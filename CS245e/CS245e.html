<!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>cs245e - Logic and Computation Enriched &vert; Fall 2020</title>
        <style>
</style>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css" integrity="sha384-yFRtMMDnQtDRO8rLpMIKrtPCD5jdktao2TV19YiZYWMDkUR5GQZR/NOVTdquEx1j" crossorigin="anonymous">
<link href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css" rel="stylesheet" type="text/css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item { list-style-type: none; } .task-list-item-checkbox { margin-left: -20px; vertical-align: middle; }
</style>
        
        <script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script>
        
    </head>
    <body class="vscode-body vscode-light">
        <h1 id="cs245e---logic-and-computation-enriched--fall-2020">cs245e - Logic and Computation Enriched | Fall 2020</h1>
<p>The course will be based off the textbook LACI by Professor Ragde</p>
<h1 id="chapter-1---introduction">Chapter 1 - Introduction</h1>
<p>Racket knowledge is a prerequisite of this course</p>
<h1 id="chapter-2---propositional-logic">Chapter 2 - Propositional logic</h1>
<p>Here are some <strong>grammar</strong> rules:</p>
<ol>
<li>if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> is an integer, then <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> is an arithmetic expression.</li>
<li>if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>E</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">E_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>E</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">E_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> are arithmetic expressions, then (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>E</mi><mn>1</mn></msub><mo>+</mo><msub><mi>E</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">E_1 + E_2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> is an arithmetic expression</li>
<li>if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>E</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">E_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>E</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">E_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> are arithmetic expressions, then (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>E</mi><mn>1</mn></msub><mo>⋅</mo><msub><mi>E</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">E_1 \cdot E_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>) is an arithmetic expression</li>
</ol>
<p>Each of these rules has a <strong>conclusions</strong> that is drawn from some <strong>premises</strong>.<br>
Such rules are called <strong>inference rule</strong>s</p>
<p>We can abbreviate by using a horizontal line where the top is the premise and below is the conclusion<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>n</mi><mo>∈</mo><mi mathvariant="double-struck">Z</mi></mrow><mrow><mi>n</mi><mo>∈</mo><mi>ε</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{n \in \mathbb{Z}}{n \in \varepsilon}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.248593em;vertical-align:-0.37237em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.876223em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mrel mtight">∈</span><span class="mord mathdefault mtight">ε</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.3939999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mrel mtight">∈</span><span class="mord mtight"><span class="mord mathbb mtight">Z</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.37237em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><msub><mi>E</mi><mn>1</mn></msub><mo>∈</mo><mi>ε</mi><msub><mi>E</mi><mn>2</mn></msub><mo>∈</mo><mi>ε</mi></mrow><mrow><mo stretchy="false">(</mo><msub><mi>E</mi><mn>1</mn></msub><mo>+</mo><msub><mi>E</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo>∈</mo><mi>ε</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{E_1 \in \varepsilon E_2 \in \varepsilon}{(E_1 + E_2) \in \varepsilon}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.4084309999999998em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8884309999999999em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:-0.05764em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mbin mtight">+</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:-0.05764em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mclose mtight">)</span><span class="mrel mtight">∈</span><span class="mord mathdefault mtight">ε</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4101em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:-0.05764em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mrel mtight">∈</span><span class="mord mathdefault mtight">ε</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:-0.05764em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mrel mtight">∈</span><span class="mord mathdefault mtight">ε</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>,</p>
<p>We can chain <strong>inferences</strong> to form a tree such that many premises lead to eventually one conclusion.</p>
<h2 id="chapter-21---formulas">Chapter 2.1 - Formulas</h2>
<p>The formulas we study will use <strong>logical connectives</strong>. They resemble arithmetic expressions.</p>
<ul>
<li>and/conjuction : <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∧</mo></mrow><annotation encoding="application/x-tex">\wedge</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.55556em;vertical-align:0em;"></span><span class="mord">∧</span></span></span></span></li>
<li>if-then/implication : <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">⇒</span></span></span></span> or <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span></li>
<li>or/disjunction : <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∨</mo></mrow><annotation encoding="application/x-tex">\vee</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.55556em;vertical-align:0em;"></span><span class="mord">∨</span></span></span></span></li>
<li>not/negation: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">¬</mi></mrow><annotation encoding="application/x-tex">\neg</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord">¬</span></span></span></span></li>
</ul>
<p>we also use propsitional variables, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo separator="true">,</mo><mi>B</mi><mo separator="true">,</mo><mi>C</mi><mo separator="true">,</mo><mo>⋯</mo></mrow><annotation encoding="application/x-tex">A, B, C, \cdots</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span></span></span></span> which represent statements or atomic propositions<br>
(assertions that must be true or false). Together with the logical connectives they make the language of <strong>propositional logic</strong></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mtext>  </mtext><mo>⟺</mo><mtext>  </mtext><mi>B</mi></mrow><annotation encoding="application/x-tex">A \iff B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.70733em;vertical-align:-0.024em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⟺</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> can be represented with <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>A</mi><mo>→</mo><mi>B</mi><mo stretchy="false">)</mo><mo>∧</mo><mo stretchy="false">(</mo><mi>B</mi><mo>→</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(A \rightarrow B) \wedge (B \rightarrow A)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">A</span><span class="mclose">)</span></span></span></span></p>
<p>Here is the grammar of propositional formulas we will use for now (will change as we go).<br>
T = X<br>
| 	(T ∧ T)<br>
| 	(T ∨ T)<br>
| 	(¬ T)<br>
| 	(T → T)</p>
<ul>
<li>X is a <strong>metavariable</strong> since it ranges over other variables</li>
<li>The grammar states that any variables X is a propositional variable</li>
<li>any and, or, negation, implication of two variables is also a propositional variable</li>
</ul>
<p>For formulas, the priority goes, Negation -&gt; conjuction/disjunction (left-associativity) -&gt; implication</p>
<h2 id="chapter-22---the-boolean-interpretation">Chapter 2.2 - The Boolean interpretation</h2>
<p>We will use 1 and 0 to represent the &quot;true&quot; and &quot;false&quot; values known as <strong>Boolean Values</strong> which form <strong>Boolean algebra</strong>.</p>
<p>We will use a Boolean interpretation by assigning our logical variables to Boolean values and considering the formula to be true,<br>
when any possible Boolean assignment evaluates to true.</p>
<p><span class="katex-error" title="ParseError: KaTeX parse error: No such environment: align* at position 7: \begin{̲a̲l̲i̲g̲n̲*̲}̲
\langle X \ran…" style="color:#cc0000">\begin{align*}
\langle X \rangle_v &amp;= v(X), ~X\mbox{ a variable}\\ \langle T \land V \rangle_v &amp;= \langle T \rangle_v \land \langle V \rangle_v \\ \langle T \lor V \rangle_v &amp;= \langle T \rangle_v \lor \langle V \rangle_v \\ \langle T \ra V \rangle_v &amp;= \langle T \rangle_v \ra \langle V \rangle_v \\ \langle \lnot T \rangle_v &amp;= \lnot \langle T \rangle_v
\end{align*}</span></p>
<p><ScrollWheelDown>We use a <strong>valuation</strong> v, which is a map/function from propoisiton variables to the Boolean values {0, 1}.<br>
For connectives with the recursive definition for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⟨</mo><mi>T</mi><msub><mo stretchy="false">⟩</mo><mi>v</mi></msub></mrow><annotation encoding="application/x-tex">\langle T \rangle_v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⟨</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mclose"><span class="mclose">⟩</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> which is the truth value assigned to formula <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span></span></span></span> by valuation <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span>.</p>
<p>To check whether a formula is true we have to try every possible combination of values, which results in exponential number of calculations.<br>
So we will continue to develop the idea of proof this chapter to prove formulas without having to go through a full truth table.</p>
<p>There are two ways that proof and truth are related.</p>
<ol>
<li><strong>soundness:</strong> &quot;if a formula has a proof, then it is true&quot; or the contrapositive &quot;if a formula is not true, then it has no proof&quot;
<ul>
<li>this will be the interpretation we use</li>
</ul>
</li>
<li><strong>completeness:</strong> &quot;if a formula is true, then it has a proof&quot;</li>
</ol>
<h2 id="chapter-23---proof-for-the-implicational-fragment">Chapter 2.3 - Proof for the implicational fragment</h2>
<p>We start by restricting the language of formulas to only propositional variables and implication.
T = X
| (T -&gt; T)</p>
<p>We write <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Γ</mi><mo>⊢</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">\Gamma\vdash T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">Γ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊢</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span></span></span></span> to mean &quot;From the assumption <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Γ</mi></mrow><annotation encoding="application/x-tex">\Gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Γ</span></span></span></span>, we can prove <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span></span></span></span>.</p>
<ul>
<li>A statement of this form is called a <strong>sequent</strong></li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Γ</mi></mrow><annotation encoding="application/x-tex">\Gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Γ</span></span></span></span> is called the <strong>context</strong></li>
<li>the symbol <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⊢</mo></mrow><annotation encoding="application/x-tex">\vdash</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mrel">⊢</span></span></span></span> is called &quot;turnstile&quot;</li>
</ul>
<p>We will use a system called <strong>natural deduction</strong> introduced by Gerhard Gentzen</p>
<p>First rule in our set of inference rules for natural deduction:
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi mathvariant="normal">Γ</mi><mo separator="true">,</mo><mi>T</mi><mo>⊢</mo><mi>W</mi></mrow><mrow><mi mathvariant="normal">Γ</mi><mo>⊢</mo><mi>T</mi><mo>→</mo><mi>W</mi></mrow></mfrac><mo stretchy="false">(</mo><mo>→</mo><mi>I</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\frac{\Gamma, T \vdash W}{\Gamma \vdash T \rightarrow W} (\rightarrow I)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.277216em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9322159999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">Γ</span><span class="mrel mtight">⊢</span><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span><span class="mrel mtight">→</span><span class="mord mathdefault mtight" style="margin-right:0.13889em;">W</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.446108em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">Γ</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span><span class="mrel mtight">⊢</span><span class="mord mathdefault mtight" style="margin-right:0.13889em;">W</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mopen">(</span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mclose">)</span></span></span></span></p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mo>→</mo><mi>I</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\rightarrow I)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mclose">)</span></span></span></span> means implication introduction (\rightarrow I)$</li>
</ul>
<p>Second rule
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi mathvariant="normal">Γ</mi><mo>⊢</mo><mi>T</mi><mo>→</mo><mi>W</mi><mi mathvariant="normal">Γ</mi><mo>⊢</mo><mi>T</mi></mrow><mrow><mi mathvariant="normal">Γ</mi><mo>⊢</mo><mi>W</mi></mrow></mfrac><mo stretchy="false">(</mo><mo>→</mo><mi>E</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\frac{\Gamma \vdash T \rightarrow W \Gamma \vdash T}{\Gamma \vdash W} (\rightarrow E)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2251079999999999em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">Γ</span><span class="mrel mtight">⊢</span><span class="mord mathdefault mtight" style="margin-right:0.13889em;">W</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">Γ</span><span class="mrel mtight">⊢</span><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span><span class="mrel mtight">→</span><span class="mord mathdefault mtight" style="margin-right:0.13889em;">W</span><span class="mord mtight">Γ</span><span class="mrel mtight">⊢</span><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mopen">(</span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span></p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo><mi>E</mi></mrow><annotation encoding="application/x-tex">\rightarrow E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span></span></span></span> means implication elimination</li>
</ul>
<p>Assumptions:<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>T</mi><mo>∈</mo><mi mathvariant="normal">Γ</mi></mrow><mrow><mi mathvariant="normal">Γ</mi><mo>⊢</mo><mi>T</mi></mrow></mfrac><mo stretchy="false">(</mo><mi>A</mi><mi>s</mi><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\frac{T \in \Gamma}{\Gamma \vdash T} (Ass)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.217331em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.872331em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">Γ</span><span class="mrel mtight">⊢</span><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.3939999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span><span class="mrel mtight">∈</span><span class="mord mtight">Γ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mord mathdefault">s</span><span class="mord mathdefault">s</span><span class="mclose">)</span></span></span></span></p>
<ul>
<li>(Ass) for assumption
Here is a better way to make this rule clear that its an <strong>axiom</strong>:<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow></mrow><mrow><mi mathvariant="normal">Γ</mi><mo separator="true">,</mo><mi>T</mi><mo>⊢</mo><mi>T</mi></mrow></mfrac><mo stretchy="false">(</mo><mi>A</mi><mi>s</mi><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\frac{}{\Gamma, T \vdash T} (Ass)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2311079999999999em;vertical-align:-0.481108em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.394em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">Γ</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span><span class="mrel mtight">⊢</span><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.481108em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mord mathdefault">s</span><span class="mord mathdefault">s</span><span class="mclose">)</span></span></span></span></li>
</ul>
<h2 id="chapter-24---proofs-as-programs">Chapter 2.4 - Proofs as programs</h2>
<p>We want to interpret logical connectives in terms of what a proof of a formula using that connective should look like.<br>
This idea is the basis of the <strong>BHK interpretation</strong> which we will be using thruoghout the rest of the course.</p>
<p>The BHK interpretation for implication is phrased as &quot;A proof of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="#cc0000"><mtext>\T</mtext></mstyle><mo>→</mo><mi>W</mi></mrow><annotation encoding="application/x-tex">\T \rightarrow W</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text" style="color:#cc0000;"><span class="mord" style="color:#cc0000;">\T</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span></span></span></span> is a construction which permits us to<br>
transform a proof of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span></span></span></span> into a proof of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi></mrow><annotation encoding="application/x-tex">W</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span></span></span></span>&quot;.</p>
<ul>
<li>the word construction could be interpreted in many ways, we will interpret it as meaning a function
t = x<br>
| (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi></mrow><annotation encoding="application/x-tex">\lambda</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">λ</span></span></span></span>x.t)
| (t t)</li>
</ul>
<p>We change our sequent notation to include proof terms. A sequent is now a three way relation <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Γ</mi><mo>⊢</mo><mi>t</mi><mo>:</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">\Gamma \vdash t : T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">Γ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊢</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span></span></span></span>,<br>
this reads as &quot;<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Γ</mi></mrow><annotation encoding="application/x-tex">\Gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Γ</span></span></span></span> proves <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span></span></span></span> with proof <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span>&quot;<br>
Here is the rule for implication introduction:<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi mathvariant="normal">Γ</mi><mo separator="true">,</mo><mi>x</mi><mo>:</mo><mi>T</mi><mo>⊢</mo><mi>t</mi><mo>:</mo><mi>W</mi></mrow><mrow><mi mathvariant="normal">Γ</mi><mo>⊢</mo><mi>λ</mi><mi>x</mi><mi mathvariant="normal">.</mi><mi>t</mi><mo>:</mo><mi>T</mi><mo>→</mo><mi>W</mi></mrow></mfrac><mo stretchy="false">(</mo><mo>→</mo><mi>I</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\frac{\Gamma, x : T \vdash t : W}{\Gamma \vdash \lambda x.t : T \rightarrow W} (\rightarrow I)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.277216em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9322159999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">Γ</span><span class="mrel mtight">⊢</span><span class="mord mathdefault mtight">λ</span><span class="mord mathdefault mtight">x</span><span class="mord mtight">.</span><span class="mord mathdefault mtight">t</span><span class="mrel mtight">:</span><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span><span class="mrel mtight">→</span><span class="mord mathdefault mtight" style="margin-right:0.13889em;">W</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.446108em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">Γ</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">x</span><span class="mrel mtight">:</span><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span><span class="mrel mtight">⊢</span><span class="mord mathdefault mtight">t</span><span class="mrel mtight">:</span><span class="mord mathdefault mtight" style="margin-right:0.13889em;">W</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mopen">(</span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mclose">)</span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi mathvariant="normal">Γ</mi><mo>⊢</mo><mi>f</mi><mo>:</mo><mi>T</mi><mo>→</mo><mi>W</mi><mi mathvariant="normal">Γ</mi><mo>⊢</mo><mi>a</mi><mo>:</mo><mi>T</mi></mrow><mrow><mi mathvariant="normal">Γ</mi><mo>⊢</mo><mi>f</mi><mi>a</mi><mo>:</mo><mi>W</mi></mrow></mfrac><mo stretchy="false">(</mo><mo>→</mo><mi>E</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\frac{\Gamma \vdash f : T \rightarrow W \Gamma \vdash a : T}{\Gamma \vdash f a : W} (\rightarrow E)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.4133239999999998em;vertical-align:-0.481108em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9322159999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">Γ</span><span class="mrel mtight">⊢</span><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight">a</span><span class="mrel mtight">:</span><span class="mord mathdefault mtight" style="margin-right:0.13889em;">W</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.446108em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">Γ</span><span class="mrel mtight">⊢</span><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mrel mtight">:</span><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span><span class="mrel mtight">→</span><span class="mord mathdefault mtight" style="margin-right:0.13889em;">W</span><span class="mord mtight">Γ</span><span class="mrel mtight">⊢</span><span class="mord mathdefault mtight">a</span><span class="mrel mtight">:</span><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.481108em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mopen">(</span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span></p>
<ul>
<li>implication elimination</li>
</ul>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow></mrow><mrow><mi mathvariant="normal">Γ</mi><mo separator="true">,</mo><mi>x</mi><mo>:</mo><mi>T</mi><mo>⊢</mo><mi>x</mi><mo>:</mo><mi>T</mi></mrow></mfrac><mo stretchy="false">(</mo><mi>V</mi><mi>a</mi><mi>r</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\frac{}{\Gamma, x : T \vdash x : T} (Var)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2311079999999999em;vertical-align:-0.481108em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.394em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">Γ</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">x</span><span class="mrel mtight">:</span><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span><span class="mrel mtight">⊢</span><span class="mord mathdefault mtight">x</span><span class="mrel mtight">:</span><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.481108em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">)</span></span></span></span></p>
<ul>
<li>we change the rule for assumptions to be called &quot;Var&quot;</li>
</ul>
<p>we can write the proof term for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi>B</mi><mo>→</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">A \rightarrow B \rightarrow A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> as<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⊢</mo><mi>λ</mi><mi>x</mi><mi mathvariant="normal">.</mi><mi>λ</mi><mi>y</mi><mi mathvariant="normal">.</mi><mi>x</mi><mo>:</mo><mi>A</mi><mo>→</mo><mi>B</mi><mo>→</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">\vdash \lambda x.\lambda y.x : A \rightarrow B \rightarrow A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mrel">⊢</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">λ</span><span class="mord mathdefault">x</span><span class="mord">.</span><span class="mord mathdefault">λ</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord">.</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span><br>
and for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>A</mi><mo>→</mo><mi>B</mi><mo stretchy="false">)</mo><mo>→</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">A \rightarrow ((A \rightarrow B) \rightarrow B)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mclose">)</span></span></span></span>:<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⊢</mo><mi>λ</mi><mi>x</mi><mi mathvariant="normal">.</mi><mi>λ</mi><mi>f</mi><mi mathvariant="normal">.</mi><mi>f</mi><mi>x</mi><mo>:</mo><mi>A</mi><mo>→</mo><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>A</mi><mo>→</mo><mi>B</mi><mo stretchy="false">)</mo><mo>→</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\vdash \lambda x.\lambda f.f x : A \rightarrow ((A \rightarrow B) \rightarrow B)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mrel">⊢</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">λ</span><span class="mord mathdefault">x</span><span class="mord">.</span><span class="mord mathdefault">λ</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mclose">)</span></span></span></span></p>
<h2 id="supplementary-material---list-abbreviations-and-pattern-matching">Supplementary material - List abbreviations and pattern matching</h2>
<p>Quote notation in racket:</p>
<pre><code class="language-Scheme"><div>&#x27;(<span class="hljs-number">1</span> x <span class="hljs-number">2</span>)
</div></code></pre>
<ul>
<li>in this code the x becomes the symbol x, but what if we wanted x as a variable?<br>
we would need:</li>
</ul>
<pre><code class="language-Scheme"><div>(<span class="hljs-name"><span class="hljs-builtin-name">list</span></span> <span class="hljs-number">1</span> x <span class="hljs-number">2</span>)
</div></code></pre>
<ul>
<li>quote notation turns any identifier or variable looking thing to a symbol i.e <code>'*</code></li>
</ul>
<p>Here's an example of an interpreter</p>
<pre><code class="language-Scheme"><div>(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> (<span class="hljs-name">interp</span> exp)
    (<span class="hljs-name"><span class="hljs-builtin-name">cond</span></span> 
        [(<span class="hljs-name"><span class="hljs-builtin-name">number?</span></span> exp) exp]
        [(<span class="hljs-name">symbol=?</span> (<span class="hljs-name">first</span> exp) <span class="hljs-symbol">&#x27;*</span>)
            (<span class="hljs-name"><span class="hljs-builtin-name">*</span></span> (<span class="hljs-name">interp</span> (<span class="hljs-name">second</span> exp))
               (<span class="hljs-name">interp</span> (<span class="hljs-name">third</span> exp)))]
        [(<span class="hljs-name">symbol=?</span> (<span class="hljs-name">first</span> exp) <span class="hljs-symbol">&#x27;+</span>)
            (<span class="hljs-name"><span class="hljs-builtin-name">+</span></span> (<span class="hljs-name">interp</span> (<span class="hljs-name">second</span> exp))
               (<span class="hljs-name">interp</span> (<span class="hljs-name">third</span> exp)))])) 
</div></code></pre>
<p>with <code>(interp '(* (+ 1 2) (+ 3 4)))</code> evaluating to 21</p>
<p>we can achieve this using <strong>Quasiquoute</strong> abbreviated with a single open quote `</p>
<ul>
<li>this allows us to escape Racket expressions, if we don't use any escapes it behaves like quote.</li>
<li>escapes are abbreviated with a comma</li>
</ul>
<pre><code class="language-Scheme"><div>(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> x <span class="hljs-number">3</span>)

`(a b ,(+ <span class="hljs-number">2</span> x))
=&gt; &#x27;(a b <span class="hljs-number">5</span>)
</div></code></pre>
<p>we can use <strong>unquote-splicing</strong> to splice a list of elements:</p>
<ul>
<li>abbreviated with ,@</li>
</ul>
<pre><code class="language-Scheme"><div>(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> x &#x27;(c d))

`(a b ,@x)
=&gt; &#x27;(a b c d)
</div></code></pre>
<p>A useful pattern-matching speciam form <code>match</code> is available in full Racket.</p>
<ul>
<li>it maches <code>cond</code> but there is an initial expression which is reduced to a value and the questiosn<br>
are replaced by patterns against whcih the value is matched</li>
</ul>
<pre><code class="language-Scheme"><div>(<span class="hljs-name">match</span> exp
    [<span class="hljs-name">pattern</span> answer]
    ...)

(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> (<span class="hljs-name">f</span> x) 
    (<span class="hljs-name">match</span> x
        [<span class="hljs-name">y</span> (<span class="hljs-name"><span class="hljs-builtin-name">+</span></span> <span class="hljs-number">3</span> y)]))
(<span class="hljs-name">f</span> <span class="hljs-number">2</span>) =&gt; <span class="hljs-number">5</span>
(<span class="hljs-name">f</span> <span class="hljs-number">5</span>) =&gt; <span class="hljs-number">8</span>

(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> (<span class="hljs-name">f</span> x)
    (<span class="hljs-name">match</span> x 
        [<span class="hljs-name">3</span> <span class="hljs-string">&quot;three&quot;</span>]
        [<span class="hljs-string">&quot;four&quot;</span> <span class="hljs-number">4</span>]
        [<span class="hljs-name">y</span> false]))
(<span class="hljs-name">f</span> <span class="hljs-number">3</span>) =&gt; <span class="hljs-string">&quot;three&quot;</span>
(<span class="hljs-name">f</span> <span class="hljs-string">&quot;four&quot;</span>) =&gt; <span class="hljs-number">4</span>
(<span class="hljs-name">f</span> <span class="hljs-number">5</span>) =&gt; false
</div></code></pre>
<ul>
<li>an identifier by itself is a pattern that matches any value</li>
<li>numbers and strings are patterns matching their values</li>
</ul>
<p>We can form compound patterns by applying list to a sequence of several patterns.</p>
<pre><code class="language-Scheme"><div>(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> (<span class="hljs-name">f</span> x)
    (<span class="hljs-name">match</span> x
        [(<span class="hljs-name"><span class="hljs-builtin-name">list</span></span> x y) (<span class="hljs-name"><span class="hljs-builtin-name">+</span></span> x y)]
        [(<span class="hljs-name"><span class="hljs-builtin-name">list</span></span> x y rst ...)
            (<span class="hljs-name"><span class="hljs-builtin-name">list</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">-</span></span> x y) rst)]
        [(<span class="hljs-name"><span class="hljs-builtin-name">list</span></span> <span class="hljs-number">1</span>) false]))

(<span class="hljs-name">f</span> &#x27;(<span class="hljs-number">1</span> <span class="hljs-number">2</span>)) =&gt; <span class="hljs-number">3</span>
(<span class="hljs-name">f</span> &#x27;(<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span>)) =&gt; &#x27;(<span class="hljs-number">-1</span> (<span class="hljs-number">3</span> <span class="hljs-number">4</span>))
(<span class="hljs-name">f</span> &#x27;(<span class="hljs-number">1</span>)) =&gt; false
</div></code></pre>
<p>Identifiers can be repeated in a pattern indicating a reptition of a value in whatever matches.</p>
<pre><code class="language-Scheme"><div>(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> (<span class="hljs-name">g</span> x)
    (<span class="hljs-name">match</span> x
        [(<span class="hljs-name"><span class="hljs-builtin-name">list</span></span> x y x) (<span class="hljs-name"><span class="hljs-builtin-name">+</span></span> x y)]
        [(<span class="hljs-name"><span class="hljs-builtin-name">list</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">list</span></span> x y) z ) (<span class="hljs-name"><span class="hljs-builtin-name">-</span></span> x z)] 
        [&#x27;(<span class="hljs-number">1</span> (<span class="hljs-number">2</span> <span class="hljs-number">3</span>)) true]))

(<span class="hljs-name">g</span> &#x27;(<span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">1</span>)) =&gt; <span class="hljs-number">4</span>
(<span class="hljs-name">g</span> &#x27;((<span class="hljs-number">4</span> <span class="hljs-number">8</span>) <span class="hljs-number">3</span>)) =&gt; <span class="hljs-number">1</span>
(<span class="hljs-name">g</span> &#x27;(<span class="hljs-number">1</span> (<span class="hljs-number">2</span> <span class="hljs-number">3</span>))) =&gt; true
</div></code></pre>
<p>Patterns can use <code>cons</code> and <code>list</code>, an <code>_</code> underscore can be used to indicate the presence of a value that we don't need to a give a name<br>
structures can also be used in patterns.</p>
<pre><code class="language-Scheme"><div>(<span class="hljs-name">struct</span> posn (<span class="hljs-name">x</span> y))
(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> (<span class="hljs-name">h</span> x)
    (<span class="hljs-name">match</span> x
        [(<span class="hljs-name"><span class="hljs-builtin-name">cons</span></span> <span class="hljs-number">1</span> (<span class="hljs-name"><span class="hljs-builtin-name">list</span></span> y z)) (<span class="hljs-name"><span class="hljs-builtin-name">+</span></span> y z)]
        [(<span class="hljs-name"><span class="hljs-builtin-name">list</span></span> p _) (<span class="hljs-name">sqr</span> p)]
        [(<span class="hljs-name">posn</span> p q)
            (<span class="hljs-name">lsit</span> p q)]))

(<span class="hljs-name">h</span> &#x27;(<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>)) =&gt; <span class="hljs-number">5</span>
(<span class="hljs-name">h</span> &#x27;(<span class="hljs-number">2</span> <span class="hljs-number">3</span>)) =&gt; <span class="hljs-number">4</span>
(<span class="hljs-name">h</span> (<span class="hljs-name">posn</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span>)) =&gt; (<span class="hljs-name"><span class="hljs-builtin-name">list</span></span> <span class="hljs-number">7</span> <span class="hljs-number">8</span>)
</div></code></pre>
<p>Quasiquote also works in pattern matching.</p>
<pre><code class="language-Scheme"><div>(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> (<span class="hljs-name">h</span> x)
  (<span class="hljs-name">match</span> x
    [`(<span class="hljs-number">1</span> ,y ,z) (<span class="hljs-name"><span class="hljs-builtin-name">+</span></span> y z)]
    [`(,(posn p q) ,r)
        (<span class="hljs-name"><span class="hljs-builtin-name">list</span></span> p q r)]
    [`(,p ,_) (<span class="hljs-name">sqr</span> p)]))
(<span class="hljs-name">h</span> &#x27;(<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>)) =&gt; <span class="hljs-number">5</span>
(<span class="hljs-name">h</span> (<span class="hljs-name"><span class="hljs-builtin-name">list</span></span> (<span class="hljs-name">posn</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span>) <span class="hljs-number">9</span>))  =&gt; &#x27;(<span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span>)
(<span class="hljs-name">h</span> (<span class="hljs-symbol">&#x27;3</span> <span class="hljs-number">4</span>)) =&gt; <span class="hljs-number">9</span>
</div></code></pre>
<p>Here's an example of our interpreter using match,</p>
<pre><code class="language-Scheme"><div><span class="hljs-comment">;; original (without using match)</span>
(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> (<span class="hljs-name">interp</span> exp)
  (<span class="hljs-name"><span class="hljs-builtin-name">cond</span></span>
    [(<span class="hljs-name"><span class="hljs-builtin-name">number?</span></span> exp) exp]
    [(<span class="hljs-name">symbol=?</span> (<span class="hljs-name">first</span> exp) <span class="hljs-symbol">&#x27;*</span>)
       (<span class="hljs-name"><span class="hljs-builtin-name">*</span></span> (<span class="hljs-name">interp</span> (<span class="hljs-name">second</span> exp))
          (<span class="hljs-name">interp</span> (<span class="hljs-name">third</span> exp)))]
    [(<span class="hljs-name">symbol=?</span> (<span class="hljs-name">first</span> exp) <span class="hljs-symbol">&#x27;+</span>)
       (<span class="hljs-name"><span class="hljs-builtin-name">+</span></span> (<span class="hljs-name">interp</span> (<span class="hljs-name">second</span> exp))
          (<span class="hljs-name">interp</span> (<span class="hljs-name">third</span> exp)))]))

<span class="hljs-comment">;; with match</span>
(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> (<span class="hljs-name">interp</span> exp)
  (<span class="hljs-name">match</span> exp
    [(<span class="hljs-name">?</span> number? n) n]
    [`(* ,x ,y) (<span class="hljs-name"><span class="hljs-builtin-name">*</span></span> (<span class="hljs-name">interp</span> x) (<span class="hljs-name">interp</span> y))]
    [`(+ ,x ,y) (<span class="hljs-name"><span class="hljs-builtin-name">+</span></span> (<span class="hljs-name">interp</span> x) (<span class="hljs-name">interp</span> y))]))
</div></code></pre>
<ul>
<li>the first pattern using ? applies the predicate <code>number?</code> to the value</li>
</ul>
<h2 id="chapter-25---proust-for-implication">Chapter 2.5 - Proust for implication</h2>
<p>Our goal is write a Racket function that validates a sequent <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Γ</mi><mo>⊢</mo><mi>t</mi><mo>:</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">\Gamma \vdash t : T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">Γ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊢</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span></span></span></span></p>
<p>We start with the goal of verifying the sequent, let's write this goal as<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Γ</mi><mo>⊢</mo><mi>t</mi><mo>⇐</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">\Gamma \vdash t \Leftarrow T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">Γ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊢</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⇐</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span></span></span></span> and call it <strong>type checking</strong>.</p>
<p>The other task we have is when we only have two of the pieces, the context <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span></span></span></span> and the term <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span><br>
and from them we need to figure out the type <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span></span></span></span>. Let's write this goal as <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Γ</mi><mo>⊢</mo><mi>t</mi><mo>⇒</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">\Gamma \vdash t \Rightarrow T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">Γ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊢</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span></span></span></span> and call it<br>
<strong>type snythesis</strong>.</p>
<ul>
<li>this approach is known as bidirectional typing and is used in real compilers
kJ:w</li>
</ul>
<p>Here are the modified inference rules:</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi mathvariant="normal">Γ</mi><mo separator="true">,</mo><mi>x</mi><mo>:</mo><mi>T</mi><mo>⊢</mo><mi>t</mi><mo>⇐</mo><mi>W</mi></mrow><mrow><mi mathvariant="normal">Γ</mi><mo>⊢</mo><mi>λ</mi><mi>x</mi><mi mathvariant="normal">.</mi><mi>t</mi><mo>⇐</mo><mi>T</mi><mo>→</mo><mi>W</mi></mrow></mfrac><mo stretchy="false">(</mo><mo>→</mo><mi>I</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\frac{ \Gamma, x : T \vdash t \Leftarrow W}{\Gamma \vdash \lambda x . t \Leftarrow T \rightarrow W} (\rightarrow I)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.0574399999999997em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714399999999998em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">Γ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊢</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">λ</span><span class="mord mathdefault">x</span><span class="mord">.</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⇐</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">Γ</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊢</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⇐</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mopen">(</span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mclose">)</span></span></span></span></span></p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi mathvariant="normal">Γ</mi><mo>⊢</mo><mi>f</mi><mo>⇒</mo><mi>T</mi><mo>→</mo><mi>W</mi><mi mathvariant="normal">Γ</mi><mo>⊢</mo><mi>a</mi><mo>⇐</mo><mi>T</mi></mrow><mrow><mi mathvariant="normal">Γ</mi><mo>⊢</mo><mi>f</mi><mi>a</mi><mo>⇒</mo><mi>W</mi></mrow></mfrac><mo stretchy="false">(</mo><mo>→</mo><mi>E</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\frac{ \Gamma \vdash f \Rightarrow T \rightarrow W \Gamma \vdash a \Leftarrow T}{\Gamma \vdash f a \Rightarrow W} (\rightarrow E)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.25188em;vertical-align:-0.8804400000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714399999999998em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">Γ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊢</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">Γ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊢</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mord">Γ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊢</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⇐</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8804400000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mopen">(</span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span></span></p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow></mrow><mrow><mi mathvariant="normal">Γ</mi><mo separator="true">,</mo><mi>x</mi><mo>:</mo><mi>X</mi><mo>⊢</mo><mi>x</mi><mo>⇒</mo><mi>X</mi></mrow></mfrac><mo stretchy="false">(</mo><mi>V</mi><mi>a</mi><mi>r</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\frac{}{\Gamma, x : X \vdash x \Rightarrow X} (Var)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.6304400000000001em;vertical-align:-0.8804400000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.677em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">Γ</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊢</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8804400000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">)</span></span></span></span></span></p>
<p>We can turn from checking to synthesis using the following rule,</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi mathvariant="normal">Γ</mi><mo>⊢</mo><mi>t</mi><mo>⇒</mo><mi>T</mi></mrow><mrow><mi mathvariant="normal">Γ</mi><mo>⊢</mo><mi>t</mi><mo>⇐</mo><mi>T</mi></mrow></mfrac><mo stretchy="false">(</mo><mi>T</mi><mi>u</mi><mi>r</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\frac{\Gamma \vdash t \Rightarrow T}{\Gamma \vdash t \Leftarrow T}(Turn)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.05744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">Γ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊢</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⇐</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">Γ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊢</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span></p>
<p>or</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi mathvariant="normal">Γ</mi><mo>⊢</mo><mi>t</mi><mo>⇒</mo><msup><mi>T</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mi>T</mi><mo>≡</mo><msup><mi>T</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><mrow><mi mathvariant="normal">Γ</mi><mo>⊢</mo><mi>t</mi><mo>⇐</mo><mi>T</mi></mrow></mfrac><mo stretchy="false">(</mo><mi>T</mi><mi>u</mi><mi>r</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\frac{\Gamma \vdash t \Rightarrow T&#x27; T \equiv T&#x27;}{\Gamma \vdash t \Leftarrow T} (Turn)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.114892em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.428892em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">Γ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊢</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⇐</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">Γ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊢</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span></p>
<p>We introduce a grammar rule for terms with a type annotation (which helps us check things that need synthesis)</p>
<p>t = x<br>
| (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi></mrow><annotation encoding="application/x-tex">\lambda</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">λ</span></span></span></span> x.t)<br>
| (t t)<br>
| (t : T)</p>
<p>Here is the grammar for types and expressions (terms) in Prous:
expr = (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi></mrow><annotation encoding="application/x-tex">\lambda</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">λ</span></span></span></span> x =&gt; expr)
| (expr expr)
| (expr : type)
| x</p>
<p>type = (type -&gt; type)
| X</p>
<p>Here are the Racket <code>struct</code>s for each grammar rule</p>
<pre><code class="language-Scheme"><div>(<span class="hljs-name">struct</span> Lam (<span class="hljs-name">var</span> body) #:transparent)
(<span class="hljs-name">struct</span> App (<span class="hljs-name">rator</span> rand) #:transparent)
(<span class="hljs-name">struct</span> Ann (<span class="hljs-name">expr</span> type) #:transparent)

(<span class="hljs-name">struct</span> Arrow (<span class="hljs-name">domain</span> range) #:transparent)
</div></code></pre>
<p>The parser:</p>
<pre><code class="language-Scheme"><div><span class="hljs-comment">;; parse-expr : sexp -&gt; Expr</span>
<span class="hljs-comment">;; sexp = symbolic expression</span>

(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> (<span class="hljs-name">parse-expr</span> s) 
    (<span class="hljs-name">match</span> s 
        [`(λ ,(? symbol? x) =&gt; ,e) (<span class="hljs-name">Lam</span> x (<span class="hljs-name">parse-expr</span> e))]
        [`(,e1, ,e2) (<span class="hljs-name">App</span> (<span class="hljs-name">parse-expr</span> e1) (<span class="hljs-name">parse-expr</span> e2))]
        [(<span class="hljs-name">?</span> symbol? x) x]
        [`(,e : ,t) (<span class="hljs-name">Ann</span> (<span class="hljs-name">parse-expr</span> e) (<span class="hljs-name">parse-type</span> t))]
        [<span class="hljs-name"><span class="hljs-builtin-name">else</span></span> (<span class="hljs-name">error</span> <span class="hljs-symbol">&#x27;parse</span> <span class="hljs-string">&quot;bad syntax: ~a&quot;</span> s)]))

<span class="hljs-comment">;; parse-type : sexp -&gt; Type</span>

(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> (<span class="hljs-name">parse-type</span> t)
    (<span class="hljs-name">match</span> t
        [`(,t1 -&gt; ,t2) (<span class="hljs-name">Arrow</span> (<span class="hljs-name">parse-type</span> t1) (<span class="hljs-name">parse-type</span> t2))]
        [(<span class="hljs-name">?</span> symbol? X) X]
        [<span class="hljs-name"><span class="hljs-builtin-name">else</span></span> (<span class="hljs-name">error</span> <span class="hljs-symbol">&#x27;parse</span> <span class="hljs-string">&quot;bad syntax: ~a\n&quot;</span> t)]))
</div></code></pre>
<p>Here are lines to add which allow for left-associative function application and right-associative arrows.</p>
<pre><code class="language-Scheme"><div><span class="hljs-comment">;; added to the end of parse-expr</span>
[`(,e1 ,e2 ,e3 ,r ...) (<span class="hljs-name">parse-expr</span> `((,e1 ,e2) ,e3 ,@r))]

<span class="hljs-comment">;; added to parse-type</span>
[`(,t1 -&gt; ,t2 -&gt; ,r ...) (<span class="hljs-name">Arrow</span> (<span class="hljs-name">parse-type</span> t1) (<span class="hljs-name">parse-type</span> `(,t2 -&gt; ,@r)))]
</div></code></pre>
<p>Here are functions which create readable strings for humans from the abstract structures:</p>
<pre><code class="language-Scheme"><div>
<span class="hljs-comment">; pretty-print-expr : Expr -&gt; String</span>
 
(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> (<span class="hljs-name">pretty-print-expr</span> e)
  (<span class="hljs-name">match</span> e
    [(<span class="hljs-name">Lam</span> x b) (<span class="hljs-name">format</span> <span class="hljs-string">&quot;(λ ~a =&gt; ~a)&quot;</span> x (<span class="hljs-name">pretty-print-expr</span> b))]
    [(<span class="hljs-name">App</span> e1 e2) (<span class="hljs-name">format</span> <span class="hljs-string">&quot;(~a ~a)&quot;</span> (<span class="hljs-name">pretty-print-expr</span> e1)
                                   (<span class="hljs-name">pretty-print-expr</span> e2))]
    [(<span class="hljs-name">?</span> symbol? x) (<span class="hljs-name">format</span> <span class="hljs-string">&quot;~a&quot;</span> x)]
    [(<span class="hljs-name">Ann</span> e t) (<span class="hljs-name">format</span> <span class="hljs-string">&quot;(~a : ~a)&quot;</span> (<span class="hljs-name">pretty-print-expr</span> e)
                                   (<span class="hljs-name">pretty-print-type</span> t))]))
 
<span class="hljs-comment">; pretty-print-type : Type -&gt; String</span>
 
(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> (<span class="hljs-name">pretty-print-type</span> t)
  (<span class="hljs-name">match</span> t
    [(<span class="hljs-name">Arrow</span> t1 t2) (<span class="hljs-name">format</span> <span class="hljs-string">&quot;(~a -&gt; ~a)&quot;</span> (<span class="hljs-name">pretty-print-type</span> t1)
                                        (<span class="hljs-name">pretty-print-type</span> t2))]
    [<span class="hljs-name"><span class="hljs-builtin-name">else</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">symbol-&gt;string</span></span> t)]))
</div></code></pre>
<pre><code class="language-Scheme"><div>
<span class="hljs-comment">; type-check : Context Expr Type -&gt; boolean</span>
<span class="hljs-comment">; produces true if expr has type t in context ctx (or error if not)</span>
 
(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> (<span class="hljs-name">type-check</span> ctx expr type)
  (<span class="hljs-name">match</span> expr
    [(<span class="hljs-name">Lam</span> x t)
       (<span class="hljs-name">match</span> type
         [(<span class="hljs-name">Arrow</span> tt tw) (<span class="hljs-name">type-check</span> (<span class="hljs-name"><span class="hljs-builtin-name">cons</span></span> `(,x ,tt) ctx) t tw)]
         [<span class="hljs-name"><span class="hljs-builtin-name">else</span></span> (<span class="hljs-name">cannot-check</span> ctx expr type)])]
    [<span class="hljs-name"><span class="hljs-builtin-name">else</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">if</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">equal?</span></span> (<span class="hljs-name">type-synth</span> ctx expr) type) true (<span class="hljs-name">cannot-check</span> ctx expr type))]))
 
<span class="hljs-comment">; type-synth : Context Expr -&gt; Type</span>
<span class="hljs-comment">; produces type of expr in context ctx (or error if can&#x27;t)</span>
<span class="hljs-comment">; all failing cases spelled out rather than put into &quot;else&quot; at end</span>
 
(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> (<span class="hljs-name">type-synth</span> ctx expr)
  (<span class="hljs-name">match</span> expr
    [(<span class="hljs-name">Lam</span> _ _) (<span class="hljs-name">cannot-synth</span> ctx expr)]
    [(<span class="hljs-name">Ann</span> e t) (<span class="hljs-name">type-check</span> ctx e t) t]
    [(<span class="hljs-name">App</span> f a)
       (<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> tf (<span class="hljs-name">type-synth</span> ctx f))
        (<span class="hljs-name">match</span> tf
         [(<span class="hljs-name">Arrow</span> tt tw) #:when (<span class="hljs-name">type-check</span> ctx a tt) tw]
         [<span class="hljs-name"><span class="hljs-builtin-name">else</span></span> (<span class="hljs-name">cannot-synth</span> ctx expr)])]
    [(<span class="hljs-name">?</span> symbol? x)
       (<span class="hljs-name"><span class="hljs-builtin-name">cond</span></span>
         [(<span class="hljs-name"><span class="hljs-builtin-name">assoc</span></span> x ctx) =&gt; second]
         [<span class="hljs-name"><span class="hljs-builtin-name">else</span></span> (<span class="hljs-name">cannot-synth</span> ctx expr)])]))
</div></code></pre>
<p>We can check <strong>tautologies</strong> (formulas that can be proved with an empty context) by using the type-synth with an empty context</p>
<pre><code class="language-Scheme"><div>(<span class="hljs-name"><span class="hljs-builtin-name">require</span></span> test-engine/racket-tests)
 
(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> (<span class="hljs-name">check-proof</span> p) (<span class="hljs-name">type-synth</span> empty (<span class="hljs-name">parse-expr</span> p)) true)
 
(<span class="hljs-name">check-expect</span> (<span class="hljs-name">check-proof</span> &#x27;((λ x =&gt; (λ y =&gt; x)) : (A -&gt; (B -&gt; A))))
              true)
</div></code></pre>
<h2 id="chapter-26---assitance-with-proofs">Chapter 2.6 - Assitance with proofs</h2>
<p>We introduce the notion of holes (or goals) which are unfinished parts of the proof represented by <code>?</code></p>
<h2 id="chapter-27---adding-the-connectives">Chapter 2.7 - Adding the connectives</h2>
<p>conjunction type checking:</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi mathvariant="normal">Γ</mi><mo>⊢</mo><mi>t</mi><mo>⇐</mo><mi>T</mi><mtext>  </mtext><mi mathvariant="normal">Γ</mi><mo>⊢</mo><mi>w</mi><mo>⇐</mo><mi>W</mi></mrow><mrow><mi mathvariant="normal">Γ</mi><mo>⊢</mo><msub><mo>∧</mo><mrow><mi>i</mi><mi>n</mi><mi>t</mi><mi>r</mi><mi>o</mi></mrow></msub><mtext> </mtext><mi>t</mi><mtext> </mtext><mi>w</mi><mo>⇐</mo><mi>T</mi><mo>∧</mo><mi>W</mi></mrow></mfrac><mo stretchy="false">(</mo><msub><mo>∧</mo><mi>I</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\frac{ \Gamma\vdash t\Leftarrow T ~~\Gamma\vdash w\Leftarrow W}
{\Gamma\vdash\land_\mathit{intro}~t~w\Leftarrow T\land W} (\land_I)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.20744em;vertical-align:-0.8360000000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.3139999999999996em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">Γ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊢</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mbin">∧</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.308752em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">i</span><span class="mord mathit mtight">n</span><span class="mord mathit mtight">t</span><span class="mord mathit mtight">r</span><span class="mord mathit mtight">o</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace nobreak"> </span><span class="mord mathdefault">t</span><span class="mspace nobreak"> </span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⇐</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">Γ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊢</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⇐</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mord">Γ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊢</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⇐</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8360000000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mopen">(</span><span class="mord"><span class="mbin">∧</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.07847em;">I</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p>
<p>conjunction type synthesis:</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi mathvariant="normal">Γ</mi><mo>⊢</mo><mi>t</mi><mo>⇒</mo><mi>T</mi><mtext>  </mtext><mi mathvariant="normal">Γ</mi><mo>⊢</mo><mi>w</mi><mo>⇒</mo><mi>W</mi></mrow><mrow><mi mathvariant="normal">Γ</mi><mo>⊢</mo><msub><mo>∧</mo><mrow><mi>i</mi><mi>n</mi><mi>t</mi><mi>r</mi><mi>o</mi></mrow></msub><mtext> </mtext><mi>t</mi><mtext> </mtext><mi>w</mi><mo>⇒</mo><mi>T</mi><mo>∧</mo><mi>W</mi></mrow></mfrac><mo stretchy="false">(</mo><msub><mo>∧</mo><mi>I</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\frac{ \Gamma\vdash t\Rightarrow T ~~\Gamma\vdash w\Rightarrow W}
{\Gamma\vdash\land_\mathit{intro}~t~w\Rightarrow T\land W} (\land_I)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.20744em;vertical-align:-0.8360000000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.3139999999999996em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">Γ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊢</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mbin">∧</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.308752em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">i</span><span class="mord mathit mtight">n</span><span class="mord mathit mtight">t</span><span class="mord mathit mtight">r</span><span class="mord mathit mtight">o</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace nobreak"> </span><span class="mord mathdefault">t</span><span class="mspace nobreak"> </span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">Γ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊢</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mord">Γ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊢</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8360000000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mopen">(</span><span class="mord"><span class="mbin">∧</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.07847em;">I</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p>
<h2 id="rest-of-the-course">Rest of the course</h2>
<p>IMO, taking notes for this course isn't beneficial as the course textbook is already well-written and does not benefit from being summarized.</p>

    </body>
    </html>