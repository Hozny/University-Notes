<!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>CS 136</title>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css" integrity="sha384-yFRtMMDnQtDRO8rLpMIKrtPCD5jdktao2TV19YiZYWMDkUR5GQZR/NOVTdquEx1j" crossorigin="anonymous">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
        <link href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css" rel="stylesheet" type="text/css">
        <style>
.task-list-item { list-style-type: none; } .task-list-item-checkbox { margin-left: -20px; vertical-align: middle; }
</style>
        <style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        
        <script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script>
    </head>
    <body class="vscode-light">
        <h1 id="cs-136">CS 136</h1>
<p>Elementary Algorithm Design and Data Abstraction</p>
<pre><code><div>Instructor: Navid Esfahani
Section: 10 / Tuesday/Thursday (4:00-5:20 or 2:30-3:50)
Email: nnasresf@uwaterloo.ca
Website: http://www.student.cs.uwaterloo.ca/~cs136/
Office: DC 2127
Office Hours: Thursday 8:30 - 10:30 am 
Lab Hours: MC 3004 / (12-5 pm on Fridays)
Textbook: Course Notes
Midterm: 
Final:
</div></code></pre>
<h1 id="p-style%22text-align-center%22-7120-p"><p style="text-align: center;"> 7/1/20 </p></h1>
<p><strong>Main topics &amp; themes:</strong></p>
<ul>
<li>Imperative programming style</li>
<li>Elementary data structures &amp; abstract data types</li>
<li>Modularization</li>
<li>Memory management &amp; state</li>
<li>Introduction to algorithm design &amp; efficiency</li>
<li>Designing &quot;medium&quot; sized, &quot;real world&quot; programs with I/O</li>
</ul>
<p><strong>Programming environment (Seashell)</strong><br>
customized &quot;Seashell&quot; development environment.</p>
<ul>
<li>browser-based for platform independence</li>
<li>Works with both C and Racket</li>
<li>Integrates with our submission &amp; testing environment</li>
<li>Helps to facilitate your own testing
<ul>
<li>Need to use vpn to connect (must be on university network)</li>
</ul>
</li>
</ul>
<p><strong>Course Materials</strong><br>
<em>Textbooks</em></p>
<ul>
<li>&quot;C Programming: A Modern Approach&quot; (CP:AMA) by K. N. King.</li>
<li>&quot;How to Design Programs&quot; (HtDP) by Felleisen, Flatt Findler, Krishnamurthi</li>
</ul>
<p><em>Course notes</em></p>
<ul>
<li>available on website</li>
</ul>
<blockquote>
<p>Go to tutorials to learn</p>
</blockquote>
<p><strong>Marking scheme</strong></p>
<ul>
<li>20% assignments (roughly weekly)</li>
<li>5% participation</li>
<li>25% midterm</li>
<li>50% final
<ul>
<li>must pass both the assignment component and weighted exam component</li>
</ul>
</li>
</ul>
<p>participation grading</p>
<ul>
<li>2 marks for a correct answer, 1 for a wrong answer</li>
<li>Your best 75% of responses are used to calculate your 5%
<ul>
<li>if u get every 3 of 4 right you get 100%</li>
</ul>
</li>
<li>each tutorial u attend will increase your 5% participation grade 0.1% (up to 1.2%, cannot exceed 5%)</li>
</ul>
<p><strong>Assignments:</strong></p>
<ul>
<li>assignment deadlines are strict, but some assignment questions may be granted a &quot;second chance&quot;</li>
<li>Most questions are marked with highest score submission</li>
<li>Hand-marked questions use the closest to the deadline with the highest score</li>
<li>Assignments can be submitted using Seashell</li>
</ul>
<p><strong>Documentation:</strong></p>
<ul>
<li>a <strong>purpose</strong> statement,</li>
<li>a <strong>contract</strong> (including a requires section if necessary)</li>
<li>unless otherwise stated you don't need templates, data definitions or examples:</li>
</ul>
<h1 id="p-style%22text-align-center%22-9120-p"><p style="text-align: center;"> 9/1/20 </p></h1>
<p><strong>C</strong> was developed by Dennis Ritchie in 1969-1973 to make the Unix operating system more portable.</p>
<ul>
<li>Named &quot;C&quot; because it was successor to &quot;B&quot;, which was a smaller version of BCPL.</li>
<li>C was designed to give programmers low-level access to memory and to be easily translatable into &quot;machine code&quot;.</li>
<li>Thousands of popular programs and portions of <strong>all</strong> popular operating systems are written in C.</li>
</ul>
<p><strong>C versions</strong> There a few different versions of the C standard. In this course, we use C99 (from 1999).</p>
<ul>
<li>The C11 standard added some new features to the language.</li>
<li>The C18 standard only fixes a few bugs from C11</li>
<li>C2x standard is currently in development.</li>
</ul>
<h2 id="c-syntax-intro">C  Syntax Intro</h2>
<p><strong>Comments</strong> any text on a line <strong>after</strong> <code>// is a comment</code>. Any text between <code>/* and */</code> is also a comment.<br>
<strong>Note:</strong> C's multi-line comment cannot be &quot;nested&quot;:</p>
<pre><code class="language-C"><div><span class="hljs-comment">/* this /* nested comment is an */</span> error */
</div></code></pre>
<p><strong>Expressions:</strong> C expressions use traditional <em>infix</em> algebraic notation (ex: 3 + 3)<br>
1 + 3 * 2 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>  </mtext><mo>⟹</mo><mtext>  </mtext></mrow><annotation encoding="application/x-tex">\implies</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.549em;vertical-align:-0.024em;"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⟹</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span></span></span> 7<br>
(1 + 3) * 2 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>  </mtext><mo>⟹</mo><mtext>  </mtext></mrow><annotation encoding="application/x-tex">\implies</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.549em;vertical-align:-0.024em;"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⟹</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span></span></span> 8</p>
<ul>
<li>Because C uses infix notation, parenthesis are needed to specify <strong>order of operations</strong>. This is not needed with prefix (or postfix) notation.</li>
</ul>
<p><strong>Operators:</strong> In addition to the traditional mathematical <em>operators</em>, c also has <em>non-mathematical</em> operators. With over 40 operators in total (CP:AMA Appendix A).</p>
<ul>
<li>C does not have an exponentiation operator (<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>x</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">x^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span>)</li>
<li>
<pre><code class="language-C"><div><span class="hljs-number">4</span> * <span class="hljs-number">5</span> / <span class="hljs-number">2</span> = (<span class="hljs-number">4</span> * <span class="hljs-number">5</span>) /<span class="hljs-number">2</span>
</div></code></pre>
</li>
</ul>
<p><strong>The / operator</strong></p>
<ul>
<li>When working with integers, the C division operator truncates (rounds toward zero) and intermediate values. Note that rounding toward zero is equivalent to &quot;removing&quot; the decimals.</li>
<li>
<pre><code class="language-C"><div><span class="hljs-number">4</span> / <span class="hljs-number">5</span> = <span class="hljs-number">0</span>
</div></code></pre>
</li>
</ul>
<p><strong>The % operator:</strong> the C <strong>modulo</strong> operator produces the <strong>remainder</strong> after integer division<br>
The value of <code>(a % b)</code> is equal to <code>a - (a / b) * b</code></p>
<ul>
<li><strong>Note:</strong> <code>(i % j)</code> has the same sign as <code>i</code>
<ul>
<li>So <code>-10 % 3 = -1</code> instead of the expected <code>2</code>
<ul>
<li>a fix would be <code>((i % j) + j) % j</code>, this is especially useful when working with array indices</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>C identifiers:</strong> Ever function, variable, and structure requires an <em>identifier</em> (or &quot;name&quot;).</p>
<ul>
<li>C identifiers must start with a letter, and can only contain letters, underscores, and numbers.</li>
<li>In this course we use <code>underscore_style</code> (or snake case). Words are separated by underscores and all letters are lowercase.
<ul>
<li><code>underscore_style</code> is the most popular style for C projects. In other languages (Java) <code>camelCaseStyle</code> is popular.</li>
<li>C identifiers can start with a leading underscore (<code>_name</code>) but they may interfere with reserved keywords. Avoid using leading underscores in this course.</li>
</ul>
</li>
</ul>
<p><strong>Anatomy of a function definition</strong></p>
<pre><code class="language-C"><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">my_add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>{
    <span class="hljs-keyword">return</span> a + b; 
}
</div></code></pre>
<ul>
<li>braces ({}) indicate the beginning/end of a function <strong>block</strong></li>
<li><code>return</code> keyword, followed by an expression, followed by a <code>;</code></li>
<li>parameters <code>(a,b)</code> are separated by a comma</li>
<li>the function and parameter <strong>types</strong> are specified (in this case, <code>int</code>)</li>
<li><strong>Note:</strong> the placement of braces and use of whitespace.</li>
</ul>
<p><strong>Static typing system:</strong> C uses a <em>static type system:</em> all types <strong>must</strong> be known <strong>before</strong> the program is run and the type of an identifier <strong>cannot change</strong>.</p>
<ul>
<li>Racket uses a <strong>dynamic</strong> type system</li>
</ul>
<p>If the type in a function definition is missing C assumes it to be an <code>int</code>:</p>
<pre><code class="language-C"><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">my_add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>{ <span class="hljs-comment">//Proper</span>
    <span class="hljs-keyword">return</span> a + b; 
}

my_add(a , b){ 
    <span class="hljs-keyword">return</span> a + b; 
}
</div></code></pre>
<ul>
<li>&quot;type&quot; runtime errors do not exists in C as the program will <strong>never</strong> compile if there is a type error.</li>
</ul>
<p><strong>Function terminology:</strong> We <strong>call</strong> a function by <strong>passing</strong> it <strong>arguments</strong>, a function <strong>returns</strong> a value.</p>
<ul>
<li>In &quot;functional&quot; language terminal we <strong>apply</strong></li>
</ul>
<h2 id="functions-without-parameters"><strong>Functions without parameters:</strong></h2>
<p>use the <code>void</code> keyword to indicate a function has no parameters.</p>
<pre><code class="language-C"><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">my_num</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>{
    <span class="hljs-keyword">return</span> my_add(<span class="hljs-number">40</span>,<span class="hljs-number">2</span>);
}
</div></code></pre>
<ul>
<li>To call a parameterless function, put nothing between the parentheses.</li>
</ul>
<p>C allows the omission of <code>void</code> which indicates an &quot;unknown&quot; or &quot;arbitrary&quot; number of parameters (beyond the scope of this course). <strong>Always use</strong> <code>void</code>.</p>
<ul>
<li>When writing programs, do not write programs which do what you intend, rather write programs which are not able to do anything except for what is intended.</li>
</ul>
<p><strong>No nested function:</strong> In C we are not able to define nested functions. This feature was added to the GNU C compiler but is not found in C Standard.</p>
<pre><code class="language-C"><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">top</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">nested_func</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>{
        <span class="hljs-comment">//...</span>
        <span class="hljs-comment">// This is not possible</span>
    }
}
</div></code></pre>
<h2 id="function-documentations"><strong>Function Documentations</strong></h2>
<p><strong>Whitespaces</strong> C mostly ignores whitespace.</p>
<pre><code class="language-C"><div><span class="hljs-comment">// The following three functions are equivalent</span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">my_add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>{  <span class="hljs-comment">//Good</span>
    <span class="hljs-keyword">return</span> a + b; 
}
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">my_add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>{ <span class="hljs-keyword">return</span> a + b; <span class="hljs-comment">//Bad</span>
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">my_add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> <span class="hljs-comment">//Very bad</span>
b)</span></span>{<span class="hljs-keyword">return</span> a+
b ; }
</div></code></pre>
<p><strong>CS 136 style:</strong></p>
<pre><code class="language-C"><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">my_add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>{  <span class="hljs-comment">//Good</span>
    <span class="hljs-keyword">return</span> a + b; 
}
</div></code></pre>
<ul>
<li>a block start (open brace {) appears at the end of a line</li>
<li>a block end (close brace }) is aligned with the line that started it, and appears on a line by itself</li>
<li>indent a block 2 (recommended), 3 or 4 spaces: <strong>be consistent</strong></li>
<li>add a space after commas and around arithmetic operators</li>
</ul>
<pre><code class="language-C"><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">my_super_long_function</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> c, <span class="hljs-keyword">int</span> d, 
                           <span class="hljs-keyword">int</span> e, <span class="hljs-keyword">int</span> f, <span class="hljs-keyword">int</span> g)</span> </span>{
    <span class="hljs-keyword">return</span> a * b + b * c + c * d + d * e + d + d * e
           d + e; 
}
</div></code></pre>
<ul>
<li>align code when lines are too long</li>
</ul>
<p><strong>Entry point:</strong> Typically a program is run by an Operating System (OS) through a shell or another program such as DrRacket. The SO needs to know where to <strong>start</strong> running the code.</p>
<p><strong>main:</strong> main has no parameters (for now) and <code>int</code> return type.</p>
<pre><code class="language-C"><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>{
    <span class="hljs-comment">//...</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<ul>
<li>The <code>return</code> value communicates to the OS the &quot;error code&quot; also know as &quot;exit code&quot;, &quot;error number&quot; or <code>errno</code></li>
<li>A successful program <code>returns</code> <strong>zero</strong> (no error code).</li>
</ul>
<h1 id="p-style%22text-align-center%22-14120-p"><p style="text-align: center;"> 14/1/20 </p></h1>
<p><strong>Top level expressions:</strong> In C, <em>top-level expressions</em> (code outside of a function) are <strong>not</strong> allowed.</p>
<ul>
<li>Code only execute <strong>inside</strong> of a function</li>
</ul>
<pre><code class="language-C"><div><span class="hljs-number">1</span> + <span class="hljs-number">1</span>; <span class="hljs-comment">// INVALID</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">my_add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>{
    <span class="hljs-keyword">return</span> a + b; 
}
</div></code></pre>
<p><strong>Tracing expressions:</strong> Seashell provides <em>tracing tools</em> to help you &quot;see&quot; what your code is doing. <code>trace_int</code> is a function that allows you trace integers.</p>
<pre><code class="language-C"><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>{
    trace_int(<span class="hljs-number">1</span> + <span class="hljs-number">1</span>); 
    trace_int(my_add(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)); 
}
</div></code></pre>
<h2 id="running-our-first-program">Running our first program</h2>
<pre><code class="language-C"><div><span class="hljs-comment">// First C program (documentation omitted)</span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"cs136.h"</span>  <span class="hljs-comment">// &lt;-- More on this later</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">my_add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>{
    <span class="hljs-keyword">return</span> a + b; 
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>{
    trace_int(<span class="hljs-number">1</span>+<span class="hljs-number">1</span>);
    trace_int(my_add(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>));
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; 
}
</div></code></pre>
<ul>
<li>For now, include &quot;cs136.h&quot; for all programs</li>
</ul>
<h2 id="function-ordering"><strong>Function ordering:</strong></h2>
<ul>
<li>For now, always place function definitions <strong>above</strong> any other functions that reference them (so <code>main</code> is at the bottom).
<ul>
<li>There are ways to bypass this, but we will explore that later</li>
</ul>
</li>
</ul>
<h2 id="program-documentation"><strong>Program documentation:</strong></h2>
<ul>
<li>Document a program (state its purpose) at the <strong>top</strong> of the file (not necessarily where <code>main</code> is).</li>
</ul>
<h2 id="testing"><strong>Testing:</strong></h2>
<ul>
<li><em>tracing tools</em> are an excellent way for you to &quot;see&quot; what is happening
<ul>
<li>They are helpful to <em>informally</em> test code</li>
<li>They are not ways to <em>thoroughly</em> test code</li>
</ul>
</li>
</ul>
<h2 id="boolean-expressions"><strong>Boolean expressions:</strong></h2>
<ul>
<li>In C, boolean expressions do not produces &quot;true&quot; or &quot;false&quot;, they produce either:
<ul>
<li>Zero (<code>0</code>) for &quot;false&quot;</li>
<li>one (<code>1</code>) for &quot;true&quot;</li>
</ul>
</li>
</ul>
<h2 id="comparison-operators"><strong>Comparison operators:</strong></h2>
<p>The <em>equality</em> <strong>operator</strong> in C is <code>==</code> (not the <strong>double</strong> equals)<br>
(3 == 3) <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">⇒</span></span></span></span> 1 (true)<br>
(2 == 3) <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">⇒</span></span></span></span> 0 (false)<br>
The <em>not equal</em> <strong>operator</strong> is <code>!=</code><br>
(2 != 3) <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">⇒</span></span></span></span> 1 (true)</p>
<p>The operators &lt;, &lt;=, &gt; and &gt;= behave exactly as expected.</p>
<ul>
<li>The accidental use of a single <code>=</code> instead of a double <code>==</code> for equality is one of the most common programming mistakes in C. This can be a serious bug.</li>
</ul>
<h2 id="logical-operators"><strong>Logical Operators:</strong></h2>
<p>The logical operators are ! (not), &amp;&amp; (and), || (or):</p>
<p>Similarly to Racket, C <em>short-circuits</em> and stops evaluating logical operators as soon as possible.</p>
<p><strong>All non-zero values are true:</strong></p>
<ul>
<li>operators that produce a Boolean value will always produce <code>0</code> or <code>1</code></li>
<li>Operators that expect a Boolean value will consider <strong>any non-zero value</strong> to be <strong>&quot;true&quot;</strong>
<ul>
<li><strong>Only zero (0) is &quot;false&quot;</strong>
<ul>
<li>The value <code>NULL</code> is also considered false. but in most implementations is evaluated as <code>0</code> anyway.</li>
</ul>
</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>Operator</th>
<th>Symbol</th>
</tr>
</thead>
<tbody>
<tr>
<td>Negations</td>
<td><code>!</code></td>
</tr>
<tr>
<td>multiplicative</td>
<td><code>* / %</code></td>
</tr>
<tr>
<td>additive</td>
<td><code>+ -</code></td>
</tr>
<tr>
<td>comparison</td>
<td><code>&lt; &lt;= &gt;= &gt;</code></td>
</tr>
<tr>
<td>equality</td>
<td><code>== !=</code></td>
</tr>
<tr>
<td>and</td>
<td><code>&amp;&amp;</code></td>
</tr>
<tr>
<td>or</td>
<td><code>||</code></td>
</tr>
</tbody>
</table>
<h2 id="bool-type"><strong>Bool type</strong></h2>
<p>The <code>bool</code> type is an integer that can only have a value <code>0</code> or <code>1</code>.</p>
<pre><code class="language-C"><div><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">is_even</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{
    <span class="hljs-keyword">return</span> (n % <span class="hljs-number">2</span>) == <span class="hljs-number">0</span>;
}
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">my_negate</span><span class="hljs-params">(<span class="hljs-keyword">bool</span> v)</span> </span>{
    <span class="hljs-keyword">return</span> !v; 
}
</div></code></pre>
<ul>
<li>You can technically add integers to booleans, but just because you can doesn't mean you should</li>
</ul>
<h2 id="assertion"><strong>Assertion</strong></h2>
<p>use the <code>assert</code> function to test functions:</p>
<pre><code class="language-C"><div>assert(my_add(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>) == <span class="hljs-number">3</span>); 
</div></code></pre>
<p><code>assert(exp)</code> <strong>stops</strong> the program and displays a message if the expression <code>exp</code> is false (zero).</p>
<p>if exp is true (non-zero), it does &quot;nothing&quot; and continues to the next line of code.</p>
<ul>
<li>assert is very similar to Racket's <code>check-expect</code>:</li>
</ul>
<pre><code class="language-C"><div><span class="hljs-comment">// My second C program (now with better testing!)</span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"cs136.h"</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">my_add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>{
    <span class="hljs-keyword">return</span> a + b; 
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>{
    assert(my_add(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)==<span class="hljs-number">3</span>);
    assert(my_add(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>)==<span class="hljs-number">4</span>);
}
</div></code></pre>
<h2 id="function-requirements"><strong>Function requirements</strong></h2>
<p>The <code>assert</code> function is also very useful for <strong>verifying function requirements</strong>.</p>
<pre><code class="language-C"><div><span class="hljs-comment">// my_divide(x, y) ...</span>
<span class="hljs-comment">// requires: y is not 0 </span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">my_divide</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>{
    assert(y!=<span class="hljs-number">0</span>);
    <span class="hljs-keyword">return</span> x/y; 
}
</div></code></pre>
<h2 id="infeasible-requirements"><strong>Infeasible requirements</strong></h2>
<p>Some requirements are <em>infeasible</em> to assert, or they would be <em>inefficient</em> to assert.<br>
It is good style to communicate that a requirement is not asserted</p>
<pre><code class="language-C"><div><span class="hljs-comment">// some function ... </span>
<span class="hljs-comment">// requires: n is a prime number [not asserted]</span>
</div></code></pre>
<h2 id="multiple-requirements"><strong>Multiple requirements</strong></h2>
<p>With multiple requirements, it is better to have several small <code>assert</code>s. It makes it easier to determine which assertion failed.</p>
<pre><code class="language-C"><div><span class="hljs-comment">// </span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">my_function</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> z)</span> </span>{
    assert((x &gt; <span class="hljs-number">0</span>) &amp;&amp; (y &lt; z)); 
}
</div></code></pre>
<h2 id="statements"><strong>Statements</strong></h2>
<p>Blocks (<code>{}</code>) can contain multiple <em>statements:</em></p>
<pre><code class="language-C"><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">my_divide</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x , in y)</span> </span>{
    assert(y)      <span class="hljs-comment">// statement</span>
    trace_int(y)   <span class="hljs-comment">// statement</span>
    <span class="hljs-keyword">return</span> x / y;  <span class="hljs-comment">// statement</span>
    trace_int(x);  <span class="hljs-comment">// unreachable statement</span>
}
</div></code></pre>
<p>Statements are executed <em>in</em> sequence (on after the other).<br>
The <code>return</code> statement <strong>ends</strong> the function. In the above code, <code>trace_int(x)</code> will never run.</p>
<h2 id="brief-introduction-to-control-flow"><strong>Brief introduction to control flow</strong></h2>
<p>The <code>return</code> statement is a special kind of statement known as a <em>control flow</em> statement.<br>
<code>return</code> &quot;controls the flow&quot; of the program by ending the function and returning to the caller.</p>
<h2 id="conditionals"><strong>Conditionals</strong></h2>
<p>The <code>if</code> control flow statement allows us to have functions with conditional behaviour.</p>
<pre><code class="language-C"><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">my_abs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{
    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">0</span>) { <span class="hljs-comment">// note: the () are required</span>
        <span class="hljs-keyword">return</span> -n; 
    } <span class="hljs-keyword">else</span> {     <span class="hljs-comment">// In CS136 they have else on the same line on the closing }</span>
        <span class="hljs-keyword">return</span> n; 
    }
}
</div></code></pre>
<ul>
<li>There can be more than one <code>return</code> in a function, but only one can ever execute.</li>
</ul>
<h2 id="else-if"><strong>else if</strong></h2>
<p>if there are more than wo possible results, use <code>else if</code></p>
<pre><code class="language-C"><div><span class="hljs-comment">// in_between(x, lo, hi) determines if lo &lt;= x &lt;= hi</span>
<span class="hljs-comment">// requires: lo &lt;= hi</span>

<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">in_between</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> lo, <span class="hljs-keyword">int</span> hi)</span> </span>{ 
    assert(lo&lt;=hi); 
    <span class="hljs-keyword">if</span> (x &lt; lo) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x &gt; hi) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; 
    }
}
</div></code></pre>
<p><strong>The C ternary conditional operator</strong> (<code>?:</code>)</p>
<pre><code class="language-C"><div>q ? a : b
</div></code></pre>
<ul>
<li><code>a</code> if <code>q</code> is <code>true</code>, <code>b</code> if <code>q</code> is <code>false</code></li>
</ul>
<pre><code class="language-C"><div>(v &gt;= <span class="hljs-number">0</span>) ? v : -v;      <span class="hljs-comment">// abs(v)</span>
(a &gt; b) a : b;          <span class="hljs-comment">// max(a, b)</span>
</div></code></pre>
<p>Goals of this section</p>
<ul>
<li>Demonstrate the use of C syntax and terminology</li>
<li>Write a simple function in C</li>
<li>Use the C operators introduced in this module</li>
<li>Explain the significance of the <code>main</code> function in C</li>
<li>Perform basic tracing in C using <code>trace_int</code></li>
<li>Use assert for testing and to verify requirements</li>
<li>Provide the required documentation for C functions</li>
</ul>
<h2 id="introduction-to-imperative-c"><strong>Introduction to imperative C</strong></h2>
<p>Readings: CP:AMA</p>
<h2 id="functional-programming"><strong>Functional programming</strong></h2>
<ul>
<li>functions are &quot;pure&quot; (a.k.a &quot;mathematical&quot;)
<ul>
<li>functions <strong>only return values</strong></li>
<li>return values <strong>only depend</strong> on argument values</li>
</ul>
</li>
<li>only <strong>constants</strong> are used</li>
</ul>
<p>In the imperative programming paradigm functions may be &quot;<strong>impure</strong>&quot; and will <strong>use variables</strong></p>
<h2 id="compound-statement"><strong>Compound statement</strong></h2>
<p>In imperative programming, a <strong>sequence of instructions</strong> (or &quot;statements&quot;) are executed. We have already seen this:</p>
<pre><code class="language-C"><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>{ 
    trace_int(<span class="hljs-number">1</span>+<span class="hljs-number">1</span>); 
    assert(<span class="hljs-number">3</span> &gt; <span class="hljs-number">2</span>); 
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; 
}
</div></code></pre>
<p>A block <code>{}</code> is formally known as a <em>compound statement</em>, which is simple a <strong>sequence of statements</strong> to be executed in order</p>
<ul>
<li>blocks can contain local variable definitions</li>
</ul>
<h2 id="io-inputoutput"><strong>I/O</strong> (input/output)</h2>
<ul>
<li>in this course we use simple <strong>text-based</strong> I/O.</li>
</ul>
<h2 id="text-io"><strong>Text I/O</strong></h2>
<p>To displace text output in C, we use the <code>printf</code> function.</p>
<pre><code class="language-C"><div><span class="hljs-comment">// My first program with I/O</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"cs136.h"</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>{
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Hello, World"</span>); 
}
</div></code></pre>
<h1 id="p-style%22text-align-center%22-16120-p"><p style="text-align: center;"> 16/1/20 </p></h1>
<h2 id="text-io-1"><strong>Text I/O ...</strong></h2>
<p>The <strong>newline</strong> character (<code>\n</code>) is necessary to properly format output to appear on multiple lines</p>
<ul>
<li>by default <code>printf</code> does not print a new line each time</li>
</ul>
<p>To output values, use a <strong>format specifier</strong> (the <strong>f</strong> in print<strong>f</strong>).</p>
<ul>
<li>For an integer in &quot;<strong>d</strong>ecimal format the format specifier is <code>%d</code></li>
</ul>
<pre><code class="language-C"><div><span class="hljs-built_in">printf</span>(<span class="hljs-string">"2 + 2 is %d"</span>,<span class="hljs-number">2</span>+<span class="hljs-number">2</span>);
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d + %d is: %d\n"</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>+<span class="hljs-number">2</span>);
<span class="hljs-comment">// 2 + 2 is: 4</span>
</div></code></pre>
<p>If you would like to print a percent sign (%), use two (%%).</p>
<pre><code class="language-C"><div><span class="hljs-built_in">printf</span>(<span class="hljs-string">"I am %d%% sure you should watch your"</span>,<span class="hljs-number">100</span>);
<span class="hljs-comment">// I am 100% sure you should watch your</span>
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"spacing!\n"</span>);
</div></code></pre>
<p>Similarly,</p>
<ul>
<li>to print a backslash (<code>\</code>) use two (<code>\\</code>)</li>
<li>To print a quote add a backslash (<code>\&quot;</code>)</li>
</ul>
<h2 id="side-effects-and-state-introduction">Side effects and state (introduction)</h2>
<p>In general, a programming side effect is when the <strong>state</strong> of something &quot;changes&quot;.<br>
State refers to the value of some data (or &quot;information&quot;) <strong>at a moment in time</strong>.</p>
<ul>
<li>You have a blank piece of paper, then you write your name on that paper.
<ul>
<li>You have changed the state of that paper: at one moment it was blank, and in the next it was &quot;autographed&quot;</li>
<li>The side effect of writing your name was that you changed the state of the paper</li>
</ul>
</li>
</ul>
<h2 id="documenting-side-effects">Documenting side effects</h2>
<p>The <code>printf</code> function has a side effect: it changes the output or &quot;display&quot;</p>
<pre><code class="language-C"><div><span class="hljs-comment">// noisy_abs(n) computes |n|</span>
<span class="hljs-comment">// effects: may produce output</span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">noise_abs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{
    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">0</span>) {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Yo! I'm changing the sign!\n"</span>);
        <span class="hljs-keyword">return</span> -n;
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> n; 
    }
}
</div></code></pre>
<p>In this course there is no need to provide any detail in the &quot;effects&quot; section <code>// effects: produces output</code> is sufficient.</p>
<ul>
<li>occasionally you want to describe the output in the purpose if the output is important in understanding the core behaviour of the function</li>
</ul>
<h2 id="debugging-tools">Debugging tools</h2>
<p>Statement used for debugging and informal testing (assert, trace_int) are <strong>not</strong> considered side effects.</p>
<h2 id="io-terminology">I/O terminology</h2>
<p>In the context I/O, be careful with eerminoloy.</p>
<pre><code class="language-C"><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sqr</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{
    <span class="hljs-keyword">return</span> n * n; 
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">noise_sqr</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Yo! I'm squaring %d!\n"</span>,n);
    <span class="hljs-keyword">return</span> n * n; 
}
</div></code></pre>
<ul>
<li>informally, someone might say: if you <strong>input</strong> <code>7</code> into <code>sqr</code>, it <strong>outputs</strong> <code>49</code>
<ul>
<li>We say if <code>7</code> is <strong>passed</strong> into <code>sqr</code> it <strong>returns</strong> <code>49</code></li>
<li>if <code>7</code> is <strong>passed</strong> into <code>noisy_sqr</code> it <strong>outputs</strong> a message and <strong>returns</strong> <code>49</code>.</li>
</ul>
</li>
</ul>
<blockquote>
<p>Our tracing tools print to a different output <strong>stream</strong> than <code>printf</code> (like writing on two different pieces of paper). By default <code>printf</code> outputs to <code>stdout</code> (<strong>st</strong>andard <strong>out</strong>put stream). Our tracing tools print to <code>stderr</code> (<strong>st</strong>andard <strong>err</strong>or stream).</p>
</blockquote>
<h2 id="void-functions">Void functions</h2>
<pre><code class="language-C"><div><span class="hljs-comment">// Display score: produces score</span>
<span class="hljs-comment">// Effects produces output</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">display_score</span><span class="hljs-params">(<span class="hljs-keyword">int</span> score, <span class="hljs-keyword">int</span> max)</span> </span>{ 
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"your score is %d out of %d.\n"</span>, score, max)
}
</div></code></pre>
<ul>
<li>In a void function, the return is optional and has no expression.</li>
</ul>
<h2 id="expression-statements">Expression statements</h2>
<p>An <strong>expression statement</strong> is an expression with a semicolon (<code>;</code>)</p>
<pre><code class="language-C"><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>{ 
    <span class="hljs-number">11</span>;
    <span class="hljs-number">10</span> + <span class="hljs-number">1</span>; 
    sqr(<span class="hljs-number">6</span>) - sqr(<span class="hljs-number">5</span>); 
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"expression\n"</span>);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"five\n"</span>)+<span class="hljs-number">6</span>;
}
</div></code></pre>
<ul>
<li>The <strong>value</strong> of an expression statement is <strong>discarded</strong> after it is executed.
<ul>
<li>The purpose of an expression statement is to generate <strong>side effects</strong>
<ul>
<li>In the example above the <code>printf</code> statements produce an output side effect</li>
<li>but <code>11;</code> produces no side effect which can result in a warning by some compilers but the program still runs</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="return-value-of-printf">Return value of <code>printf</code></h2>
<p>Surprisingly <code>printf</code> is not a <code>void</code> function it (<code>return</code>s an <code>int</code>)</p>
<ul>
<li><code>printf</code> returns the number of characters that were printed</li>
</ul>
<h2 id="statements-1">Statements</h2>
<ul>
<li><strong>Compound statements (blocks)</strong>
<ul>
<li>a sequence of statements (to be executed in order)</li>
</ul>
</li>
<li><strong>Expression statements</strong>
<ul>
<li>for generating side effects (<strong>values are discarded after execution</strong>)</li>
</ul>
</li>
<li><strong>Control flow statement</strong>
<ul>
<li>control the order in which other statements are executed</li>
</ul>
</li>
</ul>
<h2 id="variables">Variables</h2>
<p><strong>Variables</strong> store values
To define a variable in C, we need (in order):</p>
<ul>
<li>the <strong>type</strong> (<code>int</code>)</li>
<li>the <strong>identifier</strong> (&quot;name&quot;)</li>
<li>the <strong>initial value</strong></li>
</ul>
<pre><code class="language-C"><div><span class="hljs-keyword">int</span> my_variable = <span class="hljs-number">7</span>; <span class="hljs-comment">// definition</span>
</div></code></pre>
<p>Definitions <strong>are not</strong> statements.</p>
<h2 id="mutation">Mutation</h2>
<p>When the value of a variable is changed, it is known as <strong>mutation</strong></p>
<pre><code class="language-C"><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>{
    <span class="hljs-keyword">int</span> m = <span class="hljs-number">5</span>; 
    trace_int(m);   <span class="hljs-comment">// definition (with initialization)</span>
    m = <span class="hljs-number">6</span>; 
    trace_int(m);   <span class="hljs-comment">// mutation!</span>
    m = <span class="hljs-number">-1</span>; 
    trace_int(m);   <span class="hljs-comment">// more mutation!</span>
}
</div></code></pre>
<p>Mutation is a <strong>side effect</strong></p>
<h2 id="assignment-operator">Assignment operator</h2>
<p>In C, mutation is achieved with the <strong>assignment operator</strong> (<code>=</code>)</p>
<pre><code class="language-C"><div>m = m + <span class="hljs-number">1</span>; 
</div></code></pre>
<ul>
<li>The &quot;right hand side&quot; RHS must be an <em>expression</em> that produces a <strong>value</strong> with the same type as     LHS.</li>
<li>The LHS <strong>must</strong> be the name of a variable</li>
<li>The LHS variable is mutated to store the <strong>value</strong> of the RHS</li>
<li>This is a side effect
<ul>
<li><strong>Note</strong> assignment evaluates to the RHS so <code>if(n=1)</code> passes</li>
</ul>
</li>
</ul>
<p><strong>Pro tip:</strong> some defensive programmers get in the habit of writing equalities as <code>(13 == i)</code> this makes it so that if one equals is missed it produces an error rather than being a bug.</p>
<h2 id="initialization">Initialization</h2>
<p>C allows a variable definition without initialization, but is bad style.</p>
<pre><code class="language-C"><div><span class="hljs-keyword">int</span> my_variable = <span class="hljs-number">7</span>;    <span class="hljs-comment">// initialized</span>
<span class="hljs-keyword">int</span> another_variable;   <span class="hljs-comment">// uninitialized</span>
</div></code></pre>
<ul>
<li>Always initialize variables</li>
</ul>
<h2 id="initialization-is-not-assignment">Initialization is not assignment</h2>
<ul>
<li>The <code>=</code> use in initialization is <strong>not</strong> the assignment operator.</li>
</ul>
<pre><code class="language-C"><div><span class="hljs-keyword">int</span> n = <span class="hljs-number">5</span>;  <span class="hljs-comment">// initialization syntax</span>
n = <span class="hljs-number">6</span>;  <span class="hljs-comment">// assignment operator </span>
</div></code></pre>
<ul>
<li>This matters more later on in object oriented programming where assignment is more apparently different than initialization</li>
</ul>
<h2 id="more-assignment-operators">More assignment operators</h2>
<pre><code class="language-C"><div> x += <span class="hljs-number">2</span>;    <span class="hljs-comment">// x = x + 2; </span>
 ++x;   x++; <span class="hljs-comment">// x += 1;   </span>
</div></code></pre>
<ul>
<li>the prefix (<code>++x</code>) and postfix (<code>x++</code>) both increment by <code>1</code>
<ul>
<li><code>x++</code> produces the &quot;old&quot; value of <code>x</code> then increments by <code>1</code></li>
<li><code>++x</code> increments <code>x</code> then produces the &quot;new&quot; value of <code>x</code></li>
</ul>
</li>
<li>prefix (<code>++x</code>) is usually preferred to improve clarity and efficiency</li>
</ul>
<h1 id="p-style%22text-align-center%22-21120-p"><p style="text-align: center;"> 21/1/20 </p></h1>
<h2 id="constants">Constants</h2>
<p>A <strong>constant</strong> is a variable that is <strong>immutable</strong>. In other words, the value of a constant cannot be changed.</p>
<pre><code class="language-C"><div><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> my_constant = <span class="hljs-number">42</span>
</div></code></pre>
<ul>
<li>In this course <strong>variable</strong> refers to both constants and</li>
</ul>
<p>It is <strong>good style</strong> to use <code>const</code> as much as possible (whenever it is appropriate):</p>
<ul>
<li>communicates the intended use of the variable</li>
<li>prevents accidental or unintended mutation</li>
<li>may help optimize your code</li>
</ul>
<h2 id="global-and-local-variables">Global and local variables</h2>
<p>Variables are either <strong>global</strong> or <strong>local</strong></p>
<ul>
<li><strong>Global</strong> variables are defined <em>outside</em> of functions</li>
<li><strong>Local</strong> variables are defined <em>inside</em> of functions</li>
</ul>
<pre><code class="language-C"><div><span class="hljs-keyword">int</span> my_global_variable = <span class="hljs-number">7</span>; 
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>{
    <span class="hljs-keyword">int</span> my_local_variable = <span class="hljs-number">11</span>; 
    <span class="hljs-comment">//...</span>
}
</div></code></pre>
<h2 id="variable-scope">Variable Scope</h2>
<p>The <strong>scope</strong> of a variable is the region of code where it is accessible</p>
<h2 id="block-local-scope">Block (local scope)</h2>
<p>Local variables have <strong>block scope</strong>. their scope extended from their definition to the end of the block they are defined in.</p>
<pre><code class="language-C"><div><span class="hljs-keyword">int</span> n = <span class="hljs-number">1</span>; 

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>{
    trace_int(n);           <span class="hljs-comment">// n =&gt; 1</span>
    <span class="hljs-keyword">int</span> n = <span class="hljs-number">2</span>; 
    trace_int(n);           <span class="hljs-comment">// n =&gt; 2</span>
    {
        <span class="hljs-keyword">int</span> n = <span class="hljs-number">3</span>; 
        trace_int(n);       <span class="hljs-comment">// n =&gt; 3</span>
    }
    trace_int(n);           <span class="hljs-comment">// n =&gt; 2</span>
}
</div></code></pre>
<ul>
<li>Note how <code>n</code> is equal to the value assigned in the nearest scope</li>
<li>Also there is probably not much good use for opening and closing curly braces in the middle of another block</li>
</ul>
<p>In older versions of C all local variable definitions had to be at the start of a function block (before any statements). In C99 you may define a local variable anywhere in a block.</p>
<p>Modern programming guides recommend that you define a variable:</p>
<ul>
<li>in the narrowest scope possible</li>
<li>as close to its first use as possible
<ul>
<li>This improves readability and ensure</li>
</ul>
</li>
</ul>
<pre><code class="language-C"><div><span class="hljs-keyword">int</span> a = <span class="hljs-number">2</span>; 
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">int</span> n = <span class="hljs-number">3</span>; 
    <span class="hljs-comment">// Here</span>
}
<span class="hljs-keyword">int</span> b = <span class="hljs-number">5</span>; 
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">int</span> v = <span class="hljs-number">3</span>; 
    f(); 
}
</div></code></pre>
<ul>
<li><strong>Note</strong> the function <code>f()</code> does not have access to the variable <code>v</code>, <code>v</code> is not in the scope of <code>f()</code>. But <code>a</code> is. <code>b</code> is <strong>not</strong>.</li>
</ul>
<h2 id="%22impure%22-functions">&quot;Impure&quot; functions</h2>
<p>Recall that the functional paradigm requires &quot;pure&quot; functions:</p>
<ul>
<li>functions <strong>only return values</strong> (no side effects)</li>
<li>Return values <strong>only depend</strong> on argument values</li>
</ul>
<p>Impure functions are sometimes called &quot;procedure&quot; or &quot;routines&quot; to distinguish behaviour from &quot;pure&quot; functions</p>
<h2 id="mutating-global-variables">Mutating global variables</h2>
<p>A function that mutates a global variable has a <em>mutation</em> side effect (which makes it &quot;impure&quot;).</p>
<ul>
<li>Mutating a <strong>local variable</strong> does <strong>not</strong> give a function a side effect</li>
</ul>
<h2 id="mutating-parameters">Mutating parameters</h2>
<p>Parameters are nearly <em>indistinguishable</em> from local variables, and can also be mutated.</p>
<ul>
<li>mutating parameters is not a local function</li>
</ul>
<h2 id="global-dependency">Global dependency</h2>
<p>A function that depends on a global <em>mutable</em> variable is &quot;impure&quot; even it has <strong>no</strong> side effects.</p>
<ul>
<li>if the global variable is constant it is technically impure, but you could always have the constant value inside the function instead to make it pure so it is pure in a sense?</li>
</ul>
<p>A &quot;pure&quot; function only depends on its argument values.</p>
<h2 id="avoiding-global-mutable-variables">Avoiding global mutable variables</h2>
<p>Global <em>mutable</em> variables are almost always poor style and should be avoided.<br>
Unless otherwise specified, you are <strong>note allowed</strong> to use global <em>mutable</em> variable on your assignments.<br>
On the other hand, global <em>constants</em> are great style and strongly encouraged.</p>
<h2 id="static-local-variables">Static local variables</h2>
<p>Have the scope of a local variable, but the duration of a global variable. Their value persists between function calls.</p>
<pre><code class="language-C"><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">increment</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>{
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> counter = <span class="hljs-number">0</span>; 
    counter += <span class="hljs-number">1</span>; 
    <span class="hljs-keyword">return</span> counter; 
}
</div></code></pre>
<ul>
<li>This counts how many times the function was called</li>
</ul>
<p>Like global mutable variables, they are almost always poor style and should be avoided. They are not allowed in this course.</p>
<h2 id="text-input">Text input</h2>
<p>The converse of <code>printf</code> is <code>scanf</code>, but we are not going to use it yet.</p>
<h2 id="read-helper-functions">Read helper functions</h2>
<p>In this course we have provided some helper functions to make reading in input easier. For example:
<code>read_int()</code> reads an integer</p>
<h2 id="input-formatting">Input formatting</h2>
<p>When C read in <code>int</code> values, it skips over any white spaces</p>
<h2 id="reading-input">Reading input</h2>
<ul>
<li>once you read an input it can no longer be read again, so store your values.</li>
</ul>
<h2 id="testing-harness">Testing harness</h2>
<p>To summarize our function testing strategies:</p>
<pre><code class="language-C"><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test_sqr</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>{
    <span class="hljs-keyword">int</span> n = read_int(); 
    <span class="hljs-keyword">if</span> (n != READ_INT_FAIL) {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>, sqr(n));
        test_sqr(); 
    }
}
</div></code></pre>
<ul>
<li>This strategy is useful for testing both &quot;pure&quot; and &quot;impure&quot; functions.</li>
</ul>
<h2 id="goals-of-this-section">Goals of this section</h2>
<p>You should be able to answer all of the following:</p>
<ul>
<li>explain what a side effect is</li>
<li>document a side effect with an effects section</li>
<li>print output with <code>printf</code> and read input using the provided functions (<code>read_int</code>)</li>
<li>define global and local mutable variables and constants</li>
<li>use the C assignment operators</li>
<li>Use the new terminology introduced, including: mutation, expression statements and compound statements ({})</li>
</ul>
<h2 id="c-model-memory--control-flow"><strong>C Model: Memory &amp; Control Flow</strong></h2>
<h2 id="models-of-computation">Models of computation</h2>
<p>In this course, we model the behaviour of C with two complimentary mechanisms</p>
<ul>
<li>control flow</li>
<li>memory</li>
</ul>
<h2 id="control-flow">Control flow</h2>
<p>We use <strong>control flow</strong> to model how programs are executed.<br>
During execution, we keep track of the program location, which is &quot;where&quot; in the code the execution is currently occurring.<br>
When a program is &quot;run&quot;, the program location starts at the beginning of the main function.</p>
<ul>
<li>In hardware this is known as the <strong>program counter</strong></li>
</ul>
<h2 id="types-of-control-flow">Types of control flow</h2>
<ul>
<li>function calls</li>
<li>conditionals (i.e, if statements)</li>
<li>iterations (i.e, loops)</li>
</ul>
<h2 id="return">Return</h2>
<p><code>return</code> changes the program location to go back to the most recent calling function. Obviously C needs to keep track of where it is, we discuss this more later on in the course.</p>
<h2 id="conditionals-1">Conditionals</h2>
<p>The syntax of <code>if</code> is</p>
<pre><code class="language-C"><div><span class="hljs-keyword">if</span> (expression) statement
</div></code></pre>
<p>where the statement is only executed if the expression is true</p>
<pre><code class="language-C"><div><span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">0</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">"n is positive"</span>); 
</div></code></pre>
<ul>
<li>this is bad style</li>
</ul>
<p>The <code>if</code> statement only affects whether the <strong>next</strong> statement is executed. This is why if statements work without curly braces if it is only one statement (the curly braces are what allow more than one statement to be ignored).</p>
<h1 id="p-style%22text-align-center%22-23120-p"><p style="text-align: center;"> 23/1/20 </p></h1>
<p>Clarifications:</p>
<ul>
<li>using global constant variables in a function does not make it impure</li>
<li><code>x++</code> does not have lower priority than <code>=</code>, rather <code>x++</code> returns the old value of <code>x</code> by design</li>
</ul>
<h2 id="flowchart-basics">Flowchart basics</h2>
<ul>
<li>beginning in end are in elongated <strong>ellipses</strong></li>
<li>any statements or return values are in <strong>rectangles</strong></li>
<li>any choices or conditionals are in <strong>diamonds</strong></li>
</ul>
<p>Braces are sometimes necessary to avoid a &quot;dangling&quot; else.</p>
<pre><code class="language-C"><div><span class="hljs-keyword">if</span> (y &gt; <span class="hljs-number">0</span>)
    <span class="hljs-keyword">if</span> (y != <span class="hljs-number">7</span>)
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"you lose"</span>); 
<span class="hljs-keyword">else</span>
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"you win!"</span>);     <span class="hljs-comment">// when does this print</span>
</div></code></pre>
<ul>
<li>The else is related to the second if</li>
<li>this is bad style</li>
</ul>
<h2 id="switch-statements">Switch statements</h2>
<ul>
<li>Control flow statement</li>
<li>Very error prone for beginner programmers and will <strong>not be used in this course</strong></li>
</ul>
<pre><code class="language-C"><div><span class="hljs-keyword">int</span> a = <span class="hljs-number">5</span>; 
<span class="hljs-keyword">switch</span>(a) {
    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: 
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Won't print this"</span>); 
    <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>: 
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Will print this"</span>); 
    <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>: 
        print(<span class="hljs-string">"also this..."</span>); 
    <span class="hljs-keyword">default</span>: 
        print(<span class="hljs-string">"and this..."</span>); 
}
</div></code></pre>
<ul>
<li>This will print more than one case because in a switch case u must have a <code>break</code> statement to end the switch after the desired case.</li>
</ul>
<h2 id="c-goto">C goto</h2>
<ul>
<li>another control flow statement that will not be used is <code>goto</code></li>
<li>It was looked down upon by many as i tmakes &quot;spaghetti code&quot; that is hard to read
<ul>
<li>Now most agree it is useful and appropriate in <strong>some</strong> circumstances</li>
</ul>
</li>
</ul>
<pre><code class="language-C"><div><span class="hljs-keyword">if</span> (k &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">goto</span> mylabel; 
<span class="hljs-comment">// ...</span>
mylabel: 
<span class="hljs-comment">//...</span>
</div></code></pre>
<h2 id="looping">Looping</h2>
<p>With mutation, we can control flow with a method known as <strong>looping</strong></p>
<pre><code class="language-C"><div><span class="hljs-keyword">while</span> (expression) statement
</div></code></pre>
<p><code>while</code> is similar to <code>if</code>: the <code>statement</code> is only executed if the <code>expression</code> is true.</p>
<p>The difference is, <code>while</code> <strong>repeatedly</strong> &quot;loops back&quot; and executes the <code>statement</code> until the <code>expression</code> is false</p>
<h2 id="iteration-vs-recursion">Iteration vs. recursion</h2>
<p>Using a loop to solve a program is called <strong>iteration</strong></p>
<p><em>Iteration</em> is an alternative to <em>recursion</em> and is much more common in imperative programming.</p>
<pre><code class="language-C"><div><span class="hljs-comment">// recursion </span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k)</span> </span>{
    <span class="hljs-keyword">if</span> (k &lt;= <span class="hljs-number">0</span>) { 
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; 
    }
    <span class="hljs-keyword">return</span> k + sum(k - <span class="hljs-number">1</span>); 
}

<span class="hljs-comment">// iteration</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k)</span> </span>{
    <span class="hljs-keyword">int</span> s = <span class="hljs-number">0</span>; 
    <span class="hljs-keyword">while</span> (k &gt; <span class="hljs-number">0</span>) {
        s += k; 
        --k; 
    }
    <span class="hljs-keyword">return</span> s; 
}
</div></code></pre>
<ul>
<li>In general, using recursion can cause ur stack to crash or overflow because every time the function is called the information must be stored somewhere and can eventually exceed the stack
<ul>
<li>but iteration uses the same variables and replaces the values making it safer</li>
</ul>
</li>
<li>If something is can be modelled using iteration it can always be modelled using recursion</li>
</ul>
<h2 id="tracing-tools">Tracing tools</h2>
<p><code>trace_int()</code> traces an integer even through loops and will state when a loop has started and the value of the integer for each iteration</p>
<h2 id="do--while">do ... while</h2>
<p>the <code>do</code> control flow statement is very similar to <code>while</code></p>
<pre><code class="language-C"><div><span class="hljs-function"><span class="hljs-keyword">do</span> statement <span class="hljs-title">while</span> <span class="hljs-params">(expression)</span></span>; 
</div></code></pre>
<p>The difference is that <code>statement</code> is always executed at least once, and the expression is checked at the end of the loop</p>
<pre><code class="language-C"><div><span class="hljs-keyword">do</span> { 
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"try to guess my numebr! \n"</span>); 
    guess = read_int();
} <span class="hljs-keyword">while</span> (guess != my_number &amp;&amp; guess != READ_INT_FAIL); 
</div></code></pre>
<h2 id="break">break</h2>
<p>The <code>break</code> control flow statement is useful to exit from the middle of a loop</p>
<p><code>break</code> is</p>
<h2 id="continue">continue</h2>
<p>The <code>continue</code> control flow statement skips over the rest of the statements in the current block and &quot;continues&quot; with the loop.</p>
<h2 id="for-loops">For loops</h2>
<p>The final control flow statement we introduce <code>for</code>, which is often referred to as a &quot;<code>for</code> loop&quot;.</p>
<p><code>for</code> loops are a &quot;condensed&quot; version of a <code>while</code> loop.</p>
<pre><code class="language-C"><div><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i) {
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>,i;)
}
</div></code></pre>
<pre><code class="language-C"><div><span class="hljs-comment">// counting up from 0 to n-1</span>
<span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &lt; n; ++i) {...}

<span class="hljs-comment">// counting up from 1 to n</span>
<span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt;= n; ++i) {...}

<span class="hljs-comment">// counting down from n-1 to 0</span>
<span class="hljs-keyword">for</span> (i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) {...}

<span class="hljs-comment">// counting down from n to 1</span>
<span class="hljs-keyword">for</span> (i = n; i &gt; <span class="hljs-number">0</span>; --i) {...}
</div></code></pre>
<p>any of the three components of a <code>for</code> statement can be omitted. If the expression is omitted, it is always &quot;true&quot;.</p>
<h1 id="p-style%22text-align-center%22-28120-p"><p style="text-align: center;"> 28/1/20 </p></h1>
<h2 id="memory-review">Memory Review</h2>
<p>One bit of storage (in memory) has two possible <strong>states</strong>: 0 or 1<br>
A byte is 8 bits of storage. Each byte in memory is in one of 256 (<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>8</mn></msup></mrow><annotation encoding="application/x-tex">2^8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span></span></span></span>) states.</p>
<h2 id="accessing-memory">Accessing memory</h2>
<p>The smallest accessible unit of memory is a byte.<br>
To access a byte of memory, its <em>position</em> in memory, which is known as the <strong>address</strong> of the byte, must be known.<br>
For example, if you have 1 MB of memory (RAM), the address of the first byte is 0 and the address of the last byte is <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1048575</mn><mo>=</mo><mo stretchy="false">(</mo><msup><mn>2</mn><mn>20</mn></msup><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">1048575 = (2^{20} - 1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">4</span><span class="mord">8</span><span class="mord">5</span><span class="mord">7</span><span class="mord">5</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>.</p>
<p><strong>Note:</strong> Memory address are usually represented in hex, so with 1 MB of memory, the address of the first byte is <strong>0x0</strong>, and the address of the last byte is <strong>0XFFFFF</strong>.</p>
<ul>
<li>hexadecimal is used because it is more condensed than trying to use binary</li>
</ul>
<h2 id="defining-variables">Defining variables</h2>
<p>For a <strong>variable definition</strong> in C:</p>
<ul>
<li>reserves (&quot;finds&quot;) space in memory to <strong>store</strong> the variable</li>
<li>&quot;Keeps track of&quot; the address of that storage location</li>
<li>stores the initial value of the variable at that location (address)</li>
</ul>
<p>In CS 135 we viewed variables as a &quot;name for a value&quot;, but we now view variables as &quot;name for a location&quot; where the values are stored.</p>
<h2 id="sizeof">sizeof</h2>
<p>When we define a variable, C reserves space in memory to store its value, but <strong>how much space</strong> is require?</p>
<ul>
<li>that depends on the <strong>type</strong> of the variable</li>
</ul>
<p>The <strong>size operator</strong> (<code>sizeof</code>) produces the number of bytes required to store a type (it can also be used on identifiers). <code>sizeof</code> looks like a function, but it is an <strong>operator</strong>.</p>
<h2 id="integer-limits">Integer Limits</h2>
<p>C uses 4 bytes (32 bits) to store an <code>int</code>, there are only <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup></mrow><annotation encoding="application/x-tex">2^{32}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span> possible values that can be represent.<br>
The range of C int values is <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo><msup><mn>2</mn><mn>31</mn></msup><mo>⋯</mo><mo stretchy="false">(</mo><msup><mn>2</mn><mn>31</mn></msup><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">-2^{31} \cdots (2^{31}-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">−</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> or <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo><mn>2</mn><mo separator="true">,</mo><mn>147</mn><mo separator="true">,</mo><mn>488</mn><mo separator="true">,</mo><mn>648</mn><mo>⋯</mo><mn>2</mn><mo separator="true">,</mo><mn>147</mn><mo separator="true">,</mo><mn>483</mn><mo separator="true">,</mo><mn>647</mn></mrow><annotation encoding="application/x-tex">-2,147,488,648 \cdots 2,147,483,647</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">−</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">4</span><span class="mord">7</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mord">8</span><span class="mord">8</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">6</span><span class="mord">4</span><span class="mord">8</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">4</span><span class="mord">7</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mord">8</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">6</span><span class="mord">4</span><span class="mord">7</span></span></span></span>.
In our environment, the constants <code>INT_MIN</code> and <code>INT_MAX</code> are defined as those limits.</p>
<h2 id="overflow">Overflow</h2>
<p>if we try to represent values outside of <code>int</code> limits, <strong>overflow</strong> occurs.</p>
<ul>
<li>never assume what the value of an <code>int</code> will be after an overflow, the value of an integer that has overflowed is <strong>undefined</strong></li>
</ul>
<h2 id="the-char-type">The char type</h2>
<p>The <code>char</code> type is also used to store integers, but C allocates <strong>one byte</strong> of storage for a <code>char</code> (an <code>int</code> has 4 bytes).<br>
The are <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>8</mn></msup></mrow><annotation encoding="application/x-tex">2^8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span></span></span></span> possible values for a <code>char</code> (<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo><mn>128</mn><mo>⋯</mo><mn>127</mn></mrow><annotation encoding="application/x-tex">-128 \cdots 127</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord">2</span><span class="mord">8</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mord">7</span></span></span></span> in seashell environment)</p>
<h2 id="ascii">ASCII</h2>
<p>ASCII was developed when <em>teletype</em> machines were popular, most modern applications have moved to unicode</p>
<ul>
<li>a popular method of <strong>encoding</strong> Unicode is the UTF-8 standard, where displayable ASCII code use only one byte</li>
</ul>
<h2 id="c-characters">C characters</h2>
<p>in C, <strong>single</strong> quotes (<code>'</code>) are used to indicated an ASCII character.<br>
For example, <code>a</code> is equivalent to 97 and <code>z</code> is 122.<br>
In C, there is <strong>no difference</strong> between the two variables.</p>
<pre><code class="language-C"><div><span class="hljs-keyword">char</span> letter_a = <span class="hljs-string">'a'</span>; 
<span class="hljs-keyword">char</span> ninety_seven = <span class="hljs-number">97</span>; 

<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%c \n"</span>, ninety_seven)  <span class="hljs-comment">// prints a</span>
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d \n"</span>, letter_a)      <span class="hljs-comment">// prints 97</span>
</div></code></pre>
<h2 id="character-arithmetic">Character arithmetic</h2>
<p>Because C interprets characters as integers, characters can be used in expressions to avoid having &quot;magic numbers&quot; in your code.</p>
<pre><code class="language-C"><div><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">is_lowercase</span><span class="hljs-params">(<span class="hljs-keyword">char</span> c)</span> </span>{
    <span class="hljs-keyword">return</span> (c &gt;= <span class="hljs-string">'a'</span>) &amp;&amp; (c &lt;= <span class="hljs-string">'z'</span>); 
}

<span class="hljs-function"><span class="hljs-keyword">char</span> <span class="hljs-title">to_lowercase</span><span class="hljs-params">(<span class="hljs-keyword">char</span> c)</span> </span>{
    <span class="hljs-keyword">if</span> ((c &gt;= <span class="hljs-string">'A'</span>) &amp;&amp; (c &lt;= <span class="hljs-string">'Z'</span>)) {
        <span class="hljs-keyword">return</span> c - <span class="hljs-string">'A'</span> + <span class="hljs-string">'a'</span>;
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> c; 
    }
}

<span class="hljs-function"><span class="hljs-keyword">char</span> <span class="hljs-title">to_uppercase</span><span class="hljs-params">(<span class="hljs-keyword">char</span> c)</span> </span>{
    <span class="hljs-keyword">if</span>((c &gt;= <span class="hljs-string">'a'</span>) &amp;&amp; (c &lt;= <span class="hljs-string">'z'</span>)) { 
        <span class="hljs-keyword">return</span> c - <span class="hljs-string">'a'</span> + <span class="hljs-string">'A'</span>;
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> c; 
    }
}
</div></code></pre>
<h2 id="readchar">read_char()</h2>
<p>the same as <code>read_int()</code> but for <code>char</code></p>
<h2 id="symbol-type">Symbol type</h2>
<p>C <strong>symbols</strong> are constants (often <code>int</code>) which are usually defined in all caps</p>
<pre><code class="language-C"><div><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> UP = <span class="hljs-number">1</span>; 
</div></code></pre>
<h2 id="floating-point-types">Floating point types</h2>
<p>The C <code>float</code> can represent real (non-integer) values.</p>
<pre><code class="language-C"><div><span class="hljs-keyword">float</span> pi = <span class="hljs-number">3.14159</span>;
<span class="hljs-keyword">float</span> avogadro = <span class="hljs-number">6.022e23</span>; 
</div></code></pre>
<pre><code class="language-C"><div><span class="hljs-keyword">float</span> penny = <span class="hljs-number">0.01</span>; 
<span class="hljs-keyword">float</span> money = <span class="hljs-number">0</span>; 
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; ++i) { 
    money += penny; 
}
<span class="hljs-comment">// value of money is 0.999999</span>
</div></code></pre>
<p>In C, a float is 8 bytes, one <strong>byte</strong> is for the exponent (<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo><mn>127</mn><mo>⋯</mo><mn>128</mn></mrow><annotation encoding="application/x-tex">-127 \cdots 128</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord">2</span><span class="mord">7</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mord">8</span></span></span></span>), one <strong>bit</strong> is for the sign, leaving 23 <strong>bits</strong>, so the precision is <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup></mrow><annotation encoding="application/x-tex">2^{32}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></p>
<h2 id="structures">Structures</h2>
<p>Structures (compound data) in C are similar to structures in Racket.</p>
<pre><code class="language-C"><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">posn</span> {</span>       <span class="hljs-comment">// name of the structure</span>
    <span class="hljs-keyword">int</span> x;          <span class="hljs-comment">// type and field names</span>
    <span class="hljs-keyword">int</span> y; 
};                  <span class="hljs-comment">// don't forget this ; </span>
</div></code></pre>
<p>the structure <em>type</em> includes the keyword &quot;<code>struct</code>&quot;. For the example aboce the <em>type</em> is <code>struct posn</code> not just <code>posn</code>.</p>
<pre><code class="language-C"><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">posn</span> <span class="hljs-title">p</span> = {</span><span class="hljs-number">3</span>, <span class="hljs-number">4</span>};      <span class="hljs-comment">// note the use of {}</span>
trace_int(p.x); 
</div></code></pre>
<ul>
<li>instead of <em>selector</em> function C, has <strong>selector operators</strong> (<code>.</code>)</li>
</ul>
<h2 id="mutating-with-structures">Mutating with structures</h2>
<pre><code class="language-C"><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">posn</span> <span class="hljs-title">p</span> = {</span><span class="hljs-number">1</span>, <span class="hljs-number">2</span>}; 
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">posn</span> <span class="hljs-title">q</span> = {</span><span class="hljs-number">3</span>, <span class="hljs-number">4</span>}; 

p = q;      
<span class="hljs-comment">// p = {3, 4}</span>
p.x = <span class="hljs-number">23</span>; 
<span class="hljs-comment">// p = {23, 4}</span>
</div></code></pre>
<p>The braces are part of the initialization syntax and can not be used in assignment.</p>
<pre><code class="language-C"><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">posn</span> <span class="hljs-title">p</span> = {</span><span class="hljs-number">1</span>, <span class="hljs-number">2</span>}; 
p = {<span class="hljs-number">3</span>, <span class="hljs-number">4</span>};             <span class="hljs-comment">// INVALID</span>
p.x = <span class="hljs-number">3</span>;                <span class="hljs-comment">// VALID</span>
p.y = <span class="hljs-number">4</span>;                
</div></code></pre>
<p>The equality operator (==) does not work with <code>struct</code></p>
<h2 id="structures-in-the-memory-model">Structures in the memory model</h2>
<p>For a structure definition, no memory is reserved:</p>
<pre><code class="language-C"><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">posn</span> {</span>
    <span class="hljs-keyword">int</span> x; 
    <span class="hljs-keyword">int</span> y; 
};
</div></code></pre>
<p>Memory is only reserved when a   <strong>variable</strong> is defined:</p>
<pre><code class="language-C"><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">posn</span> <span class="hljs-title">p</span> = {</span><span class="hljs-number">3</span>, <span class="hljs-number">4</span>};
</div></code></pre>
<h1 id="p-style%22text-align-center%22-30120-p"><p style="text-align: center;"> 30/1/20 </p></h1>
<h2 id="sizeof-a-struct">Sizeof a struct</h2>
<pre><code class="language-C"><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mystruct</span> {</span>
    <span class="hljs-keyword">int</span> x;      <span class="hljs-comment">// 4 bytes</span>
    <span class="hljs-keyword">char</span> c;     <span class="hljs-comment">// 1 byte</span>
    <span class="hljs-keyword">int</span> y;      <span class="hljs-comment">// 4 bytes</span>
};
</div></code></pre>
<p>the amount of space reserved for a <code>struct</code> is <strong>at least</strong> the sum of the <code>sizeof</code> each field, but it may be larger.</p>
<ul>
<li>this is because the order of each field matters
<ul>
<li>so if u have an <code>int</code> following a <code>char</code>, C will space the first <code>char</code> with the same size as an <code>int</code>
<ul>
<li>this is because the compiler wants to have each integer at an address that is a multiple of 4 for performance optimization</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="language-C"><div>trace_int(<span class="hljs-keyword">sizeof</span>(struct mystruct)); 
<span class="hljs-comment">// sizeof(struct mystruct) =&gt; 12</span>
</div></code></pre>
<ul>
<li>Because it may be larger than each field, you <strong>must</strong> use sizeof to determine the <code>sizeof</code> a struct</li>
</ul>
<h2 id="sections-of-memory">Sections of memory</h2>
<p>In this course we model five <strong>sections</strong> (&quot;regions&quot;) of memory.</p>
<table>
<thead>
<tr>
<th>Sections</th>
</tr>
</thead>
<tbody>
<tr>
<td>Code</td>
</tr>
<tr>
<td>Read-only data</td>
</tr>
<tr>
<td>Global data</td>
</tr>
<tr>
<td>Heap</td>
</tr>
<tr>
<td>Stack</td>
</tr>
</tbody>
</table>
<ul>
<li>each of these is called a <strong>segment</strong>
<ul>
<li>if a program tries to access something in a segment it cannot access, you get a <strong>segmentation fault</strong></li>
</ul>
</li>
<li>other courses may use alternative names</li>
</ul>
<h2 id="temporary-results">Temporary results</h2>
<p>When evaluating C expressions, the intermediate results must be temporarily stored.</p>
<pre><code class="language-C"><div>a = f(<span class="hljs-number">3</span>) + g(<span class="hljs-number">4</span>) - <span class="hljs-number">5</span>; 
</div></code></pre>
<ul>
<li>in this example, C must temporarily store the value returned from <code>f(3)</code> and <code>g(4)</code></li>
</ul>
<h2 id="the-code-section">The code section</h2>
<p>When you program you write <strong>source code</strong> in a text editor using ASCII characters<br>
To &quot;run&quot; a C program, the <em>source code</em> must be converted into <strong>machine code</strong> that is machine readable<br>
This machine code is then placed into the <strong>code section</strong> of memory</p>
<blockquote>
<p>converting source code into machine code is known as <strong>compiling</strong></p>
</blockquote>
<h2 id="the-read-only--global-data-sections">The read-only &amp; global data sections</h2>
<p>Earlier we described how C reserves space in memory for a variable definition<br>
All global variables are placed either in the global variables section or the read only section</p>
<h2 id="the-return-address">The return address</h2>
<p>When we encounter a <code>return</code>, we need to know: &quot;what was the address we were at right before this function was called?&quot;</p>
<ul>
<li>This location is known as the <strong>return address</strong></li>
<li>This address is stored in the stack</li>
</ul>
<p>In this course, we use the name of the calling function and a line number (or an arrow) to represent the return address</p>
<h2 id="the-call-stack">The call stack</h2>
<p>The &quot;history&quot; of function calls (say function f,g,h are called in main) are stored in the <strong>call stack</strong></p>
<ul>
<li>each time a function is called it is pushed to the stack</li>
<li>each time a function returns it is popped from the stack</li>
</ul>
<h2 id="stack-frames">Stack frames</h2>
<p>&quot;entries&quot; pushed onto the call stack are known as <strong>stack frames</strong><br>
Each function call creates a stack fram (&quot;fram of reference&quot;)<br>
Each stack frame contains:</p>
<ul>
<li>the <strong>argument values</strong></li>
<li>all <strong>local variables</strong> (both mutable variables and constants) that appear within the function block</li>
<li>the return <strong>address</strong></li>
</ul>
<p>C makes a copy of each argument value and places the copy in the stack frame</p>
<ul>
<li>this is known as &quot;pass by value&quot; convention</li>
</ul>
<p>Although space is reserved for global variables before the program is executed, space for local variables is only reserved <strong>when the function is called</strong></p>
<ul>
<li>the space is reserved within the newly created stack frame</li>
</ul>
<p>Example stack frame:</p>
<pre><code class="language-C"><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">h</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>{
    <span class="hljs-keyword">int</span> r = <span class="hljs-number">10</span> * i; 
    <span class="hljs-keyword">return</span> r; 
}
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">g</span><span class="hljs-params">(<span class="hljs-keyword">int</span> y)</span> </span>{
    <span class="hljs-keyword">int</span> c = y * y; 
    <span class="hljs-keyword">return</span> c; 
}
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>{
  <span class="hljs-keyword">int</span> b = <span class="hljs-number">2</span>*x + <span class="hljs-number">1</span>;
  <span class="hljs-keyword">int</span> d = g(b + <span class="hljs-number">3</span>) + h(b);
  <span class="hljs-keyword">return</span> d;
}   
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>{            
  <span class="hljs-keyword">int</span> a = f(<span class="hljs-number">2</span>);
  <span class="hljs-comment">//...</span>
}

<span class="hljs-comment">// Stack frame</span>
=========================
g:
  y: <span class="hljs-number">8</span>
  c: <span class="hljs-number">64</span>
  <span class="hljs-keyword">return</span> address: f:<span class="hljs-number">13</span>
=========================
f:
  x: <span class="hljs-number">2</span>
  b: <span class="hljs-number">5</span>
  d: ???
  <span class="hljs-keyword">return</span> address: main:<span class="hljs-number">18</span>
=========================
main:
a: ???
  <span class="hljs-keyword">return</span> address: OS
=========================
</div></code></pre>
<h2 id="calling-a-function">Calling a function</h2>
<p>We can now model all of the <strong>control flow</strong> when a function is called:</p>
<ul>
<li>a <em>stack frame</em> is created (&quot;pushed&quot; onto the stack)</li>
<li>a <strong>copy</strong> of each of the arguments is placed in the stack frame</li>
<li>the current program location is placed in the stack frame as the return address</li>
<li>program location is changed to the start of the new function</li>
<li>initial values of local variables are set when their definition is encountered</li>
</ul>
<h2 id="return-1">return</h2>
<p>When a function <code>return</code>s:</p>
<ul>
<li>the current program location is changed back to the return address</li>
<li>the stack frame is removed (&quot;popped&quot; from the Stack memory area)</li>
</ul>
<h2 id="recursion-in-c">Recursion in C</h2>
<p>In C, each recursive call is simply a new <em>stack frame</em> with a separate frame of reference. The only unusual aspect of recursion is that the return address is a location within the same function.</p>
<h2 id="stack-section">Stack section</h2>
<p>The <em>call stack</em> is stored in the <strong>stack section</strong>, the fourth section of our memory model. We refer to this section as the &quot;the stack&quot;.<br>
The &quot;bottom&quot; of the stack (where the <code>main</code> stack frame is placed) is placed at the <strong>highest</strong> available memory address. Each additional stack frame is then placed at increasingly lower address. The stack &quot;grows&quot; toward lower address.</p>
<ul>
<li>If the stack grows too large, it can &quot;collide&quot; with other sections of memory. This is called &quot;stack overflow&quot; and can occur with very deep (or infinite) recursion.</li>
</ul>
<h2 id="uninitialized-memory">Uninitialized memory</h2>
<p><strong>Global</strong> variables are initialized with a value of 0 in C, local variables are initialized with a random value.</p>
<pre><code class="language-C"><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mystery</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>{
    <span class="hljs-keyword">int</span> k;
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"the value of k is: %d\n"</span>, k);
  }
</div></code></pre>
<ul>
<li>the value of k will likely be a leftover value from a previous stack frame</li>
</ul>
<h2 id="memory-snapshot">Memory snapshot</h2>
<p>You may be asked to draw a memory diagram (including the call stack) at a particular moment in the code execution.</p>
<ul>
<li>make sure you show any variables in the <strong>global</strong> and <strong>read-only</strong> sections, separate from the stack</li>
<li>include all local variables in stack frames, including definitions that have not yet been reached (or are incomplete)</li>
<li>local variables not yet fully initialized have a value of ???</li>
<li>you do not have to show any temporary storage
(e.g., intermediate results of an expression)</li>
</ul>
<p>When a variable is defined inside of a loop, only one occurrence of the variable is placed in the stack frame. The same variable is re-used for each iteration.<br>
Each time the definition is reached in the loop, the variable is re-initialized (it does not retain its value from the previous iteration)</p>
<h2 id="goals-of-this-section-1">Goals of this section</h2>
<p>At the end of this section</p>
<ul>
<li>...</li>
</ul>
<h1 id="p-style%22text-align-center%22-4220-p"><p style="text-align: center;"> 4/2/20 </p></h1>
<h2 id="introduction-to-pointers-in-c">Introduction to Pointers in C</h2>
<h2 id="address-operator">Address operator</h2>
<p>C was designed to give programmers &quot;low-level&quot; access to memory and <strong>expose</strong> the underlying memory model.</p>
<p>The <strong>address operator</strong> (<code>&amp;</code>) produces the <strong>location</strong> of an identifier in memory (the <strong>starting address</strong> of where its value is stored)</p>
<pre><code class="language-C"><div><span class="hljs-keyword">int</span> g = <span class="hljs-number">42</span>; 
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>{
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"the value of g is: %d\n"</span>, g); 
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"the address of g is: %p\n"</span>, &amp;g);
}
<span class="hljs-comment">// the value of g is: 42</span>
<span class="hljs-comment">// the address of g is: 0x71a0a0</span>
</div></code></pre>
<ul>
<li>The printf format specifier to display an address (in hex) is &quot;<code>%p</code>&quot;</li>
</ul>
<h2 id="pointers">Pointers</h2>
<p>In C, there is also a <em>type</em> for <strong>storing an address</strong>: a <strong>pointer</strong></p>
<p>a pointer is defined by placing a (<code>*</code>) before the identifier (name). The <code>*</code> is part of the definition syntax, not the identifier itself.</p>
<pre><code class="language-C"><div><span class="hljs-keyword">int</span> g = <span class="hljs-number">32</span>; 
<span class="hljs-keyword">int</span> i = <span class="hljs-number">42</span>; 
<span class="hljs-keyword">int</span> *p = &amp;g;    <span class="hljs-comment">// p "points at" i</span>
p = &amp;i; 
<span class="hljs-comment">//  i =&gt; 42</span>
<span class="hljs-comment">// &amp;i =&gt; 0xf020</span>
<span class="hljs-comment">//  p =&gt; 0xf020</span>
<span class="hljs-comment">// &amp;p =&gt; oxf024</span>

</div></code></pre>
<ul>
<li>when u call <code>p</code> you do not use the <code>*</code> that is just part of the definition not the identifier name</li>
</ul>
<p>The type of <code>p</code> is an &quot;int pointer&quot; which is written as &quot;<code>int *</code>&quot;.</p>
<p>For each type (e.g, <code>int</code>, <code>char</code>) there is a corresponding pointer type (e.g, <code>int *</code>, <code>char *</code>)</p>
<p>When drawing a <em>memory</em> diagram, we rarely care about the value of the address, and visualize a pointer with an arrow (that &quot;points&quot;)</p>
<h2 id="sizeof-a-pointer">sizeof a pointer</h2>
<p>Int most <em>k</em>-bit systems, memory address are <em>k</em> bits long, so pointers require <em>k</em> bits yo store an address</p>
<h2 id="indirection-operator">Indirection operator</h2>
<p>The <strong>indirection operator</strong> (<code>*</code>), also known as the <em>deference operator</em>, is the <strong>inverse</strong> of the address operator (<code>&amp;</code>).</p>
<ul>
<li>*p produces the <strong>value</strong> of what pointer p &quot;points at&quot;</li>
</ul>
<pre><code class="language-C"><div><span class="hljs-keyword">int</span> i = <span class="hljs-number">42</span>; 
<span class="hljs-keyword">int</span> *p = &amp;i; 
<span class="hljs-comment">//  p =&gt; 0xf020</span>
<span class="hljs-comment">// *p =&gt; 42</span>
</div></code></pre>
<h2 id="pointers-to-pointers">Pointers to pointers</h2>
<p>&quot;Can a pointer point at itself?&quot;</p>
<pre><code class="language-C"><div><span class="hljs-keyword">int</span> *p = &amp;p;    <span class="hljs-comment">// pointer p points at p ???</span>
</div></code></pre>
<ul>
<li>this is actually a <strong>type error</strong>
<ul>
<li>p is defined as (<code>int *</code>), a pointer to an <code>int</code>, but</li>
<li>the type of &amp;p is (<code>int **</code>), a pointer to a pointer to an <code>int</code></li>
</ul>
</li>
</ul>
<p>In C, we can define a <strong>pointer to a pointer</strong>:</p>
<pre><code class="language-C"><div><span class="hljs-keyword">int</span> i = <span class="hljs-number">42</span>; 
<span class="hljs-keyword">int</span> *p1 = &amp;i;          <span class="hljs-comment">// pointer p1 points at i</span>
<span class="hljs-keyword">int</span> **p2 == &amp;p1;       <span class="hljs-comment">// pointer p2 points at p1</span>
</div></code></pre>
<ul>
<li><code>**p * **p</code> is a confusing but valid C expression</li>
</ul>
<blockquote>
<p>A <code>void</code> pointer (<code>void *</code>) can point at anything, including a <code>void</code> pointer (itself)</p>
</blockquote>
<h2 id="dereferencing-pointers-to-structures">Dereferencing pointers to structures</h2>
<p>The structure operator (.) has higher precedence than the indirection operator (<code>*</code>)</p>
<p>Awkward parenthesis are required to access a field of a pointer to a structure</p>
<pre><code class="language-C"><div>(*ptr).field
</div></code></pre>
<p>Fortunately, the <strong>indirection selection operator</strong>, also known as the &quot;arrow&quot; operator (<code>-&gt;</code>) combines the indirection and the selection operators.</p>
<p><code>ptr-&gt;field</code> is equivalent to <code>(*ptr).field</code></p>
<h2 id="the-null-pointer">The NULL pointer</h2>
<p><code>NULL</code> is a special pointer <strong>value</strong> to represent that the pointer points to &quot;nothing&quot;</p>
<p>If the value of a pointer is <em>unknown</em> at the time of definition, or what the pointer points at becimes <em>invalid</em>, it's good style to assign the value of NULL to the pointer. A pointer with a value of NULL is often known as a &quot;NULL pointer&quot;</p>
<ul>
<li>NULL is considered &quot;false&quot; when used in a Boolean context</li>
</ul>
<p>The following two are equivalent:</p>
<pre><code class="language-C"><div><span class="hljs-keyword">if</span> (p) ... 
<span class="hljs-keyword">if</span> (p != <span class="hljs-literal">NULL</span>)
</div></code></pre>
<ul>
<li>If you try to dereference a NULL pointer, your program <strong>will crash</strong></li>
</ul>
<pre><code class="language-C"><div>p = <span class="hljs-literal">NULL</span>; 
i = *p;        <span class="hljs-comment">// crash!</span>
</div></code></pre>
<h2 id="pointer-assignment">Pointer assignment</h2>
<pre><code class="language-C"><div><span class="hljs-keyword">int</span> i = <span class="hljs-number">5</span>; 
<span class="hljs-keyword">int</span> j = <span class="hljs-number">6</span>; 

<span class="hljs-keyword">int</span> *p = &amp;i; 
<span class="hljs-keyword">int</span> *q = &amp;j; 

p = q; 
</div></code></pre>
<ul>
<li>this does not change the value of i or j, it just makes p point to j</li>
</ul>
<p>This is an example of <strong>aliasing</strong>, which is when the same memory address can be accessed from more than one variable</p>
<h1 id="p-style%22text-align-center%22-6220-p"><p style="text-align: center;"> 6/2/20 </p></h1>
<h2 id="mutation-and-parameters">Mutation and parameters</h2>
<p>Pass by value:<br>
<strong>copy</strong> of an argument is passed to a function, so the function cannot change the original value. The alternative to this is &quot;pass by reference&quot;</p>
<p>In C, we can emulate &quot;pass by reference&quot; by passing the address of a variable.</p>
<ul>
<li>This is still actually &quot;pass by value&quot; because we pass the <strong>value</strong> of the address. It is not the same as when languages pass by reference.</li>
</ul>
<p>It is also common to say pass a pointer</p>
<pre><code class="language-C"><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">inc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *p)</span> </span>{
  *p += <span class="hljs-number">1</span>;
}
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>{
  <span class="hljs-keyword">int</span> x = <span class="hljs-number">5</span>;
  trace_int(x);
  inc(&amp;x);              <span class="hljs-comment">// note the &amp;</span>
  trace_int(x);
}
</div></code></pre>
<p>Most pointer parameters should be <strong>required</strong> to be valid (e.g., non-<code>NULL</code>)</p>
<pre><code class="language-C"><div><span class="hljs-comment">// inc(p) increments the value of *p</span>
<span class="hljs-comment">// effects:  modifies *p</span>
<span class="hljs-comment">// requires: p is a valid pointer</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">inc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *p)</span> </span>{
    *p += <span class="hljs-number">1</span>;
}
</div></code></pre>
<ul>
<li>note that instead of <code>*p += 1;</code> we could have written <code>(*p)++;</code> The parenthesis are needed because <code>++</code> has higher priority than <code>*</code></li>
</ul>
<h3 id="documenting-the-side-effect">Documenting the side effect</h3>
<p>We now have a fourth effect that a function may have:</p>
<ul>
<li>produce output</li>
<li>read input</li>
<li>mutate a global variable</li>
<li><strong>mutate a variable through a pointer parameter</strong></li>
</ul>
<pre><code class="language-C"><div><span class="hljs-comment">//  effects: modifies *px and *py</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *px, <span class="hljs-keyword">int</span> *py)</span> </span>{
      <span class="hljs-keyword">int</span> temp = *px;
      *px = *py;
      *py = temp;
}
</div></code></pre>
<h2 id="c-input-scanf">C input: scanf</h2>
<p><code>scanf</code> requires a <strong>pointer</strong> to a variable to store the value read from input.<br>
Just like <code>printf</code>, <code>scanf</code> can be used to read in more than one value</p>
<ul>
<li><strong>However in this course you may only read one value per <code>scanf</code></strong></li>
</ul>
<h2 id="scanf-return-value">scanf return value</h2>
<p>The <strong>return value</strong> of <code>scanf</code> is an <code>int</code>, and either:</p>
<ul>
<li>The quantity of values successfully read
<ul>
<li>0 if the input is not formatted properly</li>
</ul>
</li>
<li>The constant <code>EOF</code>: <strong>E</strong>nd <strong>O</strong>f <strong>F</strong>ile has been reached</li>
</ul>
<h2 id="invalid-input">Invalid input</h2>
<ul>
<li>If you follow the course's advice, scanf will return 1 if the input is valid</li>
</ul>
<pre><code class="language-C"><div>retval = <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;i); <span class="hljs-comment">// read in an integer, store it in i</span>
<span class="hljs-keyword">if</span> (retval != <span class="hljs-number">1</span>) {
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Fail! I could not read in an integer!\n"</span>);
}
</div></code></pre>
<h2 id="whitespace">Whitespace</h2>
<pre><code class="language-C"><div><span class="hljs-comment">// reads in next character (may be whitespace character)</span>
count = <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%c"</span>, &amp;c);

<span class="hljs-comment">// reads in next character, ignoring whitespace</span>
count = <span class="hljs-built_in">scanf</span>(<span class="hljs-string">" %c"</span>, &amp;c);

<span class="hljs-comment">// This is better</span>
count = <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"\n%c"</span>, &amp;c);
</div></code></pre>
<ul>
<li>The space in the second example indicated that leading white space is ignored
<ul>
<li>It ignores all leading white spaces</li>
<li>It also ignores any white space characters such as <code>\n</code></li>
</ul>
</li>
<li>You can write a <code>\n</code> instead of the leading white space to have more contrast in your code</li>
</ul>
<h2 id="using-pointers-to-return-multiple-values">Using pointers to return multiple values</h2>
<p>Functions in C can only have one return value, we can use pointers to emulate returning more than one value.</p>
<pre><code class="language-C"><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">divide</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num, <span class="hljs-keyword">int</span> denom, <span class="hljs-keyword">int</span> *quot, <span class="hljs-keyword">int</span> *rem)</span> </span>{
    *quot = num / denom;
    *rem  = num % denom;
}
</div></code></pre>
<ul>
<li>This function &quot;returns&quot; both the quotient and remainder</li>
</ul>
<p>This multiple return is also useful for when a function could encounter an error.</p>
<pre><code class="language-C"><div><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">divide</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num, <span class="hljs-keyword">int</span> denom, <span class="hljs-keyword">int</span> *quot, <span class="hljs-keyword">int</span> *rem)</span> </span>{
    <span class="hljs-keyword">if</span> (denom == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    *quot = num / denom;
    *rem  = num % denom;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }
</div></code></pre>
<ul>
<li>returns true if successful</li>
<li>false if not</li>
</ul>
<h2 id="returning-an-address">Returning an address</h2>
<p>A function must <strong>never</strong> return an address within its stack fram.</p>
<pre><code class="language-C"><div><span class="hljs-function"><span class="hljs-keyword">int</span> *<span class="hljs-title">bad_idea</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{ 
    <span class="hljs-keyword">return</span> &amp;n;    <span class="hljs-comment">// Never do this</span>
}

<span class="hljs-function"><span class="hljs-keyword">int</span> *<span class="hljs-title">bad_idea2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{
  <span class="hljs-keyword">int</span> a = n*n;
  <span class="hljs-keyword">return</span> &amp;a;
}
</div></code></pre>
<h2 id="passing-structures">Passing structures</h2>
<p>When a function is called, a <strong>copy</strong> of each argument value is placed into the stack frame.</p>
<p>For structures, the <em>entire</em> structure is copied into the stack frame. For large structures, this can be quite inefficient.</p>
<p>To avoid structure copying, it is common to pass the address of a structure to a function</p>
<pre><code class="language-C"><div><span class="hljs-comment">// sqr_dist(p1, p2) calculates the square of</span>
  <span class="hljs-comment">//   the distance between p1 and p2</span>
  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sqr_dist</span><span class="hljs-params">(struct posn *p1, struct posn *p2)</span> </span>{
    <span class="hljs-keyword">int</span> xdist = p1-&gt;x - p2-&gt;x;
    <span class="hljs-keyword">int</span> ydist = p1-&gt;y - p2-&gt;y;
    <span class="hljs-keyword">return</span> xdist * xdist + ydist * ydist;
}
</div></code></pre>
<p>passing the address of a structure allows the function to mutate the fields of the structure.</p>
<pre><code class="language-C"><div><span class="hljs-comment">// scale(p, f) scales the posn p by f</span>
  <span class="hljs-comment">// requires: p is not null</span>
  <span class="hljs-comment">// effects:  modifies p</span>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">scale</span><span class="hljs-params">(struct posn *p, <span class="hljs-keyword">int</span> f)</span> </span>{
    p-&gt;x *= f;
    p-&gt;y *= f;
}
</div></code></pre>
<h2 id="const-pointers">Const pointers</h2>
<p>Adding the <code>const</code> keyword to a pointer definition prevents the pointer’s destination from being mutated through the pointer.</p>
<pre><code class="language-C"><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cannot_change</span><span class="hljs-params">(<span class="hljs-keyword">const</span> struct posn *p)</span> </span>{
    p-&gt;x = <span class="hljs-number">5</span>;   <span class="hljs-comment">// INVALID</span>
}
</div></code></pre>
<p>Place <code>const</code> <strong>before</strong> the type</p>
<ul>
<li>it is <strong>good style</strong> to add <code>const</code> to a pointer parameter to communicate that the destination does not change</li>
</ul>
<h2 id="const-parameters">Const parameters</h2>
<pre><code class="language-C"><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">can_change</span><span class="hljs-params">(struct posn *p)</span> </span>{
    p-&gt;x = <span class="hljs-number">5</span>;   <span class="hljs-comment">// VALID</span>
}
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cannot_change</span><span class="hljs-params">(<span class="hljs-keyword">const</span> struct posn *p)</span> </span>{
    p-&gt;x = <span class="hljs-number">5</span>;   <span class="hljs-comment">// INVALID</span>
}
</div></code></pre>
<p>Const parameters could be used with simple variables as well</p>
<pre><code class="language-C"><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">my_function</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> x)</span> </span>{
    <span class="hljs-comment">// mutation of x here is invalid</span>
    <span class="hljs-comment">// ...</span>
}
</div></code></pre>
<p>It does not matter if the original argument is a constant because</p>
<ul>
<li>A <code>const</code> parameter communicates (and enforces) that <strong>the copy</strong> of the argument will not be mutated.</li>
</ul>
<h2 id="minimizing-mutative-side-effects">Minimizing mutative side effects</h2>
<p>Your preference for function design should be:</p>
<ol>
<li><strong>“Pure” function</strong></li>
</ol>
<ul>
<li>No side effects or dependencies on global mutable variables.</li>
</ul>
<ol>
<li><strong>Only I/O side effects</strong>
<ul>
<li>If possible, avoid any mutative side effects.</li>
</ul>
</li>
<li><strong>Mutate data through pointer parameters</strong>
<ul>
<li>If mutation is necessary, use a pointer parameter.</li>
</ul>
</li>
<li><strong>Global dependencies</strong>
<ul>
<li>Mutable global variables should be avoided.</li>
</ul>
</li>
<li><strong>Mutate global data</strong>
<ul>
<li>Only when absolutely necessary (it rarely is)</li>
</ul>
</li>
</ol>
<h2 id="function-pointers">Function pointers</h2>
<p>In Racket, functions are first-class values.</p>
<p>For example, Racket functions are values that can be stored in variables and data structures, passed as arguments and returned by functions.</p>
<p>In C, functions are not first-class values, but <strong>function pointers</strong> are.</p>
<p>A significant difference is that <strong>new</strong> Racket functions can be created during program execution, while in C they cannot.</p>
<ul>
<li><strong>a function pointer can only point to a function that already exists</strong></li>
</ul>
<p>The function pointer stores the starting address a function in code section of memory.</p>
<p>The type of a function pointer includes the return type and all of the parameter types, which makes the syntax a little messy.</p>
<pre><code class="language-C"><div>return_type (*fpname)(param1_type, param2_type, ...)
</div></code></pre>
<ul>
<li>you are not expect to remember the syntax for defining a pointer function for the exam</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-C"><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">my_add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>{
  <span class="hljs-keyword">return</span> x + y;
}
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">my_sub</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>{
  <span class="hljs-keyword">return</span> x - y;
}
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>{
  <span class="hljs-keyword">int</span> (*fp)(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>) = <span class="hljs-literal">NULL</span>;
  fp = my_add;
  trace_int(fp(<span class="hljs-number">7</span>, <span class="hljs-number">3</span>));
  fp = my_sub;
  trace_int(fp(<span class="hljs-number">7</span>, <span class="hljs-number">3</span>));
}
<span class="hljs-comment">// fp(7, 3) =&gt; 10</span>
<span class="hljs-comment">// fp(7, 3) =&gt; 4</span>
</div></code></pre>
<h1 id="p-style%22text-align-center%22-11220-p"><p style="text-align: center;"> 11/2/20 </p></h1>
<pre><code class="language-C"><div><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">constant</span> <span class="hljs-params">(<span class="hljs-keyword">double</span> x)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; 
}

<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">linear</span> <span class="hljs-params">(<span class="hljs-keyword">double</span> x)</span> </span>{
    <span class="hljs-keyword">return</span> x; 
}

<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">square</span> <span class="hljs-params">(<span class="hljs-keyword">double</span> x)</span> </span>{
    <span class="hljs-keyword">return</span> x*x;
}

<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">cube</span> <span class="hljs-params">(<span class="hljs-keyword">double</span> x)</span> </span>{
    <span class="hljs-keyword">return</span> x*x*;
}

<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">R_sum</span> <span class="hljs-params">(<span class="hljs-keyword">double</span> (*fp) (<span class="hljs-keyword">double</span>), <span class="hljs-keyword">double</span> a, <span class="hljs-keyword">double</span> b, <span class="hljs-keyword">double</span> delta)</span> </span>{
    <span class="hljs-keyword">double</span> sum = <span class="hljs-number">0</span>; 
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">double</span> i = a; i &lt; b; i += delta) {
        sum += delta * fp(i);
    }
    <span class="hljs-keyword">return</span> sum; 
}
</div></code></pre>
<h2 id="modularization--adts"><strong>Modularization &amp; ADTs</strong></h2>
<h2 id="modularization"><strong>Modularization</strong></h2>
<p>A <strong>module</strong> provides a collection of functions that share a common aspect or purpose</p>
<ul>
<li>Modules are also commonly known as <strong>libraries</strong>
<ul>
<li>Libraries are usually sufficiently large and used by many users</li>
</ul>
</li>
</ul>
<h2 id="modules-vs-files">Modules vs. files</h2>
<p>In this course, and in most cases, it is considered <strong>good style</strong> to store <strong>modules</strong> in <strong>separate files</strong>.</p>
<h2 id="terminology">Terminology</h2>
<p>The <strong>client</strong> <strong>requires</strong> the <strong>functions</strong> that a module <strong>provides</strong></p>
<ul>
<li>imagine the client is a stranger
<ul>
<li>don't assume there is any context</li>
</ul>
</li>
</ul>
<h2 id="building-a-program">Building a program</h2>
<p>When building a program we can combine (&quot;link&quot;) <strong>multiple machine code files</strong> together to form a single program. that means we can &quot;build&quot; a program from multiple source code files and/or machine code files</p>
<pre><code><div>main.c module.c module2.c module3.ll
</div></code></pre>
<ul>
<li>modules do not contain a main function
<ul>
<li>only <strong>one</strong> main function an be defined in a program</li>
</ul>
</li>
</ul>
<h2 id="motivation-benefits-of-modularization">Motivation (benefits of modularization)</h2>
<p><strong>Re-usability</strong>: A good module can be re-used by many clients. Once we have a &quot;repository&quot; of re-usable modules, we can construct large programs more easily.</p>
<p><strong>Maintainability</strong>: It is much easier to test and debug a single module instead of a large program. If a bug is fond only the module that contains the bug needs to be fixed.</p>
<p><strong>Abstraction</strong>: To use a module, the client needs to understand <strong>functionality</strong> it provides, but it does not need to understand <strong>how</strong> it is implemented.</p>
<h2 id="declarations">Declarations</h2>
<p>In C, a function or variable mus tbe <strong>declared</strong> before it can b accessed (or referenced)</p>
<ul>
<li>
<p>a <strong>declaration</strong> introduces an identifier into a program and specifies its type</p>
</li>
<li>
<p>A declaration only specifies the type of an identifier</p>
</li>
<li>
<p>A definition instructs C to &quot;create&quot; the identifier</p>
<ul>
<li>a definition includes a declaration</li>
</ul>
</li>
</ul>
<p>A variable declarations starts with extern keywords, followed by the type then the variable name. There is no initialization</p>
<pre><code class="language-C"><div><span class="hljs-keyword">extern</span> <span class="hljs-keyword">int</span> g; 
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printg</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>{
    print(<span class="hljs-string">"%d"</span>,g);
}
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">int</span> g = <span class="hljs-number">9</span>; 
    printg(); 
}
</div></code></pre>
<h2 id="module-scope"><strong>Module scope</strong></h2>
<p>To &quot;<strong>hide</strong>&quot; a global identifier from other files, prefix the definition with the <code>static</code> keyword</p>
<p>In other words, the <code>static</code> keyword restricts the scope of a global identifier to the file (module) it is defined in.</p>
<p>We will refer to this as</p>
<h2 id="types-of-scope-revisted">Types of scope (revisted)</h2>
<ul>
<li>Local (block) identifiers
<ul>
<li>only available inside of the function (or bloc)</li>
</ul>
</li>
<li>global identifiers
<ul>
<li>program scope identifiers, available to any file in the program</li>
<li>file scope</li>
</ul>
</li>
</ul>
<h2 id="module-interface"><strong>Module interface</strong></h2>
<p>The module <strong>interface</strong> is the list of functions that the module provides (including the documentation)</p>
<p>The interface is separate from the module <strong>implementation</strong>, which is the code fo the module (i.e., function definitions)</p>
<ul>
<li>the interface is everything that a client would need to use the module</li>
</ul>
<h2 id="interface-contents">Interface contents</h2>
<ul>
<li>an <strong>overall description</strong> of the module</li>
<li>a <strong>function declaration</strong> for each provided function</li>
<li><strong>documentation</strong> (purpose) for each provided function</li>
</ul>
<h2 id="interface-h-files">Interface (.h) files</h2>
<p>For C modules, the interface is placed in a separate file with a <code>.h</code> file extentsion</p>
<p>clients can read the documentation in the interface to understand how to use the provided functions</p>
<p>The client can also copy and pase the function definitions from the header file</p>
<h2 id="include">#include</h2>
<p>A preprocessor directive temporarily modifies a source file just before it is run (but does not save the modifications)</p>
<p>The directive #include cut and pastes the contents of another file directly into your code</p>
<h2 id="implementation-notes">Implementation notes</h2>
<p>It is good style to have header files for each module</p>
<p>Referring the reader to interface file is sufficient</p>
<pre><code class="language-C"><div><span class="hljs-comment">// see fun.h for details</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">is_fun</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{
    <span class="hljs-comment">//...</span>
}
</div></code></pre>
<h2 id="c-standard-modules">C standard modules</h2>
<p>Unlike Racket, there are no &quot;built-in&quot; functions in C</p>
<p>Fortunately, C provides several standard modules also known as libraries with many useful functions</p>
<p>For example, the stdio module provides printf and scanf</p>
<p>when using #include we use angle brackets <code>&lt;&gt;</code> to specify that the module is one of the standard modules and quotes <code>&quot;&quot;</code> for regular modules (i.e, ones we have written)</p>
<pre><code class="language-C"><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"mymodule.h"</span>`</span>
</div></code></pre>
<h1 id="p-style%22text-align-center%22-30120-p-1"><p style="text-align: center;"> 30/1/20 </p></h1>
<h1 id="p-style%22text-align-center%22-30120-p-2"><p style="text-align: center;"> 30/1/20 </p></h1>

    </body>
    </html>