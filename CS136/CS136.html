<!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>CS 136</title>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css" integrity="sha384-yFRtMMDnQtDRO8rLpMIKrtPCD5jdktao2TV19YiZYWMDkUR5GQZR/NOVTdquEx1j" crossorigin="anonymous">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
        <link href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css" rel="stylesheet" type="text/css">
        <style>
.task-list-item { list-style-type: none; } .task-list-item-checkbox { margin-left: -20px; vertical-align: middle; }
</style>
        <style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        
        <script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script>
    </head>
    <body class="vscode-light">
        <h1 id="cs-136">CS 136</h1>
<p>Elementary Algorithm Design and Data Abstraction</p>
<pre><code><div>Instructor: Navid Esfahani
Section: 10 / Tuesday/Thursday (4:00-5:20 or 2:30-3:50)
Email: nnasresf@uwaterloo.ca
Website: http://www.student.cs.uwaterloo.ca/~cs136/
Office: DC 2127
Office Hours: Thursday 8:30 - 10:30 am 
Lab Hours: MC 3004 / (12-5 pm on Fridays)
Textbook: Course Notes
Midterm: 
Final:
</div></code></pre>
<h1 id="p-style%22text-align-center%22-7120-p"><p style="text-align: center;"> 7/1/20 </p></h1>
<p><strong>Main topics &amp; themes:</strong></p>
<ul>
<li>Imperative programming style</li>
<li>Elementary data structures &amp; abstract data types</li>
<li>Modularization</li>
<li>Memory management &amp; state</li>
<li>Introduction to algorithm design &amp; efficiency</li>
<li>Designing &quot;medium&quot; sized, &quot;real world&quot; programs with I/O</li>
</ul>
<p><strong>Programming environment (Seashell)</strong><br>
customized &quot;Seashell&quot; development environment.</p>
<ul>
<li>browser-based for platform independence</li>
<li>Works with both C and Racket</li>
<li>Integrates with our submission &amp; testing environment</li>
<li>Helps to facilitate your own testing
<ul>
<li>Need to use vpn to connect (must be on university network)</li>
</ul>
</li>
</ul>
<p><strong>Course Materials</strong><br>
<em>Textbooks</em></p>
<ul>
<li>&quot;C Programming: A Modern Approach&quot; (CP:AMA) by K. N. King.</li>
<li>&quot;How to Design Programs&quot; (HtDP) by Felleisen, Flatt Findler, Krishnamurthi</li>
</ul>
<p><em>Course notes</em></p>
<ul>
<li>available on website</li>
</ul>
<blockquote>
<p>Go to tutorials to learn</p>
</blockquote>
<p><strong>Marking scheme</strong></p>
<ul>
<li>20% assignments (roughly weekly)</li>
<li>5% participation</li>
<li>25% midterm</li>
<li>50% final
<ul>
<li>must pass both the assignment component and weighted exam component</li>
</ul>
</li>
</ul>
<p>participation grading</p>
<ul>
<li>2 marks for a correct answer, 1 for a wrong answer</li>
<li>Your best 75% of responses are used to calculate your 5%
<ul>
<li>if u get every 3 of 4 right you get 100%</li>
</ul>
</li>
<li>each tutorial u attend will increase your 5% participation grade 0.1% (up to 1.2%, cannot exceed 5%)</li>
</ul>
<p><strong>Assignments:</strong></p>
<ul>
<li>assignment deadlines are strict, but some assignment questions may be granted a &quot;second chance&quot;</li>
<li>Most questions are marked with highest score submission</li>
<li>Hand-marked questions use the closest to the deadline with the highest score</li>
<li>Assignments can be submitted using Seashell</li>
</ul>
<p><strong>Documentation:</strong></p>
<ul>
<li>a <strong>purpose</strong> statement,</li>
<li>a <strong>contract</strong>t (including a requires section if necessary)</li>
<li>unless otherwise stated you don't need templates, data definitions or examples:</li>
</ul>
<h1 id="p-style%22text-align-center%22-9120-p"><p style="text-align: center;"> 9/1/20 </p></h1>
<p><strong>C</strong> was developed by Dennis Ritchie in 1969-1973 to make the Unix operating system more portable.</p>
<ul>
<li>Named &quot;C&quot; because it was successor to &quot;B&quot;, which was a smaller version of BCPL.</li>
<li>C was designed to give programmers low-level access to memory and to be easily translatable into &quot;machine code&quot;.</li>
<li>Thousands of popular programs and portions of <strong>all</strong> popular operating systems are written in C.</li>
</ul>
<p><strong>C versions</strong> There a few different versions of the C standard. In this course, we use C99 (from 1999).</p>
<ul>
<li>The C11 standard added some new features to the language.</li>
<li>The C18 standard only fixes a few bugs from C11</li>
<li>C2x standard is currently in development.</li>
</ul>
<h2 id="c-syntax-intro">C  Syntax Intro</h2>
<p><strong>Comments</strong> any text on a line <strong>after</strong> <code>// is a comment</code>. Any text between <code>/* and */</code> is also a comment.<br>
<strong>Note:</strong> C's multi-line comment cannot be &quot;nested&quot;:</p>
<pre><code class="language-C"><div><span class="hljs-comment">/* this /* nested comment is an */</span> error */
</div></code></pre>
<p><strong>Expressions:</strong> C expressions use traditional <em>infix</em> algebraic notation (ex: 3 + 3)<br>
1 + 3 * 2 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>  </mtext><mo>⟹</mo><mtext>  </mtext></mrow><annotation encoding="application/x-tex">\implies</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.549em;vertical-align:-0.024em;"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⟹</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span></span></span> 7<br>
(1 + 3) * 2 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>  </mtext><mo>⟹</mo><mtext>  </mtext></mrow><annotation encoding="application/x-tex">\implies</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.549em;vertical-align:-0.024em;"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⟹</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span></span></span> 8</p>
<ul>
<li>Because C uses infix notation, parenthesis are needed to specify <strong>order of operations</strong>. This is not needed with prefix (or postfix) notation.</li>
</ul>
<p><strong>Operators:</strong> In addition to the traditional mathematical <em>operators</em>, c also has <em>non-mathematical</em> operators. With over 40 operators in total (CP:AMA Appendix A).</p>
<ul>
<li>C does not have an exponentiation operator (<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>x</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">x^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span>)</li>
<li>
<pre><code class="language-C"><div><span class="hljs-number">4</span> * <span class="hljs-number">5</span> / <span class="hljs-number">2</span> = (<span class="hljs-number">4</span> * <span class="hljs-number">5</span>) /<span class="hljs-number">2</span>
</div></code></pre>
</li>
</ul>
<p><strong>The / operator</strong></p>
<ul>
<li>When working with integers, the C division operator truncates (rounds toward zero) and intermediate values. Note that rounding toward zero is equivalent to &quot;removing&quot; the decimals.</li>
<li>
<pre><code class="language-C"><div><span class="hljs-number">4</span> / <span class="hljs-number">5</span> = <span class="hljs-number">0</span>
</div></code></pre>
</li>
</ul>
<p><strong>The % operator:</strong> the C <strong>modulo</strong> operator produces the <strong>remainder</strong> after integer division<br>
The value of <code>(a % b)</code> is equal to <code>a - (a / b) * b</code></p>
<ul>
<li><strong>Note:</strong> <code>(i % j)</code> has the same sign as <code>i</code>
<ul>
<li>So <code>-10 % 3 = -1</code> instead of the expected <code>2</code>
<ul>
<li>a fix would be <code>((i % j) + j) % j</code>, this is especially useful when working with array indices</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>C identifiers:</strong> Ever function, variable, and structure requires an <em>identifier</em> (or &quot;name&quot;).</p>
<ul>
<li>C identifiers must start with a letter, and can only contain letters, underscores, and numbers.</li>
<li>In this course we use <code>underscore_style</code> (or snake case). Words are separated by underscores and all letters are lowercase.
<ul>
<li><code>underscore_style</code> is the most popular style for C projects. In other languages (Java) <code>camelCaseStyle</code> is popular.</li>
<li>C identifiers can start with a leading underscore (<code>_name</code>) but they may interfere with reserved keywords. Avoid using leading underscores in this course.</li>
</ul>
</li>
</ul>
<p><strong>Anatomy of a function definition</strong></p>
<pre><code class="language-C"><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">my_add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>{
    <span class="hljs-keyword">return</span> a + b; 
}
</div></code></pre>
<ul>
<li>braces ({}) indicate the beginning/end of a function <strong>block</strong></li>
<li><code>return</code> keyword, followed by an expression, followed by a <code>;</code></li>
<li>parameters <code>(a,b)</code> are separated by a comma</li>
<li>the function and parameter <strong>types</strong> are specified (in this case, <code>int</code>)</li>
<li><strong>Note:</strong> the placement of braces and use of whitespace.</li>
</ul>
<p><strong>Static typing system:</strong> C uses a <em>static type system:</em> all types <strong>must</strong> be known <strong>before</strong> the program is run and the type of an identifier <strong>cannot change</strong>.</p>
<ul>
<li>Racket uses a <strong>dynamic</strong> type system</li>
</ul>
<p>If the type in a function definition is missing C assumes it to be an <code>int</code>:</p>
<pre><code class="language-C"><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">my_add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>{ <span class="hljs-comment">//Proper</span>
    <span class="hljs-keyword">return</span> a + b; 
}

my_add(a , b){ 
    <span class="hljs-keyword">return</span> a + b; 
}
</div></code></pre>
<ul>
<li>&quot;type&quot; runtime errors do not exists in C as the program will <strong>never</strong> compile if there is a type error.</li>
</ul>
<p><strong>Function terminology:</strong> We <strong>call</strong> a function by <strong>passing</strong> it <strong>arguments</strong>, a function <strong>returns</strong> a value.</p>
<ul>
<li>In &quot;functional&quot; language terminal we <strong>apply</strong></li>
</ul>
<h2 id="functions-without-parameters"><strong>Functions without parameters:</strong></h2>
<p>use the <code>void</code> keyword to indicate a function has no parameters.</p>
<pre><code class="language-C"><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">my_num</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>{
    <span class="hljs-keyword">return</span> my_add(<span class="hljs-number">40</span>,<span class="hljs-number">2</span>);
}
</div></code></pre>
<ul>
<li>To call a parameterless function, put nothing between the parentheses.</li>
</ul>
<p>C allows the omission of <code>void</code> which indicates an &quot;unknown&quot; or &quot;arbitrary&quot; number of parameters (beyond the scope of this course). <strong>Always use</strong> <code>void</code>.</p>
<ul>
<li>When writing programs, do not write programs which do what you intend, rather write programs which are not able to do anything except for what is intended.</li>
</ul>
<p><strong>No nested function:</strong> In C we are not able to define nested functions. This feature was added to the GNU C compiler but is not found in C Standard.</p>
<pre><code class="language-C"><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">top</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">nested_func</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>{
        <span class="hljs-comment">//...</span>
        <span class="hljs-comment">// This is not possible</span>
    }
}
</div></code></pre>
<h2 id="function-documentations"><strong>Function Documentations</strong></h2>
<p><strong>Whitespaces</strong> C mostly ignores whitespace.</p>
<pre><code class="language-C"><div><span class="hljs-comment">// The following three functions are equivalent</span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">my_add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>{  <span class="hljs-comment">//Good</span>
    <span class="hljs-keyword">return</span> a + b; 
}
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">my_add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>{ <span class="hljs-keyword">return</span> a + b; <span class="hljs-comment">//Bad</span>
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">my_add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> <span class="hljs-comment">//Very bad</span>
b)</span></span>{<span class="hljs-keyword">return</span> a+
b ; }
</div></code></pre>
<p><strong>CS 136 style:</strong></p>
<pre><code class="language-C"><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">my_add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>{  <span class="hljs-comment">//Good</span>
    <span class="hljs-keyword">return</span> a + b; 
}
</div></code></pre>
<ul>
<li>a block start (open brace {) appears at the end of a line</li>
<li>a block end (close brace }) is aligned with the line that started it, and appears on a line by itself</li>
<li>indent a block 2 (recommended), 3 or 4 spaces: <strong>be consistent</strong></li>
<li>add a space after commas and around arithmetic operators</li>
</ul>
<pre><code class="language-C"><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">my_super_long_function</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> c, <span class="hljs-keyword">int</span> d, 
                           <span class="hljs-keyword">int</span> e, <span class="hljs-keyword">int</span> f, <span class="hljs-keyword">int</span> g)</span> </span>{
    <span class="hljs-keyword">return</span> a * b + b * c + c * d + d * e + d + d * e
           d + e; 
}
</div></code></pre>
<ul>
<li>align code when lines are too long</li>
</ul>
<p><strong>Entry point:</strong> Typically a program is run by an Operating System (OS) through a shell or another program such as DrRacket. The SO needs to know where to <strong>start</strong> running the code.</p>
<p><strong>main:</strong> main has no parameters (for now) and <code>int</code> return type.</p>
<pre><code class="language-C"><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>{
    <span class="hljs-comment">//...</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<ul>
<li>The <code>return</code> value communicates to the OS the &quot;error code&quot; also know as &quot;exit code&quot;, &quot;error number&quot; or <code>errno</code></li>
<li>A successful program <code>returns</code> <strong>zero</strong> (no error code).</li>
</ul>
<h1 id="p-style%22text-align-center%22-14120-p"><p style="text-align: center;"> 14/1/20 </p></h1>
<p><strong>Top level expressions:</strong> In C, <em>top-level expressions</em> (code outside of a function) are <strong>not</strong> allowed.</p>
<ul>
<li>Code only execute <strong>inside</strong> of a function</li>
</ul>
<pre><code class="language-C"><div><span class="hljs-number">1</span> + <span class="hljs-number">1</span>; <span class="hljs-comment">// INVALID</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">my_add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>{
    <span class="hljs-keyword">return</span> a + b; 
}
</div></code></pre>
<p><strong>Tracing expressions:</strong> Seashell provides <em>tracing tools</em> to help you &quot;see&quot; what your code is doing. <code>trace_int</code> is a function that allows you trace integers.</p>
<pre><code class="language-C"><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>{
    trace_int(<span class="hljs-number">1</span> + <span class="hljs-number">1</span>); 
    trace_int(my_add(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)); 
}
</div></code></pre>
<h2 id="running-our-first-program">Running our first program</h2>
<pre><code class="language-C"><div><span class="hljs-comment">// First C program (documentation omitted)</span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"cs136.h"</span>  <span class="hljs-comment">// &lt;-- More on this later</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">my_add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>{
    <span class="hljs-keyword">return</span> a + b; 
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>{
    trace_int(<span class="hljs-number">1</span>+<span class="hljs-number">1</span>);
    trace_int(my_add(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>));
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; 
}
</div></code></pre>
<ul>
<li>For now, include &quot;cs136.h&quot; for all programs</li>
</ul>
<h2 id="function-ordering"><strong>Function ordering:</strong></h2>
<ul>
<li>For now, always place function definitions <strong>above</strong> any other functions that reference them (so <code>main</code> is at the bottom).
<ul>
<li>There are ways to bypass this, but we will explore that later</li>
</ul>
</li>
</ul>
<h2 id="program-documentation"><strong>Program documentation:</strong></h2>
<ul>
<li>Document a program (state its purpose) at the <strong>top</strong> of the file (not necessarily where <code>main</code> is).</li>
</ul>
<h2 id="testing"><strong>Testing:</strong></h2>
<ul>
<li><em>tracing tools</em> are an excellent way for you to &quot;see&quot; what is happening
<ul>
<li>They are helpful to <em>informally</em> test code</li>
<li>They are not ways to <em>thoroughly</em> test code</li>
</ul>
</li>
</ul>
<h2 id="boolean-expressions"><strong>Boolean expressions:</strong></h2>
<ul>
<li>In C, boolean expressions do not produces &quot;true&quot; or &quot;false&quot;, they produce either:
<ul>
<li>Zero (<code>0</code>) for &quot;false&quot;</li>
<li>one (<code>1</code>) for &quot;true&quot;</li>
</ul>
</li>
</ul>
<h2 id="comparison-operators"><strong>Comparison operators:</strong></h2>
<p>The <em>equality</em> <strong>operator</strong> in C is <code>==</code> (not the <strong>double</strong> equals)<br>
(3 == 3) <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">⇒</span></span></span></span> 1 (true)<br>
(2 == 3) <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">⇒</span></span></span></span> 0 (false)<br>
The <em>not equal</em> <strong>operator</strong> is <code>!=</code><br>
(2 != 3) <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">⇒</span></span></span></span> 1 (true)</p>
<p>The operators &lt;, &lt;=, &gt; and &gt;= behave exactly as expected.</p>
<ul>
<li>The accidental use of a single <code>=</code> instead of a double <code>==</code> for equality is one of the most common programming mistakes in C. This can be a serious bug.</li>
</ul>
<h2 id="logical-operators"><strong>Logical Operators:</strong></h2>
<p>The logical operators are ! (not), &amp;&amp; (and), || (or):</p>
<p>Similarly to Racket, C <em>short-circuits</em> and stops evaluating logical operators as soon as possible.</p>
<p><strong>All non-zero values are true:</strong></p>
<ul>
<li>operators that produce a Boolean value will always produce <code>0</code> or <code>1</code></li>
<li>Operators that expect a Boolean value will consider <strong>any non-zero value</strong> to be <strong>&quot;true&quot;</strong>
<ul>
<li><strong>Only zero (0) is &quot;false&quot;</strong>
<ul>
<li>The value <code>NULL</code> is also considered false. but in most implementations is evaluated as <code>0</code> anyway.</li>
</ul>
</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>Operator</th>
<th>Symbol</th>
</tr>
</thead>
<tbody>
<tr>
<td>Negations</td>
<td><code>!</code></td>
</tr>
<tr>
<td>multiplicative</td>
<td><code>* / %</code></td>
</tr>
<tr>
<td>additive</td>
<td><code>+ -</code></td>
</tr>
<tr>
<td>comparison</td>
<td><code>&lt; &lt;= &gt;= &gt;</code></td>
</tr>
<tr>
<td>equality</td>
<td><code>== !=</code></td>
</tr>
<tr>
<td>and</td>
<td><code>&amp;&amp;</code></td>
</tr>
<tr>
<td>or</td>
<td><code>||</code></td>
</tr>
</tbody>
</table>
<h2 id="bool-type"><strong>Bool type</strong></h2>
<p>The <code>bool</code> type is an integer that can only have a value <code>0</code> or <code>1</code>.</p>
<pre><code class="language-C"><div><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">is_even</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{
    <span class="hljs-keyword">return</span> (n % <span class="hljs-number">2</span>) == <span class="hljs-number">0</span>;
}
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">my_negate</span><span class="hljs-params">(<span class="hljs-keyword">bool</span> v)</span> </span>{
    <span class="hljs-keyword">return</span> !v; 
}
</div></code></pre>
<ul>
<li>You can technically add integers to booleans, but just because you can doesn't mean you should</li>
</ul>
<h2 id="assertion"><strong>Assertion</strong></h2>
<p>use the <code>assert</code> function to test functions:</p>
<pre><code class="language-C"><div>assert(my_add(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>) == <span class="hljs-number">3</span>); 
</div></code></pre>
<p><code>assert(exp)</code> <strong>stops</strong> the program and displays a message if the expression <code>exp</code> is false (zero).</p>
<p>if exp is true (non-zero), it does &quot;nothing&quot; and continues to the next line of code.</p>
<ul>
<li>assert is very similar to Racket's <code>check-expect</code>:</li>
</ul>
<pre><code class="language-C"><div><span class="hljs-comment">// My second C program (now with better testing!)</span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"cs136.h"</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">my_add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>{
    <span class="hljs-keyword">return</span> a + b; 
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>{
    assert(my_add(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)==<span class="hljs-number">3</span>);
    assert(my_add(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>)==<span class="hljs-number">4</span>);
}
</div></code></pre>
<h2 id="function-requirements"><strong>Function requirements</strong></h2>
<p>The <code>assert</code> function is also very useful for <strong>verifying function requirements</strong>.</p>
<pre><code class="language-C"><div><span class="hljs-comment">// my_divide(x, y) ...</span>
<span class="hljs-comment">// requires: y is not 0 </span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">my_divide</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>{
    assert(y!=<span class="hljs-number">0</span>);
    <span class="hljs-keyword">return</span> x/y; 
}
</div></code></pre>
<h2 id="infeasible-requirements"><strong>Infeasible requirements</strong></h2>
<p>Some requirements are <em>infeasible</em> to assert, or they would be <em>inefficient</em> to assert.<br>
It is good style to communicate that a requirement is not asserted</p>
<pre><code class="language-C"><div><span class="hljs-comment">// some function ... </span>
<span class="hljs-comment">// requires: n is a prime number [not asserted]</span>
</div></code></pre>
<h2 id="multiple-requirements"><strong>Multiple requirements</strong></h2>
<p>With multiple requirements, it is better to have several small <code>assert</code>s. It makes it easier to determine which assertion failed.</p>
<pre><code class="language-C"><div><span class="hljs-comment">// </span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">my_function</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> z)</span> </span>{
    assert((x &gt; <span class="hljs-number">0</span>) &amp;&amp; (y &lt; z)); 
}
</div></code></pre>
<h2 id="statements"><strong>Statements</strong></h2>
<p>Blocks (<code>{}</code>) can contain multiple <em>statements:</em></p>
<pre><code class="language-C"><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">my_divide</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x , in y)</span> </span>{
    assert(y)      <span class="hljs-comment">// statement</span>
    trace_int(y)   <span class="hljs-comment">// statement</span>
    <span class="hljs-keyword">return</span> x / y;  <span class="hljs-comment">// statement</span>
    trace_int(x);  <span class="hljs-comment">// unreachable statement</span>
}
</div></code></pre>
<p>Statements are executed <em>in</em> sequence (on after the other).<br>
The <code>return</code> statement <strong>ends</strong> the function. In the above code, <code>trace_int(x)</code> will never run.</p>
<h2 id="brief-introduction-to-control-flow"><strong>Brief introduction to control flow</strong></h2>
<p>The <code>return</code> statement is a special kind of statement known as a <em>control flow</em> statement.<br>
<code>return</code> &quot;controls the flow&quot; of the program by ending the function and returning to the caller.</p>
<h2 id="conditionals"><strong>Conditionals</strong></h2>
<p>The <code>if</code> control flow statement allows us to have functions with conditional behaviour.</p>
<pre><code class="language-C"><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">my_abs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{
    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">0</span>) { <span class="hljs-comment">// note: the () are required</span>
        <span class="hljs-keyword">return</span> -n; 
    } <span class="hljs-keyword">else</span> {     <span class="hljs-comment">// In CS136 they have else on the same line on the closing }</span>
        <span class="hljs-keyword">return</span> n; 
    }
}
</div></code></pre>
<ul>
<li>There can be more than one <code>return</code> in a function, but only one can ever execute.</li>
</ul>
<h2 id="else-if"><strong>else if</strong></h2>
<p>if there are more than wo possible results, use <code>else if</code></p>
<pre><code class="language-C"><div><span class="hljs-comment">// in_between(x, lo, hi) determines if lo &lt;= x &lt;= hi</span>
<span class="hljs-comment">// requires: lo &lt;= hi</span>

<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">in_between</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> lo, <span class="hljs-keyword">int</span> hi)</span> </span>{ 
    assert(lo&lt;=hi); 
    <span class="hljs-keyword">if</span> (x &lt; lo) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x &gt; hi) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; 
    }
}
</div></code></pre>
<p><strong>The C ternary conditional operator</strong> (<code>?:</code>)</p>
<pre><code class="language-C"><div>q ? a : b
</div></code></pre>
<ul>
<li><code>a</code> if <code>q</code> is <code>true</code>, <code>b</code> if <code>q</code> is <code>false</code></li>
</ul>
<pre><code class="language-C"><div>(v &gt;= <span class="hljs-number">0</span>) ? v : -v;      <span class="hljs-comment">// abs(v)</span>
(a &gt; b) a : b;          <span class="hljs-comment">// max(a, b)</span>
</div></code></pre>
<p>Goals of this section</p>
<ul>
<li>Demonstrate the use of C syntax and terminology</li>
<li>Write a simple function in C</li>
<li>Use the C operators introduced in this module</li>
<li>Explain the significance of the <code>main</code> function in C</li>
<li>Perform basic tracing in C using <code>trace_int</code></li>
<li>Use assert for testing and to verify requirements</li>
<li>Provide the required documentation for C functions</li>
</ul>
<h2 id="introduction-to-imperative-c"><strong>Introduction to imperative C</strong></h2>
<p>Readings: CP:AMA</p>
<h2 id="functional-programming"><strong>Functional programming</strong></h2>
<ul>
<li>functions are &quot;pure&quot; (a.k.a &quot;mathematical&quot;)
<ul>
<li>functions <strong>only return values</strong></li>
<li>return values <strong>only depend</strong> on argument values</li>
</ul>
</li>
<li>only <strong>constants</strong> are used</li>
</ul>
<p>In the imperative programming paradigm functions may be &quot;impure&quot; and will use variables</p>
<h2 id="compound-statement"><strong>Compound statement</strong></h2>
<p>In imperative programming, a <strong>sequence of instructions</strong> (or &quot;statements&quot;) are executed. We have already seen this:</p>
<pre><code class="language-C"><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>{ 
    trace_int(<span class="hljs-number">1</span>+<span class="hljs-number">1</span>); 
    assert(<span class="hljs-number">3</span> &gt; <span class="hljs-number">2</span>); 
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; 
}
</div></code></pre>
<p>A block <code>{}</code> is formally known as a <em>compound statement</em>, which is simple a <strong>sequence of statements</strong> to be executed in order</p>
<ul>
<li>blocks can contain local variable definitions</li>
</ul>
<h2 id="io-inputoutput"><strong>I/O</strong> (input/output)</h2>
<ul>
<li>in this course we use simple <strong>text-based</strong> I/O.</li>
</ul>
<h2 id="text-io"><strong>Text I/O</strong></h2>
<p>To displace text output in C, we use the <code>printf</code> function.</p>
<pre><code class="language-C"><div><span class="hljs-comment">// My first program with I/O</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"cs136.h"</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>{
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Hello, World"</span>); 
}
</div></code></pre>
<h1 id="p-style%22text-align-center%22-7120-p-1"><p style="text-align: center;"> 7/1/20 </p></h1>

    </body>
    </html>