# CS 136
Elementary Algorithm Design and Data Abstraction
``` 
Instructor: Navid Esfahani
Section: 10 / Tuesday/Thursday (4:00-5:20 or 2:30-3:50)
Email: nnasresf@uwaterloo.ca
Website: http://www.student.cs.uwaterloo.ca/~cs136/
Office: DC 2127
Office Hours: Thursday 8:30 - 10:30 am 
Lab Hours: MC 3004 / (12-5 pm on Fridays)
Textbook: Course Notes
Midterm: 
Final:
```
# <p style="text-align: center;"> 7/1/20 </p>
**Main topics & themes:**
- Imperative programming style
- Elementary data structures & abstract data types
- Modularization
- Memory management & state
- Introduction to algorithm design & efficiency 
- Designing "medium" sized, "real world" programs with I/O


**Programming environment (Seashell)**  
customized "Seashell" development environment.
- browser-based for platform independence 
- Works with both C and Racket
- Integrates with our submission & testing environment 
- Helps to facilitate your own testing
  - Need to use vpn to connect (must be on university network)

**Course Materials**    
*Textbooks*
- "C Programming: A Modern Approach" (CP:AMA) by K. N. King. 
- "How to Design Programs" (HtDP) by Felleisen, Flatt Findler, Krishnamurthi        
  
*Course notes*  
- available on website
> Go to tutorials to learn 

**Marking scheme**
- 20% assignments (roughly weekly)
- 5% participation
- 25% midterm 
- 50% final
  - must pass both the assignment component and weighted exam component

participation grading
- 2 marks for a correct answer, 1 for a wrong answer
- Your best 75% of responses are used to calculate your 5%
  - if u get every 3 of 4 right you get 100%
- each tutorial u attend will increase your 5% participation grade 0.1% (up to 1.2%, cannot exceed 5%)

**Assignments:**     
- assignment deadlines are strict, but some assignment questions may be granted a "second chance"
- Most questions are marked with highest score submission
- Hand-marked questions use the closest to the deadline with the highest score
- Assignments can be submitted using Seashell

**Documentation:**
- a **purpose** statement, 
- a **contract** (including a requires section if necessary)
- unless otherwise stated you don't need templates, data definitions or examples: 

# <p style="text-align: center;"> 9/1/20 </p>
**C** was developed by Dennis Ritchie in 1969-1973 to make the Unix operating system more portable. 
- Named "C" because it was successor to "B", which was a smaller version of BCPL. 
- C was designed to give programmers low-level access to memory and to be easily translatable into "machine code". 
- Thousands of popular programs and portions of **all** popular operating systems are written in C.

**C versions** There a few different versions of the C standard. In this course, we use C99 (from 1999). 
- The C11 standard added some new features to the language. 
- The C18 standard only fixes a few bugs from C11
- C2x standard is currently in development. 

## C  Syntax Intro 
**Comments** any text on a line **after** `// is a comment`. Any text between `/* and */` is also a comment.    
**Note:** C's multi-line comment cannot be "nested":
```C
/* this /* nested comment is an */ error */
```

**Expressions:** C expressions use traditional *infix* algebraic notation (ex: 3 + 3)   
1 + 3 * 2 $\implies$ 7  
(1 + 3) * 2 $\implies$ 8
- Because C uses infix notation, parenthesis are needed to specify **order of operations**. This is not needed with prefix (or postfix) notation. 

**Operators:** In addition to the traditional mathematical *operators*, c also has *non-mathematical* operators. With over 40 operators in total (CP:AMA Appendix A).
- C does not have an exponentiation operator ($x^n$)
- ```C 
  4 * 5 / 2 = (4 * 5) /2
  ```
**The / operator**
- When working with integers, the C division operator truncates (rounds toward zero) and intermediate values. Note that rounding toward zero is equivalent to "removing" the decimals. 
- ```C 
  4 / 5 = 0
  ```

**The % operator:** the C **modulo** operator produces the **remainder** after integer division     
The value of `(a % b)` is equal to `a - (a / b) * b`
- **Note:** `(i % j)` has the same sign as `i`
  - So `-10 % 3 = -1` instead of the expected `2` 
    - a fix would be `((i % j) + j) % j`, this is especially useful when working with array indices

**C identifiers:** Ever function, variable, and structure requires an *identifier* (or "name"). 
- C identifiers must start with a letter, and can only contain letters, underscores, and numbers. 
- In this course we use `underscore_style` (or snake case). Words are separated by underscores and all letters are lowercase.
  - `underscore_style` is the most popular style for C projects. In other languages (Java) `camelCaseStyle` is popular. 
  - C identifiers can start with a leading underscore (`_name`) but they may interfere with reserved keywords. Avoid using leading underscores in this course. 

**Anatomy of a function definition**
```C
int my_add(int a, int b) {
    return a + b; 
}
```
- braces ({}) indicate the beginning/end of a function **block**
- `return` keyword, followed by an expression, followed by a `;`
- parameters `(a,b)` are separated by a comma
- the function and parameter **types** are specified (in this case, `int`)
- **Note:** the placement of braces and use of whitespace. 
  
**Static typing system:** C uses a *static type system:* all types **must** be known **before** the program is run and the type of an identifier **cannot change**.
- Racket uses a **dynamic** type system

If the type in a function definition is missing C assumes it to be an `int`: 
```C
int my_add(int a, int b) { //Proper
    return a + b; 
}

my_add(a , b){ 
    return a + b; 
}
```
- "type" runtime errors do not exists in C as the program will **never** compile if there is a type error. 

**Function terminology:** We **call** a function by **passing** it **arguments**, a function **returns** a value. 
- In "functional" language terminal we **apply** 

## **Functions without parameters:** 
use the `void` keyword to indicate a function has no parameters. 
```C
int my_num(void) {
    return my_add(40,2);
}
```
- To call a parameterless function, put nothing between the parentheses. 

C allows the omission of `void` which indicates an "unknown" or "arbitrary" number of parameters (beyond the scope of this course). **Always use** `void`.
- When writing programs, do not write programs which do what you intend, rather write programs which are not able to do anything except for what is intended. 

**No nested function:** In C we are not able to define nested functions. This feature was added to the GNU C compiler but is not found in C Standard. 

```C
int top(void) {
    int nested_func(void) {
        //...
        // This is not possible
    }
}
```

## **Function Documentations**

**Whitespaces** C mostly ignores whitespace. 
```C
// The following three functions are equivalent

int my_add(int a, int b) {  //Good
    return a + b; 
}
int my_add(int a, int b) { return a + b; //Bad
}

int my_add(int a, int //Very bad
b){return a+
b ; }
```

**CS 136 style:**
```C
int my_add(int a, int b) {  //Good
    return a + b; 
}
```
- a block start (open brace {) appears at the end of a line
- a block end (close brace }) is aligned with the line that started it, and appears on a line by itself
- indent a block 2 (recommended), 3 or 4 spaces: **be consistent**
- add a space after commas and around arithmetic operators


```C 
int my_super_long_function(int a, int b, int c, int d, 
                           int e, int f, int g) {
    return a * b + b * c + c * d + d * e + d + d * e
           d + e; 
}
```
- align code when lines are too long

**Entry point:** Typically a program is run by an Operating System (OS) through a shell or another program such as DrRacket. The SO needs to know where to **start** running the code. 

**main:** main has no parameters (for now) and `int` return type. 
```C
int main(void) {
    //...
    return 0;
}
```
- The `return` value communicates to the OS the "error code" also know as "exit code", "error number" or `errno`
- A successful program `returns` **zero** (no error code). 
# <p style="text-align: center;"> 14/1/20 </p>
**Top level expressions:** In C, *top-level expressions* (code outside of a function) are **not** allowed. 
- Code only execute **inside** of a function
```C
1 + 1; // INVALID
int my_add(int a, int b){
    return a + b; 
}
```

**Tracing expressions:** Seashell provides *tracing tools* to help you "see" what your code is doing. `trace_int` is a function that allows you trace integers. 

```C
int main(void){
    trace_int(1 + 1); 
    trace_int(my_add(1,2)); 
}
```

## Running our first program
```C
// First C program (documentation omitted)

#include "cs136.h"  // <-- More on this later

int my_add(int a, int b){
    return a + b; 
}

int main(void){
    trace_int(1+1);
    trace_int(my_add(1,2));
    return 0; 
}
```
- For now, include "cs136.h" for all programs

## **Function ordering:**
- For now, always place function definitions **above** any other functions that reference them (so `main` is at the bottom). 
  - There are ways to bypass this, but we will explore that later

## **Program documentation:**
- Document a program (state its purpose) at the **top** of the file (not necessarily where `main` is).

## **Testing:**
- *tracing tools* are an excellent way for you to "see" what is happening
  - They are helpful to *informally* test code
  - They are not ways to *thoroughly* test code

## **Boolean expressions:**
- In C, boolean expressions do not produces "true" or "false", they produce either:
  - Zero (`0`) for "false"
  - one (`1`) for "true"

## **Comparison operators:**   
The *equality* **operator** in C is `==` (not the **double** equals)  
(3 == 3) $\Rightarrow$ 1 (true)     
(2 == 3) $\Rightarrow$ 0 (false)     
The *not equal* **operator** is `!=`  
(2 != 3) $\Rightarrow$ 1 (true) 

The operators <, <=, > and >= behave exactly as expected. 
- The accidental use of a single `=` instead of a double `==` for equality is one of the most common programming mistakes in C. This can be a serious bug. 

## **Logical Operators:**
The logical operators are ! (not), && (and), || (or):

Similarly to Racket, C *short-circuits* and stops evaluating logical operators as soon as possible. 

**All non-zero values are true:**
- operators that produce a Boolean value will always produce `0` or `1`
- Operators that expect a Boolean value will consider **any non-zero value** to be **"true"**
  - **Only zero (0) is "false"**
    - The value `NULL` is also considered false. but in most implementations is evaluated as `0` anyway. 

Operator|Symbol
---|---
Negations| `!`
multiplicative | `* / %`
additive |`+ - `
comparison | `< <= >= >`
equality | `== !=`
and | `&&`
or| `||`

## **Bool type**
The ` bool` type is an integer that can only have a value `0` or `1`. 
```C
bool is_even(int n) {
    return (n % 2) == 0;
}
bool my_negate(bool v) {
    return !v; 
}
```
- You can technically add integers to booleans, but just because you can doesn't mean you should

## **Assertion**
use the `assert` function to test functions: 
```C
assert(my_add(1,2) == 3); 
```
`assert(exp)` **stops** the program and displays a message if the expression `exp` is false (zero). 

if exp is true (non-zero), it does "nothing" and continues to the next line of code. 
- assert is very similar to Racket's `check-expect`: 

```C
// My second C program (now with better testing!)

#include "cs136.h"

int my_add(int a, int b) {
    return a + b; 
}

int main(void){
    assert(my_add(1,2)==3);
    assert(my_add(2,2)==4);
}
```

## **Function requirements**
The `assert` function is also very useful for **verifying function requirements**. 
```C
// my_divide(x, y) ...
// requires: y is not 0 

int my_divide(int x, int y) {
    assert(y!=0);
    return x/y; 
}
```
## **Infeasible requirements**
Some requirements are *infeasible* to assert, or they would be *inefficient* to assert.         
It is good style to communicate that a requirement is not asserted 
```C
// some function ... 
// requires: n is a prime number [not asserted]
```

## **Multiple requirements**
With multiple requirements, it is better to have several small `assert`s. It makes it easier to determine which assertion failed. 
```C
// 
int my_function (int x, int y, int z) {
    assert((x > 0) && (y < z)); 
}
```
## **Statements**
Blocks (`{}`) can contain multiple *statements:*
```C
int my_divide(int x , in y) {
    assert(y)      // statement
    trace_int(y)   // statement
    return x / y;  // statement
    trace_int(x);  // unreachable statement
}
```
Statements are executed *in* sequence (on after the other).         
The `return` statement **ends** the function. In the above code, `trace_int(x)` will never run. 

## **Brief introduction to control flow**
The `return` statement is a special kind of statement known as a *control flow* statement.       
`return` "controls the flow" of the program by ending the function and returning to the caller.         

## **Conditionals**
The `if` control flow statement allows us to have functions with conditional behaviour. 
```C
int my_abs(int n) {
    if (n < 0) { // note: the () are required
        return -n; 
    } else {     // In CS136 they have else on the same line on the closing }
        return n; 
    }
}
```
- There can be more than one `return` in a function, but only one can ever execute. 

## **else if**
if there are more than wo possible results, use `else if`
```C
// in_between(x, lo, hi) determines if lo <= x <= hi
// requires: lo <= hi

bool in_between(int x, int lo, int hi) { 
    assert(lo<=hi); 
    if (x < lo) {
        return false;
    } else if (x > hi) {
        return false;
    } else {
        return true; 
    }
}
```

**The C ternary conditional operator** (`?:`)
```C
q ? a : b
```
- `a` if `q` is `true`, `b` if `q` is `false`
```C
(v >= 0) ? v : -v;      // abs(v)
(a > b) a : b;          // max(a, b)
```

Goals of this section
- Demonstrate the use of C syntax and terminology
- Write a simple function in C
- Use the C operators introduced in this module
- Explain the significance of the `main` function in C
- Perform basic tracing in C using `trace_int`
- Use assert for testing and to verify requirements
- Provide the required documentation for C functions

## **Introduction to imperative C**
Readings: CP:AMA

## **Functional programming**
- functions are "pure" (a.k.a "mathematical")
  - functions **only return values**
  - return values **only depend** on argument values
- only **constants** are used       

In the imperative programming paradigm functions may be "**impure**" and will **use variables**

## **Compound statement**
In imperative programming, a **sequence of instructions** (or "statements") are executed. We have already seen this: 
```C
int main(void) { 
    trace_int(1+1); 
    assert(3 > 2); 
    return 0; 
}
```
A block `{}` is formally known as a *compound statement*, which is simple a **sequence of statements** to be executed in order
- blocks can contain local variable definitions

## **I/O** (input/output)
- in this course we use simple **text-based** I/O. 

## **Text I/O**
To displace text output in C, we use the `printf` function. 
```C 
// My first program with I/O
#include "cs136.h"

int main(void) {
    printf("Hello, World"); 
}
```

# <p style="text-align: center;"> 16/1/20 </p>
## **Text I/O ...**
The **newline** character (`\n`) is necessary to properly format output to appear on multiple lines
- by default `printf` does not print a new line each time

To output values, use a **format specifier** (the **f** in print**f**). 
- For an integer in "**d**ecimal format the format specifier is `%d`

```C
printf("2 + 2 is %d",2+2);
printf("%d + %d is: %d\n",2,2,2+2);
// 2 + 2 is: 4
```

If you would like to print a percent sign (%), use two (%%). 
```C
printf("I am %d%% sure you should watch your",100);
// I am 100% sure you should watch your
printf("spacing!\n");
```
Similarly, 
- to print a backslash (`\`) use two (`\\`)
- To print a quote add a backslash (`\"`)

## Side effects and state (introduction)
In general, a programming side effect is when the **state** of something "changes".         
State refers to the value of some data (or "information") **at a moment in time**.
- You have a blank piece of paper, then you write your name on that paper. 
  - You have changed the state of that paper: at one moment it was blank, and in the next it was "autographed"
  - The side effect of writing your name was that you changed the state of the paper

## Documenting side effects
The `printf` function has a side effect: it changes the output or "display"

```C
// noisy_abs(n) computes |n|
// effects: may produce output

int noise_abs(int n) {
    if (n < 0) {
        printf("Yo! I'm changing the sign!\n");
        return -n;
    } else {
        return n; 
    }
}
```
In this course there is no need to provide any detail in the "effects" section `// effects: produces output` is sufficient. 
- occasionally you want to describe the output in the purpose if the output is important in understanding the core behaviour of the function

## Debugging tools
Statement used for debugging and informal testing (assert, trace_int) are **not** considered side effects. 

## I/O terminology 
In the context I/O, be careful with eerminoloy. 
```C
int sqr(int n) {
    return n * n; 
}

int noise_sqr(int n) {
    printf("Yo! I'm squaring %d!\n",n);
    return n * n; 
}
```
- informally, someone might say: if you **input** `7` into `sqr`, it **outputs** `49`
  - We say if `7` is **passed** into `sqr` it **returns** `49`
  - if `7` is **passed** into `noisy_sqr` it **outputs** a message and **returns** `49`.
>Our tracing tools print to a different output **stream** than `printf` (like writing on two different pieces of paper). By default `printf` outputs to `stdout` (**st**andard **out**put stream). Our tracing tools print to `stderr` (**st**andard **err**or stream). 

## Void functions
```C
// Display score: produces score
// Effects produces output
void display_score(int score, int max) { 
    printf("your score is %d out of %d.\n", score, max)
}
```
- In a void function, the return is optional and has no expression. 

## Expression statements
An **expression statement** is an expression with a semicolon (`;`)
```C
int main(void) { 
    11;
    10 + 1; 
    sqr(6) - sqr(5); 
    printf("expression\n");
    printf("five\n")+6;
}
```
- The **value** of an expression statement is **discarded** after it is executed. 
  - The purpose of an expression statement is to generate **side effects**
    - In the example above the `printf` statements produce an output side effect
    - but `11;` produces no side effect which can result in a warning by some compilers but the program still runs

## Return value of `printf`
Surprisingly `printf` is not a `void` function it (`return`s an `int`)
- `printf` returns the number of characters that were printed
  
## Statements
- **Compound statements (blocks)**
  - a sequence of statements (to be executed in order)
- **Expression statements**
  - for generating side effects (**values are discarded after execution**)
- **Control flow statement**
  - control the order in which other statements are executed

## Variables
**Variables** store values
To define a variable in C, we need (in order):
- the **type** (`int`)
- the **identifier** ("name")
- the **initial value**
```C
int my_variable = 7; // definition
```
Definitions **are not** statements. 

## Mutation
When the value of a variable is changed, it is known as **mutation**
```C 
int main(void) {
    int m = 5; 
    trace_int(m);   // definition (with initialization)
    m = 6; 
    trace_int(m);   // mutation!
    m = -1; 
    trace_int(m);   // more mutation!
}
```
Mutation is a **side effect**

## Assignment operator
In C, mutation is achieved with the **assignment operator** (`=`)
```C
m = m + 1; 
```
- The "right hand side" RHS must be an *expression* that produces a **value** with the same type as     LHS. 
- The LHS **must** be the name of a variable
- The LHS variable is mutated to store the **value** of the RHS
- This is a side effect 
  - **Note** assignment evaluates to the RHS so `if(n=1)` passes

**Pro tip:** some defensive programmers get in the habit of writing equalities as `(13 == i)` this makes it so that if one equals is missed it produces an error rather than being a bug. 

## Initialization 
C allows a variable definition without initialization, but is bad style. 
```C
int my_variable = 7;    // initialized
int another_variable;   // uninitialized
```
- Always initialize variables

## Initialization is not assignment
- The `=` use in initialization is **not** the assignment operator. 
``` C
int n = 5;  // initialization syntax
n = 6;  // assignment operator 
```
- This matters more later on in object oriented programming where assignment is more apparently different than initialization

## More assignment operators 
```C
 x += 2;    // x = x + 2; 
 ++x;   x++; // x += 1;   
```
- the prefix (`++x`) and postfix (`x++`) both increment by `1`
  - `x++` produces the "old" value of `x` then increments by `1`
  - `++x` increments `x` then produces the "new" value of `x` 
- prefix (`++x`) is usually preferred to improve clarity and efficiency

# <p style="text-align: center;"> 21/1/20 </p>
## Constants
A **constant** is a variable that is **immutable**. In other words, the value of a constant cannot be changed. 
```C
const int my_constant = 42
```
- In this course **variable** refers to both constants and 

It is **good style** to use `const` as much as possible (whenever it is appropriate): 
- communicates the intended use of the variable
- prevents accidental or unintended mutation 
- may help optimize your code 

## Global and local variables
Variables are either **global** or **local**
- **Global** variables are defined *outside* of functions
- **Local** variables are defined *inside* of functions

```C
int my_global_variable = 7; 
void f(void) {
    int my_local_variable = 11; 
    //...
}
```

## Variable Scope
The **scope** of a variable is the region of code where it is accessible

## Block (local scope) 
Local variables have **block scope**. their scope extended from their definition to the end of the block they are defined in. 

```C
int n = 1; 

int main(void) {
    trace_int(n);           // n => 1
    int n = 2; 
    trace_int(n);           // n => 2
    {
        int n = 3; 
        trace_int(n);       // n => 3
    }
    trace_int(n);           // n => 2
}
```
- Note how `n` is equal to the value assigned in the nearest scope
- Also there is probably not much good use for opening and closing curly braces in the middle of another block

In older versions of C all local variable definitions had to be at the start of a function block (before any statements). In C99 you may define a local variable anywhere in a block.       

Modern programming guides recommend that you define a variable: 
- in the narrowest scope possible
- as close to its first use as possible
  - This improves readability and ensure

```C
int a = 2; 
int f() {
    int n = 3; 
    // Here
}
int b = 5; 
int main() {
    int v = 3; 
    f(); 
}
```
- **Note** the function `f()` does not have access to the variable `v`, `v` is not in the scope of `f()`. But `a` is. `b` is **not**. 


## "Impure" functions
Recall that the functional paradigm requires "pure" functions: 
- functions **only return values** (no side effects)
- Return values **only depend** on argument values

Impure functions are sometimes called "procedure" or "routines" to distinguish behaviour from "pure" functions

## Mutating global variables
A function that mutates a global variable has a *mutation* side effect (which makes it "impure").
- Mutating a **local variable** does **not** give a function a side effect 

## Mutating parameters
Parameters are nearly *indistinguishable* from local variables, and can also be mutated. 
- mutating parameters is not a local function

## Global dependency
A function that depends on a global *mutable* variable is "impure" even it has **no** side effects.       
- if the global variable is constant it is technically impure, but you could always have the constant value inside the function instead to make it pure so it is pure in a sense? 
  
A "pure" function only depends on its argument values. 

## Avoiding global mutable variables
Global *mutable* variables are almost always poor style and should be avoided.      
Unless otherwise specified, you are **note allowed** to use global *mutable* variable on your assignments.      
On the other hand, global *constants* are great style and strongly encouraged. 

## Static local variables
Have the scope of a local variable, but the duration of a global variable. Their value persists between function calls. 
```C
int increment(void) {
    static int counter = 0; 
    counter += 1; 
    return counter; 
}
```
- This counts how many times the function was called
  
Like global mutable variables, they are almost always poor style and should be avoided. They are not allowed in this course. 

## Text input
The converse of `printf` is `scanf`, but we are not going to use it yet. 

## Read helper functions
In this course we have provided some helper functions to make reading in input easier. For example: 
`read_int()` reads an integer

## Input formatting 
When C read in `int` values, it skips over any white spaces

## Reading input
- once you read an input it can no longer be read again, so store your values. 

## Testing harness 
To summarize our function testing strategies: 

```C
void test_sqr(void) {
    int n = read_int(); 
    if (n != READ_INT_FAIL) {
        printf("%d", sqr(n));
        test_sqr(); 
    }
}
```
- This strategy is useful for testing both "pure" and "impure" functions. 

## Goals of this section
You should be able to answer all of the following:
- explain what a side effect is 
- document a side effect with an effects section
- print output with `printf` and read input using the provided functions (`read_int`)
- define global and local mutable variables and constants
- use the C assignment operators 
- Use the new terminology introduced, including: mutation, expression statements and compound statements ({})

## **C Model: Memory & Control Flow**
## Models of computation 
In this course, we model the behaviour of C with two complimentary mechanisms
- control flow
- memory

## Control flow
We use **control flow** to model how programs are executed.         
During execution, we keep track of the program location, which is "where" in the code the execution is currently occurring.         
When a program is "run", the program location starts at the beginning of the main function.
- In hardware this is known as the **program counter**       
  

## Types of control flow 
- function calls
- conditionals (i.e, if statements)
- iterations (i.e, loops)

## Return 
`return` changes the program location to go back to the most recent calling function. Obviously C needs to keep track of where it is, we discuss this more later on in the course. 

## Conditionals
The syntax of `if` is 
```C
if (expression) statement
```
where the statement is only executed if the expression is true

```C
if (n > 0) printf("n is positive"); 
```
- this is bad style 
  
The `if` statement only affects whether the **next** statement is executed. This is why if statements work without curly braces if it is only one statement (the curly braces are what allow more than one statement to be ignored). 


# <p style="text-align: center;"> 23/1/20 </p>
Clarifications: 
- using global constant variables in a function does not make it impure
- `x++` does not have lower priority than `=`, rather `x++` returns the old value of `x` by design

## Flowchart basics
- beginning in end are in elongated **ellipses**
- any statements or return values are in **rectangles**
- any choices or conditionals are in **diamonds**
  

Braces are sometimes necessary to avoid a "dangling" else. 
```C
if (y > 0)
    if (y != 7)
        printf("you lose"); 
else
    printf("you win!");     // when does this print
```
- The else is related to the second if
- this is bad style

## Switch statements
- Control flow statement
- Very error prone for beginner programmers and will **not be used in this course**

```C
int a = 5; 
switch(a) {
    case 0: 
        printf("Won't print this"); 
    case 5: 
        printf("Will print this"); 
    case 4: 
        print("also this..."); 
    default: 
        print("and this..."); 
}
```
- This will print more than one case because in a switch case u must have a `break` statement to end the switch after the desired case. 

## C goto
- another control flow statement that will not be used is `goto`
- It was looked down upon by many as i tmakes "spaghetti code" that is hard to read 
  - Now most agree it is useful and appropriate in **some** circumstances

```C
if (k < 0) goto mylabel; 
// ...
mylabel: 
//...
```

## Looping
With mutation, we can control flow with a method known as **looping**
```C
while (expression) statement
```
`while` is similar to `if`: the `statement` is only executed if the `expression` is true. 

The difference is, `while` **repeatedly** "loops back" and executes the `statement` until the `expression` is false

## Iteration vs. recursion
Using a loop to solve a program is called **iteration**

*Iteration* is an alternative to *recursion* and is much more common in imperative programming. 

```C
// recursion 
int sum(int k) {
    if (k <= 0) { 
        return 0; 
    }
    return k + sum(k - 1); 
}

// iteration
int sum(int k) {
    int s = 0; 
    while (k > 0) {
        s += k; 
        --k; 
    }
    return s; 
}
```
- In general, using recursion can cause ur stack to crash or overflow because every time the function is called the information must be stored somewhere and can eventually exceed the stack 
  - but iteration uses the same variables and replaces the values making it safer
- If something is can be modelled using iteration it can always be modelled using recursion

## Tracing tools
`trace_int()` traces an integer even through loops and will state when a loop has started and the value of the integer for each iteration

## do ... while 
the `do` control flow statement is very similar to `while`      
```C
do statement while (expression); 
```
The difference is that `statement` is always executed at least once, and the expression is checked at the end of the loop 
```C
do { 
    printf("try to guess my numebr! \n"); 
    guess = read_int();
} while (guess != my_number && guess != READ_INT_FAIL); 
```

## break 
The `break` control flow statement is useful to exit from the middle of a loop

`break` is 

## continue 
The `continue` control flow statement skips over the rest of the statements in the current block and "continues" with the loop. 

## For loops
The final control flow statement we introduce `for`, which is often referred to as a "`for` loop". 

`for` loops are a "condensed" version of a `while` loop. 

```C
for (int i = 0; i < 10; ++i) {
    printf("%d",i;)
}
```

```C
// counting up from 0 to n-1
for ( i = 0; i < n; ++i) {...}

// counting up from 1 to n
for (i = 1; i <= n; ++i) {...}

// counting down from n-1 to 0
for (i = n - 1; i >= 0; --i) {...}

// counting down from n to 1
for (i = n; i > 0; --i) {...}
```

any of the three components of a `for` statement can be omitted. If the expression is omitted, it is always "true". 


# <p style="text-align: center;"> 28/1/20 </p>
## Memory Review
One bit of storage (in memory) has two possible **states**: 0 or 1          
A byte is 8 bits of storage. Each byte in memory is in one of 256 ($2^8$) states.       

## Accessing memory
The smallest accessible unit of memory is a byte.       
To access a byte of memory, its *position* in memory, which is known as the **address** of the byte, must be known.         
For example, if you have 1 MB of memory (RAM), the address of the first byte is 0 and the address of the last byte is $1048575 = (2^{20} - 1)$.      

**Note:** Memory address are usually represented in hex, so with 1 MB of memory, the address of the first byte is **0x0**, and the address of the last byte is **0XFFFFF**. 
- hexadecimal is used because it is more condensed than trying to use binary 

## Defining variables
For a **variable definition** in C: 
- reserves ("finds") space in memory to **store** the variable
- "Keeps track of" the address of that storage location
- stores the initial value of the variable at that location (address)

In CS 135 we viewed variables as a "name for a value", but we now view variables as "name for a location" where the values are stored. 

## sizeof
When we define a variable, C reserves space in memory to store its value, but **how much space** is require? 
- that depends on the **type** of the variable

The **size operator** (`sizeof`) produces the number of bytes required to store a type (it can also be used on identifiers). `sizeof` looks like a function, but it is an **operator**.

## Integer Limits
C uses 4 bytes (32 bits) to store an `int`, there are only $2^{32}$ possible values that can be represent.      
The range of C int values is $-2^{31} \cdots (2^{31}-1)$ or $-2,147,488,648 \cdots 2,147,483,647$. 
In our environment, the constants `INT_MIN` and `INT_MAX` are defined as those limits. 

## Overflow 
if we try to represent values outside of `int` limits, **overflow** occurs. 
- never assume what the value of an `int` will be after an overflow, the value of an integer that has overflowed is **undefined**
  
## The char type
The `char` type is also used to store integers, but C allocates **one byte** of storage for a `char` (an `int` has 4 bytes).        
The are $2^8$ possible values for a `char` ($-128 \cdots 127$ in seashell environment)    

## ASCII
ASCII was developed when *teletype* machines were popular, most modern applications have moved to unicode 
- a popular method of **encoding** Unicode is the UTF-8 standard, where displayable ASCII code use only one byte

## C characters
in C, **single** quotes (`'`) are used to indicated an ASCII character.         
For example, `a` is equivalent to 97 and `z` is 122.        
In C, there is **no difference** between the two variables.         
```C
char letter_a = 'a'; 
char ninety_seven = 97; 

printf("%c \n", ninety_seven)  // prints a
printf("%d \n", letter_a)      // prints 97
```

## Character arithmetic 
Because C interprets characters as integers, characters can be used in expressions to avoid having "magic numbers" in your code. 
```C
bool is_lowercase(char c) {
    return (c >= 'a') && (c <= 'z'); 
}

char to_lowercase(char c) {
    if ((c >= 'A') && (c <= 'Z')) {
        return c - 'A' + 'a';
    } else {
        return c; 
    }
}

char to_uppercase(char c) {
    if((c >= 'a') && (c <= 'z')) { 
        return c - 'a' + 'A';
    } else {
        return c; 
    }
}
```

## read_char()
the same as `read_int()` but for `char`
## Symbol type
C **symbols** are constants (often `int`) which are usually defined in all caps
```C
const int UP = 1; 
```

## Floating point types
The C `float` can represent real (non-integer) values. 
```C
float pi = 3.14159;
float avogadro = 6.022e23; 
```

```C
float penny = 0.01; 
float money = 0; 
for (int i = 0; i < 100; ++i) { 
    money += penny; 
}
// value of money is 0.999999
```

In C, a float is 8 bytes, one **byte** is for the exponent ($-127 \cdots 128$), one **bit** is for the sign, leaving 23 **bits**, so the precision is $2^{32}$

## Structures
Structures (compound data) in C are similar to structures in Racket. 
```C
struct posn {       // name of the structure
    int x;          // type and field names
    int y; 
};                  // don't forget this ; 
```

the structure *type* includes the keyword "`struct`". For the example aboce the *type* is `struct posn` not just `posn`.        

```C
struct posn p = {3, 4};      // note the use of {}
trace_int(p.x); 
```
-  instead of *selector* function C, has **selector operators** (`.`)

## Mutating with structures
```C
struct posn p = {1, 2}; 
struct posn q = {3, 4}; 

p = q;      
// p = {3, 4}
p.x = 23; 
// p = {23, 4}
```

The braces are part of the initialization syntax and can not be used in assignment. 
```C
struct posn p = {1, 2}; 
p = {3, 4};             // INVALID
p.x = 3;                // VALID
p.y = 4;                
```

The equality operator (==) does not work with `struct`

## Structures in the memory model 
For a structure definition, no memory is reserved: 
```C
struct posn {
    int x; 
    int y; 
};
```
Memory is only reserved when a   **variable** is defined:
```C
struct posn p = {3, 4};
```

# <p style="text-align: center;"> 30/1/20 </p>
## Sizeof a struct
```C
struct mystruct {
    int x;      // 4 bytes
    char c;     // 1 byte
    int y;      // 4 bytes
};
```
the amount of space reserved for a `struct` is **at least** the sum of the `sizeof` each field, but it may be larger. 
- this is because the order of each field matters
  - so if u have an `int` following a `char`, C will space the first `char` with the same size as an `int`
    - this is because the compiler wants to have each integer at an address that is a multiple of 4 for performance optimization
```C
trace_int(sizeof(struct mystruct)); 
// sizeof(struct mystruct) => 12
```
- Because it may be larger than each field, you **must** use sizeof to determine the `sizeof` a struct


## Sections of memory
In this course we model five **sections** ("regions") of memory. 
|Sections|
|---|
|Code|
|Read-only data|
|Global data|
|Heap|
|Stack|
- each of these is called a **segment**
  - if a program tries to access something in a segment it cannot access, you get a **segmentation fault**
- other courses may use alternative names

## Temporary results
When evaluating C expressions, the intermediate results must be temporarily stored. 
```C
a = f(3) + g(4) - 5; 
```
- in this example, C must temporarily store the value returned from `f(3)` and `g(4)`

## The code section
When you program you write **source code** in a text editor using ASCII characters      
To "run" a C program, the *source code* must be converted into **machine code** that is machine readable        
This machine code is then placed into the **code section** of memory
> converting source code into machine code is known as **compiling**

## The read-only & global data sections
Earlier we described how C reserves space in memory for a variable definition              
All global variables are placed either in the global variables section or the read only section

## The return address 
When we encounter a `return`, we need to know: "what was the address we were at right before this function was called?"
- This location is known as the **return address**
- This address is stored in the stack
  
In this course, we use the name of the calling function and a line number (or an arrow) to represent the return address

## The call stack 
The "history" of function calls (say function f,g,h are called in main) are stored in the **call stack**
- each time a function is called it is pushed to the stack
- each time a function returns it is popped from the stack


## Stack frames
"entries" pushed onto the call stack are known as **stack frames**      
Each function call creates a stack fram ("fram of reference")       
Each stack frame contains: 
- the **argument values**
- all **local variables** (both mutable variables and constants) that appear within the function block 
- the return **address**

C makes a copy of each argument value and places the copy in the stack frame
- this is known as "pass by value" convention

Although space is reserved for global variables before the program is executed, space for local variables is only reserved **when the function is called** 
- the space is reserved within the newly created stack frame

Example stack frame:

```C
int h(int i) {
    int r = 10 * i; 
    return r; 
}
int g(int y) {
    int c = y * y; 
    return c; 
}
int f(int x) {
  int b = 2*x + 1;
  int d = g(b + 3) + h(b);
  return d;
}   
int main(void) {            
  int a = f(2);
  //...
}

// Stack frame
=========================
g:
  y: 8
  c: 64
  return address: f:13
=========================
f:
  x: 2
  b: 5
  d: ???
  return address: main:18
=========================
main:
a: ???
  return address: OS
=========================
```

## Calling a function
We can now model all of the **control flow** when a function is called: 
- a *stack frame* is created ("pushed" onto the stack)
- a **copy** of each of the arguments is placed in the stack frame
- the current program location is placed in the stack frame as the return address 
- program location is changed to the start of the new function
- initial values of local variables are set when their definition is encountered

## return 
When a function `return`s: 
- the current program location is changed back to the return address 
- the stack frame is removed ("popped" from the Stack memory area)

## Recursion in C
In C, each recursive call is simply a new *stack frame* with a separate frame of reference. The only unusual aspect of recursion is that the return address is a location within the same function. 

## Stack section
The *call stack* is stored in the **stack section**, the fourth section of our memory model. We refer to this section as the "the stack".       
The "bottom" of the stack (where the `main` stack frame is placed) is placed at the **highest** available memory address. Each additional stack frame is then placed at increasingly lower address. The stack "grows" toward lower address.
- If the stack grows too large, it can "collide" with other sections of memory. This is called "stack overflow" and can occur with very deep (or infinite) recursion. 

## Uninitialized memory
**Global** variables are initialized with a value of 0 in C, local variables are initialized with a random value. 
```C
void mystery(void) {
    int k;
    printf("the value of k is: %d\n", k);
  }
```
- the value of k will likely be a leftover value from a previous stack frame

## Memory snapshot 
You may be asked to draw a memory diagram (including the call stack) at a particular moment in the code execution.
- make sure you show any variables in the **global** and **read-only** sections, separate from the stack
- include all local variables in stack frames, including definitions that have not yet been reached (or are incomplete)
- local variables not yet fully initialized have a value of ???
- you do not have to show any temporary storage
(e.g., intermediate results of an expression)

When a variable is defined inside of a loop, only one occurrence of the variable is placed in the stack frame. The same variable is re-used for each iteration.         
Each time the definition is reached in the loop, the variable is re-initialized (it does not retain its value from the previous iteration)

## Goals of this section
At the end of this section 
- ...

# <p style="text-align: center;"> 4/2/20 </p>
## Introduction to Pointers in C 
## Address operator
C was designed to give programmers "low-level" access to memory and **expose** the underlying memory model. 

The **address operator** (`&`) produces the **location** of an identifier in memory (the **starting address** of where its value is stored)
```C
int g = 42; 
int main(void) {
    printf("the value of g is: %d\n", g); 
    printf("the address of g is: %p\n", &g);
}
// the value of g is: 42
// the address of g is: 0x71a0a0
```

- The printf format specifier to display an address (in hex) is "`%p`"

## Pointers
In C, there is also a *type* for **storing an address**: a **pointer**

a pointer is defined by placing a (`*`) before the identifier (name). The `*` is part of the definition syntax, not the identifier itself. 
```C
int g = 32; 
int i = 42; 
int *p = &g;    // p "points at" i
p = &i; 
//  i => 42
// &i => 0xf020
//  p => 0xf020
// &p => oxf024

```
- when u call `p` you do not use the `*` that is just part of the definition not the identifier name
  
The type of `p` is an "int pointer" which is written as "`int *`". 

For each type (e.g, `int`, `char`) there is a corresponding pointer type (e.g, `int *`, `char *`)

When drawing a *memory* diagram, we rarely care about the value of the address, and visualize a pointer with an arrow (that "points")

## sizeof a pointer
Int most *k*-bit systems, memory address are *k* bits long, so pointers require *k* bits yo store an address

## Indirection operator
The **indirection operator** (`*`), also known as the *deference operator*, is the **inverse** of the address operator (`&`). 
- *p produces the **value** of what pointer p "points at" 
```C
int i = 42; 
int *p = &i; 
//  p => 0xf020
// *p => 42
```

## Pointers to pointers
"Can a pointer point at itself?"
```C
int *p = &p;    // pointer p points at p ???
```
- this is actually a **type error**
  - p is defined as (`int *`), a pointer to an `int`, but
  - the type of &p is (`int **`), a pointer to a pointer to an `int`

In C, we can define a **pointer to a pointer**: 
```C 
int i = 42; 
int *p1 = &i;          // pointer p1 points at i
int **p2 == &p1;       // pointer p2 points at p1
```
- `**p * **p` is a confusing but valid C expression

> A `void` pointer (`void *`) can point at anything, including a `void` pointer (itself)

## Dereferencing pointers to structures
The structure operator (.) has higher precedence than the indirection operator (`*`)

Awkward parenthesis are required to access a field of a pointer to a structure
```C
(*ptr).field
```
Fortunately, the **indirection selection operator**, also known as the "arrow" operator (`->`) combines the indirection and the selection operators.

`ptr->field` is equivalent to `(*ptr).field`

## The NULL pointer
`NULL` is a special pointer **value** to represent that the pointer points to "nothing" 

If the value of a pointer is *unknown* at the time of definition, or what the pointer points at becimes *invalid*, it's good style to assign the value of NULL to the pointer. A pointer with a value of NULL is often known as a "NULL pointer"
- NULL is considered "false" when used in a Boolean context

The following two are equivalent: 
```C
if (p) ... 
if (p != NULL)
```
- If you try to dereference a NULL pointer, your program **will crash**
```C
p = NULL; 
i = *p;        // crash!
```

## Pointer assignment 
```C
int i = 5; 
int j = 6; 

int *p = &i; 
int *q = &j; 

p = q; 
```
- this does not change the value of i or j, it just makes p point to j
  
This is an example of **aliasing**, which is when the same memory address can be accessed from more than one variable 
# <p style="text-align: center;"> 6/2/20 </p>
## Mutation and parameters
Pass by value:  
**copy** of an argument is passed to a function, so the function cannot change the original value. The alternative to this is "pass by reference"

In C, we can emulate "pass by reference" by passing the address of a variable. 
- This is still actually "pass by value" because we pass the **value** of the address. It is not the same as when languages pass by reference. 

It is also common to say pass a pointer
```C 
void inc(int *p) {
  *p += 1;
}
int main(void) {
  int x = 5;
  trace_int(x);
  inc(&x);              // note the &
  trace_int(x);
}
```
Most pointer parameters should be **required** to be valid (e.g., non-`NULL`)
```C
// inc(p) increments the value of *p
// effects:  modifies *p
// requires: p is a valid pointer
void inc(int *p) {
    *p += 1;
}
```
- note that instead of `*p += 1;` we could have written `(*p)++;` The parenthesis are needed because `++` has higher priority than `*`

### Documenting the side effect
We now have a fourth effect that a function may have: 
- produce output 
- read input 
- mutate a global variable 
- **mutate a variable through a pointer parameter**
```C
//  effects: modifies *px and *py
    void swap(int *px, int *py) {
      int temp = *px;
      *px = *py;
      *py = temp;
}
```

## C input: scanf
`scanf` requires a **pointer** to a variable to store the value read from input.            
Just like `printf`, `scanf` can be used to read in more than one value
- **However in this course you may only read one value per `scanf`**

## scanf return value
The **return value** of `scanf` is an `int`, and either: 
- The quantity of values successfully read  
  - 0 if the input is not formatted properly
- The constant `EOF`: **E**nd **O**f **F**ile has been reached

## Invalid input 
- If you follow the course's advice, scanf will return 1 if the input is valid
```C
retval = scanf("%d", &i); // read in an integer, store it in i
if (retval != 1) {
    printf("Fail! I could not read in an integer!\n");
}
```

## Whitespace
```C    
// reads in next character (may be whitespace character)
count = scanf("%c", &c);

// reads in next character, ignoring whitespace
count = scanf(" %c", &c);

// This is better
count = scanf("\n%c", &c);
```
- The space in the second example indicated that leading white space is ignored
  - It ignores all leading white spaces
  - It also ignores any white space characters such as `\n`
- You can write a `\n` instead of the leading white space to have more contrast in your code

## Using pointers to return multiple values
Functions in C can only have one return value, we can use pointers to emulate returning more than one value.

```C
void divide(int num, int denom, int *quot, int *rem) {
    *quot = num / denom;
    *rem  = num % denom;
}
```
- This function "returns" both the quotient and remainder

This multiple return is also useful for when a function could encounter an error. 

```C
bool divide(int num, int denom, int *quot, int *rem) {
    if (denom == 0) return true;
    *quot = num / denom;
    *rem  = num % denom;
    return false;
  }
```
- returns true if successful
- false if not
  
## Returning an address 
A function must **never** return an address within its stack fram. 
```C
int *bad_idea(int n) { 
    return &n;    // Never do this
}

int *bad_idea2(int n) {
  int a = n*n;
  return &a;
}
```

## Passing structures
When a function is called, a **copy** of each argument value is placed into the stack frame. 

For structures, the *entire* structure is copied into the stack frame. For large structures, this can be quite inefficient. 

To avoid structure copying, it is common to pass the address of a structure to a function

```C
// sqr_dist(p1, p2) calculates the square of
  //   the distance between p1 and p2
  int sqr_dist(struct posn *p1, struct posn *p2) {
    int xdist = p1->x - p2->x;
    int ydist = p1->y - p2->y;
    return xdist * xdist + ydist * ydist;
}
```

passing the address of a structure allows the function to mutate the fields of the structure. 
```C
// scale(p, f) scales the posn p by f
  // requires: p is not null
  // effects:  modifies p
  void scale(struct posn *p, int f) {
    p->x *= f;
    p->y *= f;
}
```

## Const pointers
Adding the `const` keyword to a pointer definition prevents the pointer’s destination from being mutated through the pointer.

```C
void cannot_change(const struct posn *p) {
    p->x = 5;   // INVALID
}
```
Place `const` **before** the type
- it is **good style** to add `const` to a pointer parameter to communicate that the destination does not change

## Const parameters
```C
void can_change(struct posn *p) {
    p->x = 5;   // VALID
}
  void cannot_change(const struct posn *p) {
    p->x = 5;   // INVALID
}
```
Const parameters could be used with simple variables as well 
```C
int my_function(const int x) {
    // mutation of x here is invalid
    // ...
}
```
It does not matter if the original argument is a constant because
- A `const` parameter communicates (and enforces) that **the copy** of the argument will not be mutated.

## Minimizing mutative side effects
Your preference for function design should be: 
  1. **“Pure” function**
   - No side effects or dependencies on global mutable variables.
1. **Only I/O side effects**
   - If possible, avoid any mutative side effects.
2. **Mutate data through pointer parameters**
   - If mutation is necessary, use a pointer parameter.
3. **Global dependencies**
   - Mutable global variables should be avoided.
4. **Mutate global data**
   - Only when absolutely necessary (it rarely is)

## Function pointers
In Racket, functions are first-class values.

For example, Racket functions are values that can be stored in variables and data structures, passed as arguments and returned by functions.

In C, functions are not first-class values, but **function pointers** are.

A significant difference is that **new** Racket functions can be created during program execution, while in C they cannot.
 - **a function pointer can only point to a function that already exists**
  
The function pointer stores the starting address a function in code section of memory. 

The type of a function pointer includes the return type and all of the parameter types, which makes the syntax a little messy.
```C
return_type (*fpname)(param1_type, param2_type, ...)
 ```
 - you are not expect to remember the syntax for defining a pointer function for the exam

 **Example:**
 ```C
 int my_add(int x, int y) {
   return x + y;
}
 int my_sub(int x, int y) {
   return x - y;
}
 int main(void) {
   int (*fp)(int, int) = NULL;
   fp = my_add;
   trace_int(fp(7, 3));
   fp = my_sub;
   trace_int(fp(7, 3));
}
// fp(7, 3) => 10
// fp(7, 3) => 4
```
# <p style="text-align: center;"> 30/1/20 </p>
# <p style="text-align: center;"> 30/1/20 </p>
# <p style="text-align: center;"> 30/1/20 </p>
# <p style="text-align: center;"> 30/1/20 </p>
