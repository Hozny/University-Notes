# CS 136
Elementary Algorithm Design and Data Abstraction
``` 
Instructor: Navid Esfahani
Section: 10 / Tuesday/Thursday (4:00-5:20 or 2:30-3:50)
Email: nnasresf@uwaterloo.ca
Website: http://www.student.cs.uwaterloo.ca/~cs136/
Office: DC 2127
Office Hours: Thursday 8:30 - 10:30 am 
Lab Hours: MC 3004 / (12-5 pm on Fridays)
Textbook: Course Notes
Midterm: 
Final:
```
# <p style="text-align: center;"> 7/1/20 </p>
**Main topics & themes:**
- Imperative programming style
- Elementary data structures & abstract data types
- Modularization
- Memory management & state
- Introduction to algorithm design & efficiency 
- Designing "medium" sized, "real world" programs with I/O


**Programming environment (Seashell)**  
customized "Seashell" development environment.
- browser-based for platform independence 
- Works with both C and Racket
- Integrates with our submission & testing environment 
- Helps to facilitate your own testing
  - Need to use vpn to connect (must be on university network)

**Course Materials**    
*Textbooks*
- "C Programming: A Modern Approach" (CP:AMA) by K. N. King. 
- "How to Design Programs" (HtDP) by Felleisen, Flatt Findler, Krishnamurthi        
  
*Course notes*  
- available on website
> Go to tutorials to learn 

**Marking scheme**
- 20% assignments (roughly weekly)
- 5% participation
- 25% midterm 
- 50% final
  - must pass both the assignment component and weighted exam component

participation grading
- 2 marks for a correct answer, 1 for a wrong answer
- Your best 75% of responses are used to calculate your 5%
  - if u get every 3 of 4 right you get 100%
- each tutorial u attend will increase your 5% participation grade 0.1% (up to 1.2%, cannot exceed 5%)

**Assignments:**     
- assignment deadlines are strict, but some assignment questions may be granted a "second chance"
- Most questions are marked with highest score submission
- Hand-marked questions use the closest to the deadline with the highest score
- Assignments can be submitted using Seashell

**Documentation:**
- a **purpose** statement, 
- a **contract** (including a requires section if necessary)
- unless otherwise stated you don't need templates, data definitions or examples: 

# <p style="text-align: center;"> 9/1/20 </p>
**C** was developed by Dennis Ritchie in 1969-1973 to make the Unix operating system more portable. 
- Named "C" because it was successor to "B", which was a smaller version of BCPL. 
- C was designed to give programmers low-level access to memory and to be easily translatable into "machine code". 
- Thousands of popular programs and portions of **all** popular operating systems are written in C.

**C versions** There a few different versions of the C standard. In this course, we use C99 (from 1999). 
- The C11 standard added some new features to the language. 
- The C18 standard only fixes a few bugs from C11
- C2x standard is currently in development. 

## C  Syntax Intro 
**Comments** any text on a line **after** `// is a comment`. Any text between `/* and */` is also a comment.    
**Note:** C's multi-line comment cannot be "nested":
```C
/* this /* nested comment is an */ error */
```

**Expressions:** C expressions use traditional *infix* algebraic notation (ex: 3 + 3)   
1 + 3 * 2 $\implies$ 7  
(1 + 3) * 2 $\implies$ 8
- Because C uses infix notation, parenthesis are needed to specify **order of operations**. This is not needed with prefix (or postfix) notation. 

**Operators:** In addition to the traditional mathematical *operators*, c also has *non-mathematical* operators. With over 40 operators in total (CP:AMA Appendix A).
- C does not have an exponentiation operator ($x^n$)
- ```C 
  4 * 5 / 2 = (4 * 5) /2
  ```
**The / operator**
- When working with integers, the C division operator truncates (rounds toward zero) and intermediate values. Note that rounding toward zero is equivalent to "removing" the decimals. 
- ```C 
  4 / 5 = 0
  ```

**The % operator:** the C **modulo** operator produces the **remainder** after integer division     
The value of `(a % b)` is equal to `a - (a / b) * b`
- **Note:** `(i % j)` has the same sign as `i`
  - So `-10 % 3 = -1` instead of the expected `2` 
    - a fix would be `((i % j) + j) % j`, this is especially useful when working with array indices

**C identifiers:** Ever function, variable, and structure requires an *identifier* (or "name"). 
- C identifiers must start with a letter, and can only contain letters, underscores, and numbers. 
- In this course we use `underscore_style` (or snake case). Words are separated by underscores and all letters are lowercase.
  - `underscore_style` is the most popular style for C projects. In other languages (Java) `camelCaseStyle` is popular. 
  - C identifiers can start with a leading underscore (`_name`) but they may interfere with reserved keywords. Avoid using leading underscores in this course. 

**Anatomy of a function definition**
```C
int my_add(int a, int b) {
    return a + b; 
}
```
- braces ({}) indicate the beginning/end of a function **block**
- `return` keyword, followed by an expression, followed by a `;`
- parameters `(a,b)` are separated by a comma
- the function and parameter **types** are specified (in this case, `int`)
- **Note:** the placement of braces and use of whitespace. 
  
**Static typing system:** C uses a *static type system:* all types **must** be known **before** the program is run and the type of an identifier **cannot change**.
- Racket uses a **dynamic** type system

If the type in a function definition is missing C assumes it to be an `int`: 
```C
int my_add(int a, int b) { //Proper
    return a + b; 
}

my_add(a , b){ 
    return a + b; 
}
```
- "type" runtime errors do not exists in C as the program will **never** compile if there is a type error. 

**Function terminology:** We **call** a function by **passing** it **arguments**, a function **returns** a value. 
- In "functional" language terminal we **apply** 

## **Functions without parameters:** 
use the `void` keyword to indicate a function has no parameters. 
```C
int my_num(void) {
    return my_add(40,2);
}
```
- To call a parameterless function, put nothing between the parentheses. 

C allows the omission of `void` which indicates an "unknown" or "arbitrary" number of parameters (beyond the scope of this course). **Always use** `void`.
- When writing programs, do not write programs which do what you intend, rather write programs which are not able to do anything except for what is intended. 

**No nested function:** In C we are not able to define nested functions. This feature was added to the GNU C compiler but is not found in C Standard. 

```C
int top(void) {
    int nested_func(void) {
        //...
        // This is not possible
    }
}
```

## **Function Documentations**

**Whitespaces** C mostly ignores whitespace. 
```C
// The following three functions are equivalent

int my_add(int a, int b) {  //Good
    return a + b; 
}
int my_add(int a, int b) { return a + b; //Bad
}

int my_add(int a, int //Very bad
b){return a+
b ; }
```

**CS 136 style:**
```C
int my_add(int a, int b) {  //Good
    return a + b; 
}
```
- a block start (open brace {) appears at the end of a line
- a block end (close brace }) is aligned with the line that started it, and appears on a line by itself
- indent a block 2 (recommended), 3 or 4 spaces: **be consistent**
- add a space after commas and around arithmetic operators


```C 
int my_super_long_function(int a, int b, int c, int d, 
                           int e, int f, int g) {
    return a * b + b * c + c * d + d * e + d + d * e
           d + e; 
}
```
- align code when lines are too long

**Entry point:** Typically a program is run by an Operating System (OS) through a shell or another program such as DrRacket. The SO needs to know where to **start** running the code. 

**main:** main has no parameters (for now) and `int` return type. 
```C
int main(void) {
    //...
    return 0;
}
```
- The `return` value communicates to the OS the "error code" also know as "exit code", "error number" or `errno`
- A successful program `returns` **zero** (no error code). 
# <p style="text-align: center;"> 14/1/20 </p>
**Top level expressions:** In C, *top-level expressions* (code outside of a function) are **not** allowed. 
- Code only execute **inside** of a function
```C
1 + 1; // INVALID
int my_add(int a, int b){
    return a + b; 
}
```

**Tracing expressions:** Seashell provides *tracing tools* to help you "see" what your code is doing. `trace_int` is a function that allows you trace integers. 

```C
int main(void){
    trace_int(1 + 1); 
    trace_int(my_add(1,2)); 
}
```

## Running our first program
```C
// First C program (documentation omitted)

#include "cs136.h"  // <-- More on this later

int my_add(int a, int b){
    return a + b; 
}

int main(void){
    trace_int(1+1);
    trace_int(my_add(1,2));
    return 0; 
}
```
- For now, include "cs136.h" for all programs

## **Function ordering:**
- For now, always place function definitions **above** any other functions that reference them (so `main` is at the bottom). 
  - There are ways to bypass this, but we will explore that later

## **Program documentation:**
- Document a program (state its purpose) at the **top** of the file (not necessarily where `main` is).

## **Testing:**
- *tracing tools* are an excellent way for you to "see" what is happening
  - They are helpful to *informally* test code
  - They are not ways to *thoroughly* test code

## **Boolean expressions:**
- In C, boolean expressions do not produces "true" or "false", they produce either:
  - Zero (`0`) for "false"
  - one (`1`) for "true"

## **Comparison operators:**   
The *equality* **operator** in C is `==` (not the **double** equals)  
(3 == 3) $\Rightarrow$ 1 (true)     
(2 == 3) $\Rightarrow$ 0 (false)     
The *not equal* **operator** is `!=`  
(2 != 3) $\Rightarrow$ 1 (true) 

The operators <, <=, > and >= behave exactly as expected. 
- The accidental use of a single `=` instead of a double `==` for equality is one of the most common programming mistakes in C. This can be a serious bug. 

## **Logical Operators:**
The logical operators are ! (not), && (and), || (or):

Similarly to Racket, C *short-circuits* and stops evaluating logical operators as soon as possible. 

**All non-zero values are true:**
- operators that produce a Boolean value will always produce `0` or `1`
- Operators that expect a Boolean value will consider **any non-zero value** to be **"true"**
  - **Only zero (0) is "false"**
    - The value `NULL` is also considered false. but in most implementations is evaluated as `0` anyway. 

Operator|Symbol
---|---
Negations| `!`
multiplicative | `* / %`
additive |`+ - `
comparison | `< <= >= >`
equality | `== !=`
and | `&&`
or| `||`

## **Bool type**
The ` bool` type is an integer that can only have a value `0` or `1`. 
```C
bool is_even(int n) {
    return (n % 2) == 0;
}
bool my_negate(bool v) {
    return !v; 
}
```
- You can technically add integers to booleans, but just because you can doesn't mean you should

## **Assertion**
use the `assert` function to test functions: 
```C
assert(my_add(1,2) == 3); 
```
`assert(exp)` **stops** the program and displays a message if the expression `exp` is false (zero). 

if exp is true (non-zero), it does "nothing" and continues to the next line of code. 
- assert is very similar to Racket's `check-expect`: 

```C
// My second C program (now with better testing!)

#include "cs136.h"

int my_add(int a, int b) {
    return a + b; 
}

int main(void){
    assert(my_add(1,2)==3);
    assert(my_add(2,2)==4);
}
```

## **Function requirements**
The `assert` function is also very useful for **verifying function requirements**. 
```C
// my_divide(x, y) ...
// requires: y is not 0 

int my_divide(int x, int y) {
    assert(y!=0);
    return x/y; 
}
```
## **Infeasible requirements**
Some requirements are *infeasible* to assert, or they would be *inefficient* to assert.         
It is good style to communicate that a requirement is not asserted 
```C
// some function ... 
// requires: n is a prime number [not asserted]
```

## **Multiple requirements**
With multiple requirements, it is better to have several small `assert`s. It makes it easier to determine which assertion failed. 
```C
// 
int my_function (int x, int y, int z) {
    assert((x > 0) && (y < z)); 
}
```
## **Statements**
Blocks (`{}`) can contain multiple *statements:*
```C
int my_divide(int x , in y) {
    assert(y)      // statement
    trace_int(y)   // statement
    return x / y;  // statement
    trace_int(x);  // unreachable statement
}
```
Statements are executed *in* sequence (on after the other).         
The `return` statement **ends** the function. In the above code, `trace_int(x)` will never run. 

## **Brief introduction to control flow**
The `return` statement is a special kind of statement known as a *control flow* statement.       
`return` "controls the flow" of the program by ending the function and returning to the caller.         

## **Conditionals**
The `if` control flow statement allows us to have functions with conditional behaviour. 
```C
int my_abs(int n) {
    if (n < 0) { // note: the () are required
        return -n; 
    } else {     // In CS136 they have else on the same line on the closing }
        return n; 
    }
}
```
- There can be more than one `return` in a function, but only one can ever execute. 

## **else if**
if there are more than wo possible results, use `else if`
```C
// in_between(x, lo, hi) determines if lo <= x <= hi
// requires: lo <= hi

bool in_between(int x, int lo, int hi) { 
    assert(lo<=hi); 
    if (x < lo) {
        return false;
    } else if (x > hi) {
        return false;
    } else {
        return true; 
    }
}
```

**The C ternary conditional operator** (`?:`)
```C
q ? a : b
```
- `a` if `q` is `true`, `b` if `q` is `false`
```C
(v >= 0) ? v : -v;      // abs(v)
(a > b) a : b;          // max(a, b)
```

Goals of this section
- Demonstrate the use of C syntax and terminology
- Write a simple function in C
- Use the C operators introduced in this module
- Explain the significance of the `main` function in C
- Perform basic tracing in C using `trace_int`
- Use assert for testing and to verify requirements
- Provide the required documentation for C functions

## **Introduction to imperative C**
Readings: CP:AMA

## **Functional programming**
- functions are "pure" (a.k.a "mathematical")
  - functions **only return values**
  - return values **only depend** on argument values
- only **constants** are used       

In the imperative programming paradigm functions may be "**impure**" and will **use variables**

## **Compound statement**
In imperative programming, a **sequence of instructions** (or "statements") are executed. We have already seen this: 
```C
int main(void) { 
    trace_int(1+1); 
    assert(3 > 2); 
    return 0; 
}
```
A block `{}` is formally known as a *compound statement*, which is simple a **sequence of statements** to be executed in order
- blocks can contain local variable definitions

## **I/O** (input/output)
- in this course we use simple **text-based** I/O. 

## **Text I/O**
To displace text output in C, we use the `printf` function. 
```C 
// My first program with I/O
#include "cs136.h"

int main(void) {
    printf("Hello, World"); 
}
```

# <p style="text-align: center;"> 16/1/20 </p>
## **Text I/O ...**
The **newline** character (`\n`) is necessary to properly format output to appear on multiple lines
- by default `printf` does not print a new line each time

To output values, use a **format specifier** (the **f** in print**f**). 
- For an integer in "**d**ecimal format the format specifier is `%d`

```C
printf("2 + 2 is %d",2+2);
printf("%d + %d is: %d\n",2,2,2+2);
// 2 + 2 is: 4
```

If you would like to print a percent sign (%), use two (%%). 
```C
printf("I am %d%% sure you should watch your",100);
// I am 100% sure you should watch your
printf("spacing!\n");
```
Similarly, 
- to print a backslash (`\`) use two (`\\`)
- To print a quote add a backslash (`\"`)

## Side effects and state (introduction)
In general, a programming side effect is when the **state** of something "changes".         
State refers to the value of some data (or "information") **at a moment in time**.
- You have a blank piece of paper, then you write your name on that paper. 
  - You have changed the state of that paper: at one moment it was blank, and in the next it was "autographed"
  - The side effect of writing your name was that you changed the state of the paper

## Documenting side effects
The `printf` function has a side effect: it changes the output or "display"

```C
// noisy_abs(n) computes |n|
// effects: may produce output

int noise_abs(int n) {
    if (n < 0) {
        printf("Yo! I'm changing the sign!\n");
        return -n;
    } else {
        return n; 
    }
}
```
In this course there is no need to provide any detail in the "effects" section `// effects: produces output` is sufficient. 
- occasionally you want to describe the output in the purpose if the output is important in understanding the core behaviour of the function

## Debugging tools
Statement used for debugging and informal testing (assert, trace_int) are **not** considered side effects. 

## I/O terminology 
In the context I/O, be careful with eerminoloy. 
```C
int sqr(int n) {
    return n * n; 
}

int noise_sqr(int n) {
    printf("Yo! I'm squaring %d!\n",n);
    return n * n; 
}
```
- informally, someone might say: if you **input** `7` into `sqr`, it **outputs** `49`
  - We say if `7` is **passed** into `sqr` it **returns** `49`
  - if `7` is **passed** into `noisy_sqr` it **outputs** a message and **returns** `49`.
>Our tracing tools print to a different output **stream** than `printf` (like writing on two different pieces of paper). By default `printf` outputs to `stdout` (**st**andard **out**put stream). Our tracing tools print to `stderr` (**st**andard **err**or stream). 

## Void functions
```C
// Display score: produces score
// Effects produces output
void display_score(int score, int max) { 
    printf("your score is %d out of %d.\n", score, max)
}
```
- In a void function, the return is optional and has no expression. 

## Expression statements
An **expression statement** is an expression with a semicolon (`;`)
```C
int main(void) { 
    11;
    10 + 1; 
    sqr(6) - sqr(5); 
    printf("expression\n");
    printf("five\n")+6;
}
```
- The **value** of an expression statement is **discarded** after it is executed. 
  - The purpose of an expression statement is to generate **side effects**
    - In the example above the `printf` statements produce an output side effect
    - but `11;` produces no side effect which can result in a warning by some compilers but the program still runs

## Return value of `printf`
Surprisingly `printf` is not a `void` function it (`return`s an `int`)
- `printf` returns the number of characters that were printed
  
## Statements
- **Compound statements (blocks)**
  - a sequence of statements (to be executed in order)
- **Expression statements**
  - for generating side effects (values are discarded)
- **Control flow statement**
  - control the order in which other statements are executed

## Variables
**Variables** store values
To define a variable in C, we need (in order):
- the **type** (`int`)
- the **identifier** ("name")
- the **initial value**
```C
int my_variable = 7; // definition
```
Definitions **are not** statements. 

## Mutation
When the value of a variable is changed, it is known as **mutation**
```C 
int main(void) {
    int m = 5; 
    trace_int(m);   // definition (with initialization)
    m = 6; 
    trace_int(m);   // mutation!
    m = -1; 
    trace_int(m);   // more mutation!
}
```
Mutation is a **side effect**

## Assignment operator
In C, mutation is achieved with the **assignment operator** (`=`)
```C
m = m + 1; 
```
- The "right hand side" RHS must be an *expression* that produces a **value** with the same type as     LHS. 
- The LHS **must** be the name of a variable
- The LHS variable is mutated to store the **value** of the RHS
- This is a side effect 
  - **Note** assignment evaluates to the RHS so `if(n=1)` passes

**Pro tip:** some defensive programmers get in the habit of writing equalities as `(13 == i)` this makes it so that if one equals is missed it produces an error rather than being a bug. 

## Initialization 
C allows a variable definition without initialization, but is bad style. 
```C
int my_variable = 7;    // initialized
int another_variable;   // uninitialized
```
- Always initialize variables

## Initialization is not assignment
- The `=` use in initialization is **not** the assignment operator. 
``` C
int n = 5;  // initialization syntax
n = 6;  // assignment operator 
```
- This matters more later on in object oriented programming where assignment is more apparently different than initialization

## More assignment operators 
```C
 x += 2;    // x = x + 2; 
 ++x;   x++; // x += 1;   
```
- the prefix (`++x`) and postfix (`x++`) both increment by `1`
  - `x++` produces the "old" value of `x` then increments by `1`
  - `++x` increments `x` then produces the "new" value of `x` 
- prefix (`++x`) is usually preferred to improve clarity and efficiency