# CS 246 - Object Oriented Software Development | Fall 2020

# Linux File Permissions 

Permission information: d rwx r-x ---
- first character: `d` if directory, `-` if file
- next three are read (`r`), write (`w`), executable (`x`)
- first three are user, next three are group, next three are other (everyone)

## chgrp - change group

Changes group-name associated with a file

Usage: `chgrp [-R] group-name file/directory-list`

## chmod - change permissions

Changes permissions of a file

Usage: `chmod [-R] mode-list file/directory-list`
- `mode-list` has the form : `security-level operator permission`
- securty-level is: user (`u`), group (`g`), other (`o`), all (`a`)
- Operator `+` adds permission, `-` removes permission, `=` sets permission

Example: `chmod go-rw foo`, `chmod a+r schedule.html`, `chmod g=rw test.txt`

**Note:** if you `chmod` using binary numbers you can switch the permissions based on the binary representation of each of those bits
- chmod `712` -> `111 001 010` -> `rwz --x -w-`

# The File System 
**path:** is the general name of a file or directory in textual format

Note: directories in linux are just a specialized form of file
- they can be edited but it is dangerous to do so 

## Absolute and relative paths
`/` is the **root** directory

`.` is the current directory, `..` is the previous directory

## Changing the current directory
`cd` to change directory        
`pwd` to display path of working directory      

## The home directory
Each new user is given their own **home directory**
- this is a directory owned by the user where they can place their personal files without disturbing other users

when writing a pathname, the shell replaces the special character `~` with the absolute path of your home directory.        

## The $PATH variable
When the name of a file is given without a path then the shell looks in locations defined global system variable named `$PATH`      
The contents of the `$PATH` variable are a list of pathnames separated by the colon character (:)
```
$ echo $PATH
/home/bob/bin:/user/local/bin:/usr/bin
```

you can run a program by giving its path to the shell           

you can add to the $PATH variable by (this doesn't affect existing PATH values):
```
export PATH=$PATH:/location/program
```

# The shell


A **shell** is a program that runs and gives an interface to communicate with the opreating system 

In most linux distributions, a program called bash acts as the shell

SSH (Secure SHell) connection allows us to user the shell on another computer through the internet. 

**Standard input:** `stdin` is a device where from the shell is reading text input              
**Standard output:** `stdout` is a device where the shell is writing text output        
**Standard error:** `stderr` is a device where the shell writes error messages to            

## The command `ls`
The command `ls -l` displays a long form of the list with the following information:            
- **type:** `-` for a file, `d` for directory
- **permissions:** three groups of three bits
    - 3 for user, 3 for group, 3 for other
- **owner:** the ID of the user that owns the file
- **group:** a user can belong to one or more group
- **size:** size of the file in bytes
- **modified:** the date and time it was last modified
- **name:** the file name


## Executing commands

`bash` can run in an interactive (user provides commands) or non-interactive mode (a script file)

## The command prompt
command prompt is what the shell displays in interactive mode when it is waiting for user input

### Types of commands
**Scripts:** are text files that contain commands in a specific programming language. 
- interpreters interpret and execute the commands

**Programs:** are files that contain commands in binary format. They can be understood the operating system not by a human                  
and can be run without an interpreter 

## Input/Output redirection

### The command `cat`

`cat` simple reads the contents of standard input and writes it back to standard output

### Redirecting input and output

you can use the shell's **redirect** `cat`'s standard input and output devices to read from or write to fiels.      

`cat < file1.txt` 
- cat is doing the same thing but instead of `stdin` being the keyboard it will be `file1.txt`

you can also redirect the standard output using `>`             
`cat > file2.txt`
- this will make cat reading from the keyboard and output to `file2.txt`

you can combined both redirections.         
```
cat < file1.txt > file2.txt
```
- this will read from file1 and write to file2

you can redirect the standard error device with `2>`. For example:          
```
cat < file1.txt > file2.txt 2> log.txt
```
- this will write error messages to `log.txt`

## Commans-line arguments

### Passing command-line arguments
you can pass arguments to a program or script by writing each argument separated by a space after the command name:             
```
cat -n file1.txt
```
- here the `-n` argument makes cat prefix each line with a line number

### Difference between arguments and input redirection

`cat -n < file1.txt` essentially dose the same thing as `cat -n file1.txt` but they are different
- the first has the **shell** redirect `stdin` so that it's `file1.txt`
- the second passes "file1.txt" to cat which then has to look for the file to read from it

the program `echo` reads each command-line argument to `stdout`

```
$ echo a file1.txt
a file1.txt
$ echo a < file1.txt
a 
$
```
- the second time echo is called `file1.txt` is not printed because its not an argument (its an instruction for the shell to redirect `stdin`)
    - this demonstrates the difference between arguments and input redirection

### Quoting arguments

Spaces are treated as separators between arguments. If you want to pass an argument that contains spaces you need to quote it.      
`'` single quotes will not interpolate anything. `"` duoble quotes will interpolate. 

```
$ echo "My shell is $0"
My shell is -bash
$ echo 'My shell is $0'
My shell is $0
```

### Pipes
**pipes** allow us to use the output of one program as the input of another by connecting the second program's `stdin` to the first's `stdout`      

- The command `head -n` gives the first n lines of a file
- the command `wc -w` counts the words in the input

We can combine these two programs by piping them. A pipe is made using the the character `|`        
```
head -20 file.txt | wc - w
```
- this counts the words in the first 20 lines of `file.txt`

``` 
cat file.txt | head -20 | wc -w > words.txt
```
- cat outputs `file.txt` to head
- file is passed to `head` which is passed to `wc` and finally the number of words is redirected to `words.txt`


**Note:** echo changes whitespace of a file, do not combine `echo` with `cat` if u need to preserve the original file format        


## Globbing patterns

The shell can automaticall expand a few wildcard patterns to match all the files that satisfy the pattern. 
- this is known as **globbing**
```
cat *.txt
```
- `*.txt` is known as a **globbing pattern**, the wildcard `*` means "match any sequence of characters>" 

The following operators can be used in globbing patterns
- `*` : matches zero or more characters
- `?` : matches zero or one character
- `+` : matches at least one character
- `[abc]` : matches exactly one of the characters in the brackets
- `[!abc]` : matches any character *except* the ones in the brackets
- `[a-z]` : matches any character in the given range
- `{pat1, pat2}` matches either `pat1` or `pat2` (note no spaces)

# Regular Expressions

## Introduction to pattern matching

We will use the tool `egrep` which looks for lines that match a pattern. 
- `grep` is the less powerful predecessor of `egrep`

```
$ egrep "CS246" < tasks.txt
CS246: Assignment 2
anth221: Discuss conflict with CS246
```
- looks for lines with exactly "CS246"

```
$ egrep "(CS246|cs246)" < tasks.txt
CS246: Assignment 2
cs246 : Exam 1
anth221: Discuss conflict with CS246
```
- looks for lines with either "CS246|cs246"

The syntax `(x|y)` matches to either the pattern `x` or `y`

```
$ egrep "(CS|cs)246" < tasks.txt
CS246: Assignment 2
cs246 : Exam 1
anth221: Discuss conflict with CS246
```

`egrep` also has argument `-i` which ignores case
- this is blunt because it will accept "Cs246" and "cS246" 

`^` means "beginning of line" in regular expressions

```
$ egrep "^(CS|cs)246:" < tasks.txt
CS246: Assignment 2
```

## Advanced patterns
It is common to want to match to a pattern or nothing, the sorthand is `?`
```
$ egrep "^(CS|cs)246 ?:" < tasks.txt
CS246: Assignment 2
cs246 : Exam 1
```
- this makes the space before the colon optional 

```
$ egrep "^(CS|cs)246 *:" < tasks.txt
CS246: Assignment 2
cs246 : Exam 1
```
- this makes the space before the `*` repeatable, it will match to either 0 or any number of repetitions of the space 
- if we wanted it to match to at least one ore more of the space we can change the `*` to `+` which means at least one of the repetition must exist

```
$ egrep "^(CS|cs)246 +:" < tasks.txt
cs246 : Exam 1
```

## Pattern reference
- The basic battern is all normal characters. `e` matches to "e"
- `(XYZ)` groups patterns, usually in order to use `|`,`*`,or `+` on a whole group
    - for example `(CS246)*` matches to "" or "CS246" or "CS246CS246"
- `(X|Y)` matches either `X` or `Y`
- `[...]` matches any of the *characters* between the square brackets
    - `[cC][sS]` is equivalent to `(c|C)(s|S)`
- `[...]` can also match *ranges* of characters, specified with `a-z`. 
    - `[a-z0-9]` matches all lower case letters and numbers
    - `[a-df-z]` matches all lower case letters except for "e"
- `[^...]` is an inversion of `[...]` (matches anything except what's specified)
    - `[^a-z]` matches anything other than a lower-case character
    - it must match to something tho, `CS[^3]46` will not match to "CS46" but will match "CS246" 
- `*` matches repetition of a pattern 0 or more times
    - repeats the pattern not the matched string so `(c|C)*` matches "cCCCcccCCcCCC"
- `+` matches repetition of pattern 1 or more times
- `?` matches repetition of a pattern 0 or 1 time. 
    - `a?` matches either "" or "a"
- `.` matches any single character. Often used to combined patterns that are separated by random tings
    -  `(CS246.*ANTH221|ANTH221.*CS246)` matches to ant and cs with anything between
- `^` matches beginning of line
    - `^CS246` matches to the line that starts with "CS246"
- `$` matches end of line
    - `CS246$` matches to the line that ends with "CS246"
    - `^CS246$` matches to the line that is exactly "CS246"
- `\` escapes special characters
    - be carefule the shell interprets `\` on its own so you should use it in single quotes (which will not interploate)

Here's an example
```
$ egrep "^(CS|cs)2[0-9][0-9] *:.*[Aa]ssignment" < tasks.txt
CS241: Finish assignment 1
CS246: Assignment 2
```
- matches to cs with 2 numbers after and with a colon and followed by assignment

## bash, egrep, and quotation marks

Since we just started with `bash` it is recommended to using `'` single quotes around `egrep` patterns to avoid bash substitutions             

```
$ echo "\hi"
\hi
$ echo "\\"
\
$ echo "\\hi"
\hi
$ echo "$PATH"
/usr/bin:/bin
$ echo "\$PATH"
$PATH
```
In comparison to:               
```
$ echo '\hi'
\hi
$ echo '\\'
\\
$ echo '\\hi'
\\hi
$ echo '$PATH'
$PATH
$ echo '\$PATH'
\$PATH
```

# Bash Scripts

## Introduction
### Creating a script file
It is convention, but not necessary, to use `.sh` for bash script files

```
#!/bin/bash 
date 
whoami 
pwd
```
- the first line is called a **shebang** line
- it tells the shell which language the script is written in 
- the argument `-x` can be added to show verbose output
    - this will be helpful for assignment 1

we can run the program by telling bash to execute it `basic basic.sh`

### Running a script file
The general rules for setting up a script file are: 
1. insert a **shebang** line as your first line
2. always add user-level execute permission 

# Bash as a programming language

adding `-x` will make the script show every command and its arguments as it executes

## Variables

Good list of potential problems [here](https://www.linuxtopia.org/online_books/advanced_bash_scripting_guide/gotchas.html)

Variable naming should follow similar naming conventions to C variable names.

When assigning veriables there should never be a `$`, a `$` is only used to retrives values from a variable. 

``` 
x=1
echo $x
```
- the 1 is a string
- there must be no whitespace around the `=` operator, otherwise its an error

it is good idea to user curly braces `{}` around variable names when retrieving their value `${x}`

there are a lot of global variables available to you. 
    - use the env command to see many of them

### Special shell variables

- `$0` the first parameter of the command-line and its arguments; the shell-script name
- `$1, $2, etc` each command-line argument, based upon its position
- `$#` the total number of command-line arguments
- `$?` the exit/return value of the most recently executed command; used to tell us whether it succeeded or failed
    - 0 means success, not-0 (any other value) means failure

```
#!/bin/bash

egrep "^$1$" /usr/share/dict/words
```
- this returns the word if its in the dictionary


## Selection statements

if statement general structure must follow one of the two following forms: 
```
if condition1 ; then
    statement1
    statement2
elif condition2 ; then
    statement3
...
else
    statement4
    statement5
fi
```
or 
```
if condition1
then
  statement1
  statement2
elif condition2
then
    statement3
...
else
    statement4
    statement5
fi
```
- note that if you want the keyword then to be on the same line as `if/elif` you must separate it with a semicolon from the condition

### specifying conditions
a conditions is generally specified with `[ ]` a pair of open square brackets. There must be a black space between the opening square bracked and the closing square bracket
```
if [ -e foo.txt ]; then
    cat foo.txt
fi
```

```
if [ $foo -eq 2 ]; then
    echo equals 2
else
    echo not equal 2
fi
```

if you want to combine conditions using "and" or "or" use the keywords `-a` or `-o`. 

## Functions

functions can only return a positive integer value, 0 to 255, so we don't need to specify a return-type

```
foo() {
    echo "name is: " ${0}
    echo "foo argument 1 is: " ${1}
    echo "foo argument 2 is: " ${2}
    echo "foo argument 3 is: " ${3}
    if [ ${1} = "cat" ]; then
        return 0
    fi
    return 1
}
```
and `foo` is called by saying: 



```
foo ${3} ${2} ${1}
echo 'foo returned ${?}' ${?}
```

## Loops
bash provied two main types of loops, a counted loop and a loop that iterates over a list of items

here the general forms of a counted loop: 
```
while [ cond ]; do
    ...
done

until [ cond ]; do
   ...
done

for (( expr1; expr2; expr3 )) ; do
   ...
done
```

and here are examples of the forms: 

```
x=1
while [ ${x} -le 5 ]; do
   echo ${x}
   x=$((x + 1))
done

x=1
until [ ${x} -gt 5 ]; do
   echo ${x}
   x=$((x + 1))
done

for (( x=1; x <= 5; x++ )) ; do
    echo ${x}
done
```

- the special syntax `$(( ... ))` is used to tell the shell that the information within the doubled parentheses are to be treated as integers.


here is a list iteration loop: 

```
for variable in list; do
   command1
   command2
   ...
done
```

# Software testing

software can be tested manually by a human or automatically by a machine

In **automated testing** test suites are implemented that automatically test the software and compare results with expected ones.           
- in general **test suites** should contain a list of input sets and matching expected outputs 

## Types of software tests
**Unit tests**
- conducted at the lowest level, testing one specific module/unit of the software       

**Integration tests**
- verify if the different modules/units of the software work correctly together

**Functional tests (system tests)**
- verifies if application produces the correct outputs, here we are not conerned with how results are produced

**Acceptance tests**
- part of a formal process where client must verify that produced software meets all the requirements
    - can be split into phases such as **alpha testing** (end of development, subset of users, in developer environment) and **beta testing (end of development after alpha tests, subset of users, in user's environment)

**Regressions tests**
- conducted after any modification in the software to ensure no errors were introduced

**Performance tests**
- verify if the run-time performance of teh system will be adequate

## White/Black box tests

White box tests: 
- created with knowledge of internal structure of a program
- generalyl used to verify internal structures of a program instead of expected functional requirements
- most common for unit tests

Black-box tests: 
- tests created based only on the requirement specifications, without any knowledge of internal structure of program            
- verify if software works according to specification

Grey-box tests: 
- a mix of the two approaches above

Creating black-box test: 
- identify the different classes of input (numeric ranges, positive vs. negative, etc.)
- test the boundaries of valid ranges (edge cases), e.g., min and max values
- test multiple simultaneous boundaries (corner case)
- test extreme cases 
- intuition - with experience you can begin to guess likely errors

creating white-box tests
- the tests execute all logical paths through the program
the tests make sure that every function runs

# Introduction to C++

C++ allows for high-level abstraction as well as machine level work (backwards compatability with C)

C++ Standard refers to a particular standard, e.g. C++11 refers to the C++ 2011 standard. 

## Basics
```C++
#include <iostream> 
int main() { 
    std::cout << "Hello world!" << std::endl;
    return 0;
}
```
- notice iostream does not end in a `.h`, because `.h` represents that it's a C library and this is a C++ library
- `std::` specifies that something is defined in the **standard (std) namespace**
    - declarations are specific to their namespace
    - `std::cout` is the name for the standard output stream

`main` must have a return value in C++ (0 for success, anthing else for error just like bash), if you don't add `return 0` the compiler will add it for you. 

There are ways around not writing `std::` each time, 
```c++
// solution 1
 using std::count; 
 using std::endl;

// solution 2
 using namespace std; 
 ```

C++ file end in one of `.cc`, `.cpp` or `.C`
- we will use `.cc` in this course

## Compilation

You cannot just run C++ files, you must first compile them.             
Compilers take high-level languages and produce machine-readable code by first preprocessing, then compiling, assembling, and linking. 

We will use the GCC compiler, `g++` is a "front-end" to `gcc` that specifies we're programming in C++. 
- programs compiled on one system will not run on a system with different OS, libraries, etc... So you must compile for the system you intend to run the program on 

**Compiling:**
`g++ hello.cc` creates `a.out` by default           
`g++ -std=c++14 hello.cc` specifies we want to use the C++14 standard (at a minimum)            
`g++14 hello.cc -o hello` specifies the compiled name to have name `hello` (g++14 is an alias we created to shorten `g++ std=c++14`)

There are more options for the compiler which are useful
- `-g` roduce debugging information in the operating system's native format. The GNU debugger, gdb, can work with this debugging information. Makes your code larger, but useful while trying to get everything working.
- `-c` Produce an object file (ends in .o) that consists of assembler output. Will be useful once we discuss separate compilation.
- `-Wall` This enables all the warnings about constructions that some users consider questionable, and that are easy to avoid (or modify to prevent the warning). Not necessary, but a good idea.
- `Wextra` This enables some extra warnings that aren't enabled by -Wall. Not necessary, but a good idea.
- `Wpedantic` This ensures that your code follows the strict ISO C++ standard, with no forbidden extensions. Not necessary, but a good idea. 
- `-D` Lets us define a macro name as a command-line argument to the compiler. Useful for selectively adding/removing code during the compilation process.

It is strongly recommended to learn a tool such as `gdb` for debugging

## Input and output

There are three golbal variables in the standard (std) **namespace** whcih define stream objects used for basic input and output
- `cin` = `stdin` (in C) : reads from standard input
- `cout` = `stdout` (in C) : writes to standard output
- `cerr` = `stderr` (in C) : writes to standard error
    - `>>` is the operator to read input from the stream
    - `<<` is the operator to write to the output stream
    - easy way to remember is they point in the direction of data flow
- to use these streams you must include the `iostream` library

The standard input stream object `cin` has several bits to track if an error has occured, we can only access these bits through methods `fail()` or `eof()`
```c++
if (cin.fail()) { ... }
if (cin.eof()) { ... }
```
- you must attempt to read before you test for end-of-file

## Error Handling

We see that the program will just silently fail if a user enters an invalid input for an integer. 

**Version 2:**

```C++
#include <iostream> 
using namespace std; 

int main() { 
    int i; 
    while (1) { 
        cin >> i; 
        if (!cin) break;
        cout << i << endl;
    }
}
```
- in C++ `(!cin)` is equivalent to `cin.operator!()` where `cin`'s operator `!` has been defined to return the contents of the fail bit by calling `fail()`
    - this ability to specialize operators is called **operator overloading**

**Version 3:**


- (`cin >> i` is equivalent to `operator>>(cin, i)`
    - `operator>>` has return type `cin` since it must be able to read from input multiple times
    - `cin >> x >> y >> z` is equivalent to `operator>>( operator>>( operator>>( cin, x), y), z);
- the parameter to `operator>>` is a **refnerence variable** since `cin` needs to be able to modify it 

the **signature** of the function `operator>>` that reads in an integer is: 
```c++
std::istream * operator>>( std::istream & in, int & value );

```C++
#include <iostream> 
using namespace std; 

int main() { 
    int i; 
    while (1) { 
        if (!(cin >> i)) break;
        cout << i << endl;
    }
}
```
- parenthesis are there to clarify order of operations


**Version 4:** 
This will take advantage of C++11 where `std::istream` can be implicitly converted (we say it is **coerced**) to a Boolean type. 
```C++
#include <iostream> 
using namespace std; 

int main() { 
    int i; 
    while ( cin >> i ) { 
        cout << i << endl;
    }
}
```

**Version 5:**          
we will now modify the program so that it skips reading any non-integer value

- since `cin` keeps reading till a non-integer then sets the fail bit we need to 
1. clear the fail bit after an error with `cin.clear()`
2. we have to "throw away" the offending input with `cin.ignore()`

```c++
#include <iostream> 
using namespace std; 

int main() { 
    int i; 
    while (true) { 
        if ( !(cin >> i) ) {  // remember, operator! === fail()
            if ( cin.eof() ) break;
            cin.clear();
            cin.ignore(); 
        } else { 
            cout << i << endl;
        }
    }
}
```

## File I/O
Reading from a file is almost indentical to reading from standard input. Instead of including the `iostream` library we include the `fstream` library and use the `ifstream` type.          
writing to a file is similar except that we use the `ofstream type`

```c++
#include <fstream> 

int main() { 
    std::ifstream infile{ "input.txt" };
    std::ofstream outfile{ "output.txt" };
    int i; 
    while ( true ) { 
        infile >> i; 
        if (infile.fail() ) break;
        outfile << i << std::endl;
    }
}
```
- the *name* of a file must be of type `(const char *)` or the type `(const string &)`.*

if input file cannot be opened for input
- the `fail` bti is set and u can chek it with `fail()`

if output file doesn't exist
- the system automatically creates the file output file with new contents

if output file doesn't have write permissions 
- `fail` bit is set


The files will automatically close for us when the objects go "out of scope" and are destroyed on the final closing brace `}` of the program. 
- if you used `open()` to open the file you must remember to `close()` it when you are done

## Formatting output

We will rarely require formatting beyond white space in this course, but it's good to know. 

```c++
#include <iostream> 
#include <iomanip> 
using namespace std; 

int main() { 
    for (int i = 0; i < 20; ++i) { 
        cout << dec << setw(3) << i << oct << setw(3) << i << hex << setw(3) << i << endl;
    } 
} 
```
- `setw` is to set width of the information to 3 characters, the fill-character is used to fill out information to meet width
- `dec`, `oct`, `hex` are used to print different "base" systems

```c++
#include <iostream>
#include <iomanip>
using namespace std;

int main () {
  int i = 95;
  cout << hex << i << endl;
  cout << i << endl;
  float price = 2.00;
  cout << fixed << showpoint << setprecision(2) << price << endl;
}
$ g++14 manip.cc 
$ ./a.out
5f
5f
2.00
```
- `dec/oct/hex` feature is "sticky" as in once it's set it continues to print in that base until we change it again
- `showpoint` is used to force printing of decimal point in our floating point number
- `setprecisions` specifies number of digits after the decimal point to print, uses `0` as the fill character

## Strings

| C | C++ | 
| --- | --- | 
|array of character: `char *` or `char []` | *type is `std::string` and requires inclusiong of `<string>` library|
| memory needs to be explicitly managed. Need to shrink and grow array explicitly | manages memory for you | 
| Easy to accidently overwrite `'\0'` and corrupt memory | safer to manipulate | 
| `char  * s = "hello"; char name [10] = "Jane\0";` | `std:: string s = "hello"; string name{ "Jane" };` | 
- note the literal "hello" that is on the right side of s in the c++ assignment is actually a C constant character pointer which is passed to initialize in `s`

### Operations
these are a few of the common string oeprations/operators 
- equality: `s1 == s2`
- inequality: `s1 != s2`
- comparison: `s1 <= s2, s < s2, s1 >= s2, s1 > s2`
    - comparison are *lexicographic*
- length: `s1.size()` or `s1.length()`
- fetch individual characters: `s1[0], s1[1], ...`
    - starts at `0` and goes to `s1.size() - 1`
- concatenation `s1 = s2 + s3; s3 += s4;`

### Input/Output

- `>>` skips initial whitespace when reading `std::string`
- `getline` takes an input stream as a parameter
- `getline` does **not** skip initial white space 
- `getline` can be coerced to return a boolean value

## String streams

There is `stringstream` type which is a hybrid of a string class and I/O stream class. It lets you read/write to/from strings using stream operators. 
- you can use `stringstream` for input or output its recommended to use `istringsream` or `ostringstream` as appropriate. 

### Input string streams

The primary purpose of an input string stream is to take an existing string and split it into separate words. 
- `isstringstream` separates the words by whitespace

```c++
#include <iostream>
#include <sstream>
#include <string>
using namespace std;

int main () {
    string s;
    string s1{ "The quick brown fox\njumped over the lazy\t dog." };
    istringstream ss1{ s1 };
    while ( ss1 >> s ) {
         cout << s << endl;
    }
    string s2{ "Smith,Jane,99999999,Yu,Yaoliang,99999998" };
    istringstream ss2{ s2 };
    cout << "***" << endl;
    while ( getline( ss2, s, ',' ) ) {
         cout << s << endl;
    }
}
```
- *we use `getline` to specify a delimiter to separate our string based on commas for `s2`

### Output string streams
There is almost no reason to use an output string stream object in this course (CS246)
- with the exception of converting integer values to strings for a library such as X11 

```c++
#include <iostream>
#include <string>
#include <sstream>
using namespace std;

int main () {
  ostringstream ss;
  int lo {1}, hi {100};
  ss << "Enter a # between " << lo << " and " << hi;
  string s {ss.str()};
  cout << s << endl;
}
```
- s contains "Enter a # between 1 and 100"

## Command-line arguments 

Command-line arguments in C++ are the same as in C: The `main` function may take two arguments, `argc` and `argv` 
- `argc` is the number of of arguments the program received
- `argv` is the array of arguments
- unfortunately they are no difference than in C! so it's of type `char **` not an array of strings

```c++
#include <iostream>

int main(int argc, char **argv) {
  for (int argi = 0; argi < argc; argi++) {
    std::cout << argv[argi] << std::endl;
  }
}
```
- just like in c `argv[0]` is the name of the program itself

## Functions

functions in C++ are very similar to C. Basic format: 
```c++ 
return-type function-name( type1 arg1, type2 arg2, ... ) {
    ...
    return value of appropriate type;
}
```

### Forward declarations

You should already know to separate a function into its **declaration** (signature) and its **definition** (implementation)

You must call functions only after they have been **declared** but you can **define** them wherever. 

## Overloading

C++ allows for functions to be **overloaded&& which means more than one function can have the exact same name so long as the number of arguments and/or their types is different. 

Note: the decision as to which function must be called must be made at compile-time

The compiler does **not** distinguish between overloaded functions based on return types
- this makes sense, because if they're exactly the same other than return which do you use? 

### Default parameters

Sometimes you want a function to behave the a way most of the time unless specified otherwise through a parameter.          
We can do this with overloading, but then we'd have to maintain two functions, instead we use default parameters. 

function declaration: 
```c++ 
void processInput( bool log = false ); 
```
- this means that the parameter will be set to false when it is called without the parameter explicitly specified

**Note:** All parameters with default values must come **after** those without. 

## Structures

*C*: 
```c 
typedef struct Node_t {
    int value;
    struct Node_t * next;
} Node;

Node * head = NULL;
Node n;
n.value = 5;
n.next = NULL;
```
*C++*:
```c++
struct Node {
    int value;
    Node * next;
};

Node * head = nullptr;
Node n{ 5, nullptr }, n1 = { 6, head };
```
- C++ doesn't require that the type definition start with keyword `typedef`
- `struct` doesn't need to repeated in all variable declarations. Just needs to be done once in the initial type definition
-  C++ no longer uses `NULL` instead you should use `nullptr`
- there is no "short version" of teh type name before closing the semicolon
- there must always be a closing semicolon, after the closing `}`

Here is an **incorrect** example: 
```c++
struct Node {
    int value;
    Node next;
};
```
- this is because `Node` is not defined until the end of the closing bracket. You can use a pointer since they all have the same size


## Constants

We can define **immutable** values with teh `const` keyword. A common convention is to name cosntant values using all capital letters: 
```c++
const int MAX_GRADE = 100; 
const double MATH_PI = 3.14159;
```

you can also declare more complext types as constant such as a `struct`

## Parameter passing

If we want to write a function that increments a value without having to assign its return value we need to pass the variables adress and directly modify it.           
Normally we are only passing the value of a variable and any modification within the function does not affect it, this is called **call-by-value**

```c++
void inc( int * n ) { ++*n; } // same as *n = *n + 1;
...
inc( &value );
```
- this allows for `inc(x)` to work 

## References

References are a very important topic you should understand them well. 
- in this course, you should generally pass by reference rather than by pointer as much ass possible
    - that way you don't have to remember to dereference your pointers all of the time. 

Let's introduce the concept of **rvalues** and **lvalues** (left and right)
- if you can take the address of an expression it's an **lvalue**, otherwise it's an **rvalue**
- **lvalue** can appear on the left hand side of an assignment

for example : 
```c++ 
int x = 5;
int * ptr = nullptr;
```
- x and ptr are both **lvalues**

A **reference** is an *lvalue* that acts like a constant pointer but the compiler automatically dereferences it. Since it's constant it **must** be initialized when it is defined. 
```c++ 
int x = 5;
int &y = x;
int * ptr = &y;
y += 2;
*ptr += 3;
std::cout << x << std::endl;
```
- `*ptr` contains the address of `x` 

There are a number of things that **cannot** be done with an **lvalue reference**
1. cannot leave them uninitialized `int &x;` is illegal, must be initialized with an **lvalue**
2. cannot create a pointer to a reference `int &*x;` is illegal
    - but a reference to a pointer is legal
3. cannot create a reference to a reference `int &&x;` does not mean "reference to reference" we will see what it actually means later 
4. cannot create an array of reference `int $refAarray[3] = {x, y, z}`

let us revise the increment program: 
```c++ 
#include <iostream>
using namespace std;

void inc(int &n) {
  n = n + 1;
}

int main () {
  int x {5};
  inc(x);
  cout << x << endl;
}
```
passing by value requires "copying" the value into the function which can be expensive for large data, so to incerase efficiency we can pass a **constant reference** which will allow us to read the data but not mutate it. 

**Advice:** pass by const ref over pass by value for anything larger than an integer unless the function needs to make a copy anyways. 

**Warning:** if you want to pass a literal integer it must be defined as a constant reference. 

`f(5)` would not work with `int f( int & n ) { ... }`       

`f(5)` works with `int f( const int & n ) { ... }`       

## Dynamic memory allocation

| C | C++ |
| --- | --- | 
| uses a library `cstdlib` now known as `stdio.h` that provides `malloc`,`calloc`,`realloc` and `free`. Only works with type `(void*)` so **not** type safe | uses keywords `new` and `delete`. Type safe, i.e. allocates space appropriate of size and return a  pointer of the appropriate type | 

```c++
#include <iostream>

struct Node {
   int data;
   Node * next;
};

int main() {
   Node n{ 5, nullptr };
   Node * np = new Node{ 3, &n };
   std::cout << n.data << ' ' << np->data << std::endl;
   delete np;
}
```

**Warning:** if you fail to delete dynamically allocated memory you have a **memory leak**. It is considered incorrect in this course since it will eventually fail. 

### Dynamic array allocation

```c++ 
Node * nodeArray = new Node[10];
...
nodeArray[0].data = 5;
nodeArray[0].next = nullptr;
...
delete []  nodeArray;
```
- must specify `[]` after `delete` otherwise it will only delete the first element and cause a **memory leak**
    - match your `new` and `delete` statements, if one used `[]` the other should too 

### Pointers and optional files

`./test [ input-file-name [output-file-name] ]` it is unix convention to specify (in documentation) optional arguments by enclosing them in `[]`

it is common to have programs default to `stdin` or use files if supplied in arguments. 

Here is a good example of how to handle this: 

```c++
#include <iostream>
#include <fstream>
#include <string>

void usage( char * pgmname ) {
    std::cerr << pgmname << " [ input-file-name [output-file-name] ]" << std::endl;
} // usage

int main( int argc, char * argv[] ) {
    std::istream * infile = &std::cin;
    std::ostream * outfile = &std::cout;

    if ( argc > 3 || argc < 1 ) {
        usage( argv[0] );
        return 1;           
    } // if

    switch( argc ) {
        case 3:
            outfile = new std::ofstream{ argv[2] };
            if ( outfile == nullptr || outfile->fail() ) {
                delete outfile;
                std::cerr << "ERROR: unable to open output file \""
                    << argv[2] << '"' << std::endl;
                return 1;
            } // if
            // fall through to open up the input file next
        case 2:
            infile = new std::ifstream{ argv[1] };
            if ( infile == nullptr || infile->fail() ) {
                if ( outfile != &std::cout ) delete outfile;
                delete infile;
                std::cerr << "ERROR: unable to open input file \""
                    << argv[1] << '"' << std::endl;
                return 1;
            } // if
            break;
        default:
            // do nothing
            break;
    } // switch

    // Echoes the input to output.
    std::string line;
    while ( std::getline( *infile, line ) ) {
        *outfile << line << std::endl;
    } // while

    // Closes the I/O files. Don't delete if standard input or output, though.
    if ( infile != &std::cin ) delete infile;
    if ( outfile != &std::cout ) delete outfile;
} // main
```

## Returning information

There are three ways a function can return values; 
1. return by *value*
2. return by *pointer* 
3. return by *reference*

let's see examples of the three using the structure: 
```c++ 
struct Node {
  int data;
  Node * next;
};
```

**Return by value**
```c++
Node getMeANode( int value ) {
   Node n{ value, nullptr };
   return n;
}
```
**Return by pointer**
```
// THIS CODE IS INCORRECT
Node * getMeANode( int value ) {
   Node n{ value, nullptr };
   return &n;
}
```
- this is return an adress of a local variable which is popped from the stack when the function ends
The correct way: 
```c++
Node * getMeANode( int value ) {
   Node *nptr = new Node{ value, nullptr };
   return nptr;
}
```

**Return by reference**
```c++
Node & getMeANode( int value ) {
   Node *nptr = new Node{ value, nullptr };
   return *nptr;
}
```
- the problem is that the user won't know that it allocates in the heap and that they must `delete` what's allocated

```c++
Node & newNode = getMeANode( 5 );
...
// do something with newNode
...
delete &newNode;
```
- when deleteing a reference value we must get it's address since `delete` only works on pointers

**Which technique should we use**
- in some cases returning a pointer is fine, however in most situations it turns out that return by value is the right thing to do since as of C++11 (and up) it's not as expensive as it looks

## Operator overloading

we can also overload operators such as `+`,`-`,`*`,`/`, etc. in C++. 
```c++
struct Vec {
   int x, y;
};

Vec operator+( const Vec & v1, const Vec & v2 ) {
   Vec v{ v1.x + v2.x, v1.y + v2.y };
   return v;
}

int main() {
   Vec v1{3, 4}, v2{6, 7};
   Vec v3 = v1 + v2;
}
```
We can multiply a vector by an integer
```c++
Vec operator*( const Vec & v, const int k  ) {
   return { k*v.x, k*v.y };
}
Vec operator*( const Vec & v, const int k  ) {
   return k * v;
}
```
- without the second operator overload we would only be able to write `(v * k)` so we have to define it both ways

### Overloading << and >> 
```c++ 
struct Grade { 
    int theGrade; 
};
```
We want the output operator the print the value then a '%' sign
```c++ 
std::ostream & operator<<( std::ostream & out, const Grade & g ) {
   out << g.theGrade << '%';
   return out;
}
```
Rules for output operator: 
1. the return type is always `std::osteram &`
2. the function name is always `operator<<`
3. the first parameter is always the output stream `std::ostream &`
4. the second parameter is always the information being output
5. write the `return` statement to return whatever the name of the output stream is

```c++
std::istream & operator>>( std::istream & in, Grade & g ) {
   in >> g.theGrade;
   if ( g.theGrade < 0 ) g.theGrade = 0;
   else if ( g.theGrade > 100 ) g.theGrade = 100;
   return in;
}
```

Rules for input operator: 
1. the return operator is always `std::istream &`
2. the function operator is always `operator>>`
3. the firs parameter is always the input stream `std::istream &`
4. the second parameter is always the information being read in. 
5. write the `return` statement to return whatever the name of the input stream 

templates: 
```c++ 
std::ostream & operator<<( std::ostream & out, const typeToPrint & value ) {
   out << v ; // whatever is appropriate for the type you are outputting
   return out;
}
std::istream & operator>>( std::istream & in, typeToRead & value ) {
   in >> v ; // whatever is appropriate for the type you are reading in
   return in;
}
```

# Preprocessing and Compilation

## The preprocessor

The **C preprocessor** is tasked with handling **preprocessor directives**, it's primary purpose is to control what code is included in your program. 

the `-E` flag with g++ will make the preprocessor output to standard out

the preprocessor can also define constants `#define GEESE 15` however in modern C++ and C this is unneeded and you should use `const` definitions since they are more type-safe.

the `#if` (ends with `#endif`) controls whether code is included (controlled by preprocessor).              
Here is an example of debugging using `#if`
```c++
$ cat debug.cc 
#include <iostream>
using namespace std;

#define DEBUG_LEVEL 1

int main() {
#if DEBUG_LEVEL >= 1
    cout << "main has started" << endl;
#endif
    cout << "Hello, world!" << endl;
#if DEBUG_LEVEL >= 2
    cout << "About to end main" << endl;
#endif
    return 0;
}
```

`#ifdef` and `#ifndef` check if a preprocessor variable is set: 
```c++
 [...]
#ifdef DEBUG
  cout << "Debugging activated (I don't care what level)" << endl;
#endif
```

`#if 0` can be used to comment out large amounts of code since it nests properly unlike comments

preprocessor variables can be given in the command line to `g++`, e.g. `$ g++ -std=c++14 debug.cc -DDEBUG_LEVEL=2 -o debug`

## Separate compilation
- **declaration**: asserts that a function or variable exists, but does't define its content
- **definition**: full details on a function or variable. Defines a function's content and allocates space for both functions and variables

We split our code into two components: 
- **interface**: declarations including function prototypes, with no actual code, as well as type definitions. Put in a separate file from the actual code, typically named wih `.h` (for "header")
- **implementation**: the full definition for every function, as well as space for any global variables. In this course, typicall named `.cc`. C files are always named `.c`

The real power in separating our implementations is by having **separate compilation** this is useful for very large projects where compiling the entire project for one change would take a very long time. 
```
$ g++ -c main.cc
$ g++ -c vec.cc
$ g++ main.o vec.o -o vecs
$
```
- the `-c` compiles to an **object file** which is compiled code but not enough for a full program.
- combining multiple `.o` files is called **linking**

if we only change something in main we don't have to recompile the entire project: 
```c++ 
  [... change main.cc ...]
$ g++ -c main.cc
$ g++ main.o vec.o -o vecs
$
```

header files can only have declarations so we need to declare a variable in the header file with `extern type name` then define the varaible in an implementation file.

## Make and makefiles


there is a tool to automate linking, `make`         
a simple makefile for our previous example program is 
```make
vecs: main.o vec.o
	g++ main.o vec.o -o vecs

main.o: main.cc vec.h
	g++ -std=c++14 -c main.cc

vec.o: vec.cc vec.h
	g++ -std=c++14 -c vec.cc
```
- this must be placed in a file named "Makefile"
- the lines not indented are *dependencies*
    - the show that the file before the colon depends on the file after the colon
    - each file is a **target** (something Makefile describes how to create)

**note:** the commands to create a target must be indented with tabs, even if you normally use spaces

the command to create any given target is called a **recipe**

to use the make file we only need to use the command `make`
```
$ make
g++ -std=c++14 -c main.cc
g++ -std=c++14 -c vec.cc
g++ main.o vec.o -o vecs
$
```
- `make` automatically only rebuilds what is needed based on what we changed

we can clean up unwanted side effects of building through a **phony target** (a target that only exists for its recipe and doesn't actually build anything)
```
$ cat Makefile 
vecs: main.o vec.o
	g++ main.o vec.o -o vecs

main.o: main.cc vec.h
	g++ -std=c++14 -c main.cc

vec.o: vec.cc vec.h
	g++ -std=c++14 -c vec.cc

.PHONY: clean

clean:
	rm *.o vecs

$ make clean
rm *.o vecs
$
```

we can reduce clutter in our `Makefile` by using **make variables**
```
$ cat Makefile 
CXX=g++
CXXFLAGS=-std=c++14
OBJECTS=main.o vec.o
EXEC=vecs

${EXEC}: ${OBJECTS}
	${CXX} ${OBJECTS} -o ${EXEC}

main.o: main.cc vec.h
vec.o: vec.cc vec.h
.PHONY: clean

clean:
	rm ${OBJECTS} ${EXEC}

$ make 
g++ -std=c++14   -c -o main.o main.cc
g++ -std=c++14   -c -o vec.o vec.cc
g++ main.o vec.o -o vecs
$
```

the `-MMD` flag for g++ makes it create `.d` files which are `make` dependencies so that we can keep track of what our dependencies are. 
```
$ cat Makefile 
CXX=g++
CXXFLAGS=-std=c++14 -MMD
OBJECTS=main.o vec.o
DEPENDS=${OBJECTS:.o=.d}
EXEC=vecs

${EXEC}: ${OBJECTS}
	${CXX} ${OBJECTS} -o ${EXEC}

-include ${DEPENDS}

.PHONY: clean

clean:
	rm ${OBJECTS} ${DEPENDS} ${EXEC}
$ 
```
`make` is capable of a lot more, but this is sufficient to build most normal C++ projects
























