# CS 246 - Object Oriented Software Development | Fall 2020

# Linux File Permissions 

Permission information: d rwx r-x ---
- first character: `d` if directory, `-` if file
- next three are read (`r`), write (`w`), executable (`x`)
- first three are user, next three are group, next three are other (everyone)

## chgrp - change group

Changes group-name associated with a file

Usage: `chgrp [-R] group-name file/directory-list`

## chmod - change permissions

Changes permissions of a file

Usage: `chmod [-R] mode-list file/directory-list`
- `mode-list` has the form : `security-level operator permission`
- securty-level is: user (`u`), group (`g`), other (`o`), all (`a`)
- Operator `+` adds permission, `-` removes permission, `=` sets permission

Example: `chmod go-rw foo`, `chmod a+r schedule.html`, `chmod g=rw test.txt`

**Note:** if you `chmod` using binary numbers you can switch the permissions based on the binary representation of each of those bits
- chmod `712` -> `111 001 010` -> `rwz --x -w-`

# The File System 
**path:** is the general name of a file or directory in textual format

Note: directories in linux are just a specialized form of file
- they can be edited but it is dangerous to do so 

## Absolute and relative paths
`/` is the **root** directory

`.` is the current directory, `..` is the previous directory

## Changing the current directory
`cd` to change directory        
`pwd` to display path of working directory      

## The home directory
Each new user is given their own **home directory**
- this is a directory owned by the user where they can place their personal files without disturbing other users

when writing a pathname, the shell replaces the special character `~` with the absolute path of your home directory.        

## The $PATH variable
When the name of a file is given without a path then the shell looks in locations defined global system variable named `$PATH`      
The contents of the `$PATH` variable are a list of pathnames separated by the colon character (:)
```
$ echo $PATH
/home/bob/bin:/user/local/bin:/usr/bin
```

you can run a program by giving its path to the shell           

you can add to the $PATH variable by (this doesn't affect existing PATH values):
```
export PATH=$PATH:/location/program
```

# The shell


A **shell** is a program that runs and gives an interface to communicate with the opreating system 

In most linux distributions, a program called bash acts as the shell

SSH (Secure SHell) connection allows us to user the shell on another computer through the internet. 

**Standard input:** `stdin` is a device where from the shell is reading text input              
**Standard output:** `stdout` is a device where the shell is writing text output        
**Standard error:** `stderr` is a device where the shell writes error messages to            

## The command `ls`
The command `ls -l` displays a long form of the list with the following information:            
- **type:** `-` for a file, `d` for directory
- **permissions:** three groups of three bits
    - 3 for user, 3 for group, 3 for other
- **owner:** the ID of the user that owns the file
- **group:** a user can belong to one or more group
- **size:** size of the file in bytes
- **modified:** the date and time it was last modified
- **name:** the file name


## Executing commands

`bash` can run in an interactive (user provides commands) or non-interactive mode (a script file)

## The command prompt
command prompt is what the shell displays in interactive mode when it is waiting for user input

### Types of commands
**Scripts:** are text files that contain commands in a specific programming language. 
- interpreters interpret and execute the commands

**Programs:** are files that contain commands in binary format. They can be understood the operating system not by a human                  
and can be run without an interpreter 

## Input/Output redirection

### The command `cat`

`cat` simple reads the contents of standard input and writes it back to standard output

### Redirecting input and output

you can use the shell's **redirect** `cat`'s standard input and output devices to read from or write to fiels.      

`cat < file1.txt` 
- cat is doing the same thing but instead of `stdin` being the keyboard it will be `file1.txt`

you can also redirect the standard output using `>`             
`cat > file2.txt`
- this will make cat reading from the keyboard and output to `file2.txt`

you can combined both redirections.         
```
cat < file1.txt > file2.txt
```
- this will read from file1 and write to file2

you can redirect the standard error device with `2>`. For example:          
```
cat < file1.txt > file2.txt 2> log.txt
```
- this will write error messages to `log.txt`

## Commans-line arguments

### Passing command-line arguments
you can pass arguments to a program or script by writing each argument separated by a space after the command name:             
```
cat -n file1.txt
```
- here the `-n` argument makes cat prefix each line with a line number

### Difference between arguments and input redirection

`cat -n < file1.txt` essentially dose the same thing as `cat -n file1.txt` but they are different
- the first has the **shell** redirect `stdin` so that it's `file1.txt`
- the second passes "file1.txt" to cat which then has to look for the file to read from it

the program `echo` reads each command-line argument to `stdout`

```
$ echo a file1.txt
a file1.txt
$ echo a < file1.txt
a 
$
```
- the second time echo is called `file1.txt` is not printed because its not an argument (its an instruction for the shell to redirect `stdin`)
    - this demonstrates the difference between arguments and input redirection

### Quoting arguments

Spaces are treated as separators between arguments. If you want to pass an argument that contains spaces you need to quote it.      
`'` single quotes will not interpolate anything. `"` duoble quotes will interpolate. 

```
$ echo "My shell is $0"
My shell is -bash
$ echo 'My shell is $0'
My shell is $0
```

### Pipes
**pipes** allow us to use the output of one program as the input of another by connecting the second program's `stdin` to the first's `stdout`      

- The command `head -n` gives the first n lines of a file
- the command `wc -w` counts the words in the input

We can combine these two programs by piping them. A pipe is made using the the character `|`        
```
head -20 file.txt | wc - w
```
- this counts the words in the first 20 lines of `file.txt`

``` 
cat file.txt | head -20 | wc -w > words.txt
```
- cat outputs `file.txt` to head
- file is passed to `head` which is passed to `wc` and finally the number of words is redirected to `words.txt`


**Note:** echo changes whitespace of a file, do not combine `echo` with `cat` if u need to preserve the original file format        


## Globbing patterns

The shell can automaticall expand a few wildcard patterns to match all the files that satisfy the pattern. 
- this is known as **globbing**
```
cat *.txt
```
- `*.txt` is known as a **globbing pattern**, the wildcard `*` means "match any sequence of characters>" 

The following operators can be used in globbing patterns
- `*` : matches zero or more characters
- `?` : matches zero or one character
- `+` : matches at least one character
- `[abc]` : matches exactly one of the characters in the brackets
- `[!abc]` : matches any character *except* the ones in the brackets
- `[a-z]` : matches any character in the given range
- `{pat1, pat2}` matches either `pat1` or `pat2` (note no spaces)

# Regular Expressions

## Introduction to pattern matching

We will use the tool `egrep` which looks for lines that match a pattern. 
- `grep` is the less powerful predecessor of `egrep`

```
$ egrep "CS246" < tasks.txt
CS246: Assignment 2
anth221: Discuss conflict with CS246
```
- looks for lines with exactly "CS246"

```
$ egrep "(CS246|cs246)" < tasks.txt
CS246: Assignment 2
cs246 : Exam 1
anth221: Discuss conflict with CS246
```
- looks for lines with either "CS246|cs246"

The syntax `(x|y)` matches to either the pattern `x` or `y`

```
$ egrep "(CS|cs)246" < tasks.txt
CS246: Assignment 2
cs246 : Exam 1
anth221: Discuss conflict with CS246
```

`egrep` also has argument `-i` which ignores case
- this is blunt because it will accept "Cs246" and "cS246" 

`^` means "beginning of line" in regular expressions

```
$ egrep "^(CS|cs)246:" < tasks.txt
CS246: Assignment 2
```

## Advanced patterns
It is common to want to match to a pattern or nothing, the sorthand is `?`
```
$ egrep "^(CS|cs)246 ?:" < tasks.txt
CS246: Assignment 2
cs246 : Exam 1
```
- this makes the space before the colon optional 

```
$ egrep "^(CS|cs)246 *:" < tasks.txt
CS246: Assignment 2
cs246 : Exam 1
```
- this makes the space before the `*` repeatable, it will match to either 0 or any number of repetitions of the space 
- if we wanted it to match to at least one ore more of the space we can change the `*` to `+` which means at least one of the repetition must exist

```
$ egrep "^(CS|cs)246 +:" < tasks.txt
cs246 : Exam 1
```

## Pattern reference
- The basic battern is all normal characters. `e` matches to "e"
- `(XYZ)` groups patterns, usually in order to use `|`,`*`,or `+` on a whole group
    - for example `(CS246)*` matches to "" or "CS246" or "CS246CS246"
- `(X|Y)` matches either `X` or `Y`
- `[...]` matches any of the *characters* between the square brackets
    - `[cC][sS]` is equivalent to `(c|C)(s|S)`
- `[...]` can also match *ranges* of characters, specified with `a-z`. 
    - `[a-z0-9]` matches all lower case letters and numbers
    - `[a-df-z]` matches all lower case letters except for "e"
- `[^...]` is an inversion of `[...]` (matches anything except what's specified)
    - `[^a-z]` matches anything other than a lower-case character
    - it must match to something tho, `CS[^3]46` will not match to "CS46" but will match "CS246" 
- `*` matches repetition of a pattern 0 or more times
    - repeats the pattern not the matched string so `(c|C)*` matches "cCCCcccCCcCCC"
- `+` matches repetition of pattern 1 or more times
- `?` matches repetition of a pattern 0 or 1 time. 
    - `a?` matches either "" or "a"
- `.` matches any single character. Often used to combined patterns that are separated by random tings
    -  `(CS246.*ANTH221|ANTH221.*CS246)` matches to ant and cs with anything between
- `^` matches beginning of line
    - `^CS246` matches to the line that starts with "CS246"
- `$` matches end of line
    - `CS246$` matches to the line that ends with "CS246"
    - `^CS246$` matches to the line that is exactly "CS246"
- `\` escapes special characters
    - be carefule the shell interprets `\` on its own so you should use it in single quotes (which will not interploate)

Here's an example
```
$ egrep "^(CS|cs)2[0-9][0-9] *:.*[Aa]ssignment" < tasks.txt
CS241: Finish assignment 1
CS246: Assignment 2
```
- matches to cs with 2 numbers after and with a colon and followed by assignment

## bash, egrep, and quotation marks

Since we just started with `bash` it is recommended to using `'` single quotes around `egrep` patterns to avoid bash substitutions             

```
$ echo "\hi"
\hi
$ echo "\\"
\
$ echo "\\hi"
\hi
$ echo "$PATH"
/usr/bin:/bin
$ echo "\$PATH"
$PATH
```
In comparison to:               
```
$ echo '\hi'
\hi
$ echo '\\'
\\
$ echo '\\hi'
\\hi
$ echo '$PATH'
$PATH
$ echo '\$PATH'
\$PATH
```

# Bash Scripts

## Introduction
### Creating a script file
It is convention, but not necessary, to use `.sh` for bash script files

```
#!/bin/bash 
date 
whoami 
pwd
```
- the first line is called a **shebang** line
- it tells the shell which language the script is written in 
- the argument `-x` can be added to show verbose output
    - this will be helpful for assignment 1

we can run the program by telling bash to execute it `basic basic.sh`

### Running a script file
The general rules for setting up a script file are: 
1. insert a **shebang** line as your first line
2. always add user-level execute permission 

# Bash as a programming language

adding `-x` will make the script show every command and its arguments as it executes

## Variables

Good list of potential problems [here](https://www.linuxtopia.org/online_books/advanced_bash_scripting_guide/gotchas.html)

Variable naming should follow similar naming conventions to C variable names.

When assigning veriables there should never be a `$`, a `$` is only used to retrives values from a variable. 

``` 
x=1
echo $x
```
- the 1 is a string
- there must be no whitespace around the `=` operator, otherwise its an error

it is good idea to user curly braces `{}` around variable names when retrieving their value `${x}`

there are a lot of global variables available to you. 
    - use the env command to see many of them

### Special shell variables

- `$0` the first parameter of the command-line and its arguments; the shell-script name
- `$1, $2, etc` each command-line argument, based upon its position
- `$#` the total number of command-line arguments
- `$?` the exit/return value of the most recently executed command; used to tell us whether it succeeded or failed
    - 0 means success, not-0 (any other value) means failure

```
#!/bin/bash

egrep "^$1$" /usr/share/dict/words
```
- this returns the word if its in the dictionary


## Selection statements

if statement general structure must follow one of the two following forms: 
```
if condition1 ; then
    statement1
    statement2
elif condition2 ; then
    statement3
...
else
    statement4
    statement5
fi
```
or 
```
if condition1
then
  statement1
  statement2
elif condition2
then
    statement3
...
else
    statement4
    statement5
fi
```
- note that if you want the keyword then to be on the same line as `if/elif` you must separate it with a semicolon from the condition

### specifying conditions
a conditions is generally specified with `[ ]` a pair of open square brackets. There must be a black space between the opening square bracked and the closing square bracket
```
if [ -e foo.txt ]; then
    cat foo.txt
fi
```

```
if [ $foo -eq 2 ]; then
    echo equals 2
else
    echo not equal 2
fi
```

if you want to combine conditions using "and" or "or" use the keywords `-a` or `-o`. 

## Functions

functions can only return a positive integer value, 0 to 255, so we don't need to specify a return-type

```
foo() {
    echo "name is: " ${0}
    echo "foo argument 1 is: " ${1}
    echo "foo argument 2 is: " ${2}
    echo "foo argument 3 is: " ${3}
    if [ ${1} = "cat" ]; then
        return 0
    fi
    return 1
}
```
and `foo` is called by saying: 



```
foo ${3} ${2} ${1}
echo 'foo returned ${?}' ${?}
```

## Loops
bash provied two main types of loops, a counted loop and a loop that iterates over a list of items

here the general forms of a counted loop: 
```
while [ cond ]; do
    ...
done

until [ cond ]; do
   ...
done

for (( expr1; expr2; expr3 )) ; do
   ...
done
```

and here are examples of the forms: 

```
x=1
while [ ${x} -le 5 ]; do
   echo ${x}
   x=$((x + 1))
done

x=1
until [ ${x} -gt 5 ]; do
   echo ${x}
   x=$((x + 1))
done

for (( x=1; x <= 5; x++ )) ; do
    echo ${x}
done
```

- the special syntax `$(( ... ))` is used to tell the shell that the information within the doubled parentheses are to be treated as integers.


here is a list iteration loop: 

```
for variable in list; do
   command1
   command2
   ...
done
```

# Software testing

software can be tested manually by a human or automatically by a machine

In **automated testing** test suites are implemented that automatically test the software and compare results with expected ones.           
- in general **test suites** should contain a list of input sets and matching expected outputs 

## Types of software tests
**Unit tests**
- conducted at the lowest level, testing one specific module/unit of the software       

**Integration tests**
- verify if the different modules/units of the software work correctly together

**Functional tests (system tests)**
- verifies if application produces the correct outputs, here we are not conerned with how results are produced

**Acceptance tests**
- part of a formal process where client must verify that produced software meets all the requirements
    - can be split into phases such as **alpha testing** (end of development, subset of users, in developer environment) and **beta testing (end of development after alpha tests, subset of users, in user's environment)

**Regressions tests**
- conducted after any modification in the software to ensure no errors were introduced

**Performance tests**
- verify if the run-time performance of teh system will be adequate

## White/Black box tests

White box tests: 
- created with knowledge of internal structure of a program
- generalyl used to verify internal structures of a program instead of expected functional requirements
- most common for unit tests

Black-box tests: 
- tests created based only on the requirement specifications, without any knowledge of internal structure of program            
- verify if software works according to specification

Grey-box tests: 
- a mix of the two approaches above

Creating black-box test: 
- identify the different classes of input (numeric ranges, positive vs. negative, etc.)
- test the boundaries of valid ranges (edge cases), e.g., min and max values
- test multiple simultaneous boundaries (corner case)
- test extreme cases 
- intuition - with experience you can begin to guess likely errors

creating white-box tests
- the tests execute all logical paths through the program
the tests make sure that every function runs

# Introduction to C++

C++ allows for high-level abstraction as well as machine level work (backwards compatability with C)

C++ Standard refers to a particular standard, e.g. C++11 refers to the C++ 2011 standard. 

## Basics
```C++
#include <iostream> 
int main() { 
    std::cout << "Hello world!" << std::endl;
    return 0;
}
```
- notice iostream does not end in a `.h`, because `.h` represents that it's a C library and this is a C++ library
- `std::` specifies that something is defined in the **standard (std) namespace**
    - declarations are specific to their namespace
    - `std::cout` is the name for the standard output stream

`main` must have a return value in C++ (0 for success, anthing else for error just like bash), if you don't add `return 0` the compiler will add it for you. 

There are ways around not writing `std::` each time, 
```c++
// solution 1
 using std::count; 
 using std::endl;

// solution 2
 using namespace std; 
 ```

C++ file end in one of `.cc`, `.cpp` or `.C`
- we will use `.cc` in this course

## Compilation

You cannot just run C++ files, you must first compile them.             
Compilers take high-level languages and produce machine-readable code by first preprocessing, then compiling, assembling, and linking. 

We will use the GCC compiler, `g++` is a "front-end" to `gcc` that specifies we're programming in C++. 
- programs compiled on one system will not run on a system with different OS, libraries, etc... So you must compile for the system you intend to run the program on 

**Compiling:**
`g++ hello.cc` creates `a.out` by default           
`g++ -std=c++14 hello.cc` specifies we want to use the C++14 standard (at a minimum)            
`g++14 hello.cc -o hello` specifies the compiled name to have name `hello` (g++14 is an alias we created to shorten `g++ std=c++14`)

There are more options for the compiler which are useful
- `-g` roduce debugging information in the operating system's native format. The GNU debugger, gdb, can work with this debugging information. Makes your code larger, but useful while trying to get everything working.
- `-c` Produce an object file (ends in .o) that consists of assembler output. Will be useful once we discuss separate compilation.
- `-Wall` This enables all the warnings about constructions that some users consider questionable, and that are easy to avoid (or modify to prevent the warning). Not necessary, but a good idea.
- `Wextra` This enables some extra warnings that aren't enabled by -Wall. Not necessary, but a good idea.
- `Wpedantic` This ensures that your code follows the strict ISO C++ standard, with no forbidden extensions. Not necessary, but a good idea. 
- `-D` Lets us define a macro name as a command-line argument to the compiler. Useful for selectively adding/removing code during the compilation process.

It is strongly recommended to learn a tool such as `gdb` for debugging

## Input and output

There are three golbal variables in the standard (std) **namespace** whcih define stream objects used for basic input and output
- `cin` = `stdin` (in C) : reads from standard input
- `cout` = `stdout` (in C) : writes to standard output
- `cerr` = `stderr` (in C) : writes to standard error
    - `>>` is the operator to read input from the stream
    - `<<` is the operator to write to the output stream
    - easy way to remember is they point in the direction of data flow
- to use these streams you must include the `iostream` library

The standard input stream object `cin` has several bits to track if an error has occured, we can only access these bits through methods `fail()` or `eof()`
```c++
if (cin.fail()) { ... }
if (cin.eof()) { ... }
```
- you must attempt to read before you test for end-of-file

## Error Handling

We see that the program will just silently fail if a user enters an invalid input for an integer. 

**Version 2:**

```C++
#include <iostream> 
using namespace std; 

int main() { 
    int i; 
    while (1) { 
        cin >> i; 
        if (!cin) break;
        cout << i << endl;
    }
}
```
- in C++ `(!cin)` is equivalent to `cin.operator!()` where `cin`'s operator `!` has been defined to return the contents of the fail bit by calling `fail()`
    - this ability to specialize operators is called **operator overloading**

**Version 3:**


- (`cin >> i` is equivalent to `operator>>(cin, i)`
    - `operator>>` has return type `cin` since it must be able to read from input multiple times
    - `cin >> x >> y >> z` is equivalent to `operator>>( operator>>( operator>>( cin, x), y), z);
- the parameter to `operator>>` is a **refnerence variable** since `cin` needs to be able to modify it 

the **signature** of the function `operator>>` that reads in an integer is: 
```c++
std::istream * operator>>( std::istream & in, int & value );

```C++
#include <iostream> 
using namespace std; 

int main() { 
    int i; 
    while (1) { 
        if (!(cin >> i)) break;
        cout << i << endl;
    }
}
```
- parenthesis are there to clarify order of operations


**Version 4:** 
This will take advantage of C++11 where `std::istream` can be implicitly converted (we say it is **coerced**) to a Boolean type. 
```C++
#include <iostream> 
using namespace std; 

int main() { 
    int i; 
    while ( cin >> i ) { 
        cout << i << endl;
    }
}
```

**Version 5:**          
we will now modify the program so that it skips reading any non-integer value

- since `cin` keeps reading till a non-integer then sets the fail bit we need to 
1. clear the fail bit after an error with `cin.clear()`
2. we have to "throw away" the offending input with `cin.ignore()`

```c++
#include <iostream> 
using namespace std; 

int main() { 
    int i; 
    while (true) { 
        if ( !(cin >> i) ) {  // remember, operator! === fail()
            if ( cin.eof() ) break;
            cin.clear();
            cin.ignore(); 
        } else { 
            cout << i << endl;
        }
    }
}
```

## File I/O
Reading from a file is almost indentical to reading from standard input. Instead of including the `iostream` library we include the `fstream` library and use the `ifstream` type.          
writing to a file is similar except that we use the `ofstream type`

```c++
#include <fstream> 

int main() { 
    std::ifstream infile{ "input.txt" };
    std::ofstream outfile{ "output.txt" };
    int i; 
    while ( true ) { 
        infile >> i; 
        if (infile.fail() ) break;
        outfile << i << std::endl;
    }
}
```
- the *name* of a file must be of type `(const char *)` or the type `(const string &)`.*

if input file cannot be opened for input
- the `fail` bti is set and u can chek it with `fail()`

if output file doesn't exist
- the system automatically creates the file output file with new contents

if output file doesn't have write permissions 
- `fail` bit is set


The files will automatically close for us when the objects go "out of scope" and are destroyed on the final closing brace `}` of the program. 
- if you used `open()` to open the file you must remember to `close()` it when you are done

## Formatting output

We will rarely require formatting beyond white space in this course, but it's good to know. 

```c++
#include <iostream> 
#include <iomanip> 
using namespace std; 

int main() { 
    for (int i = 0; i < 20; ++i) { 
        cout << dec << setw(3) << i << oct << setw(3) << i << hex << setw(3) << i << endl;
    } 
} 
```
- `setw` is to set width of the information to 3 characters, the fill-character is used to fill out information to meet width
- `dec`, `oct`, `hex` are used to print different "base" systems

```c++
#include <iostream>
#include <iomanip>
using namespace std;

int main () {
  int i = 95;
  cout << hex << i << endl;
  cout << i << endl;
  float price = 2.00;
  cout << fixed << showpoint << setprecision(2) << price << endl;
}
$ g++14 manip.cc 
$ ./a.out
5f
5f
2.00
```
- `dec/oct/hex` feature is "sticky" as in once it's set it continues to print in that base until we change it again
- `showpoint` is used to force printing of decimal point in our floating point number
- `setprecisions` specifies number of digits after the decimal point to print, uses `0` as the fill character

## Strings

| C | C++ | 
| --- | --- | 
|array of character: `char *` or `char []` | *type is `std::string` and requires inclusiong of `<string>` library|
| memory needs to be explicitly managed. Need to shrink and grow array explicitly | manages memory for you | 
| Easy to accidently overwrite `'\0'` and corrupt memory | safer to manipulate | 
| `char  * s = "hello"; char name [10] = "Jane\0";` | `std:: string s = "hello"; string name{ "Jane" };` | 
- note the literal "hello" that is on the right side of s in the c++ assignment is actually a C constant character pointer which is passed to initialize in `s`

### Operations
these are a few of the common string oeprations/operators 
- equality: `s1 == s2`
- inequality: `s1 != s2`
- comparison: `s1 <= s2, s < s2, s1 >= s2, s1 > s2`
    - comparison are *lexicographic*
- length: `s1.size()` or `s1.length()`
- fetch individual characters: `s1[0], s1[1], ...`
    - starts at `0` and goes to `s1.size() - 1`
- concatenation `s1 = s2 + s3; s3 += s4;`

### Input/Output

- `>>` skips initial whitespace when reading `std::string`
- `getline` takes an input stream as a parameter
- `getline` does **not** skip initial white space 
- `getline` can be coerced to return a boolean value

## String streams

There is `stringstream` type which is a hybrid of a string class and I/O stream class. It lets you read/write to/from strings using stream operators. 
- you can use `stringstream` for input or output its recommended to use `istringsream` or `ostringstream` as appropriate. 

### Input string streams

The primary purpose of an input string stream is to take an existing string and split it into separate words. 
- `isstringstream` separates the words by whitespace

```c++
#include <iostream>
#include <sstream>
#include <string>
using namespace std;

int main () {
    string s;
    string s1{ "The quick brown fox\njumped over the lazy\t dog." };
    istringstream ss1{ s1 };
    while ( ss1 >> s ) {
         cout << s << endl;
    }
    string s2{ "Smith,Jane,99999999,Yu,Yaoliang,99999998" };
    istringstream ss2{ s2 };
    cout << "***" << endl;
    while ( getline( ss2, s, ',' ) ) {
         cout << s << endl;
    }
}
```
- *we use `getline` to specify a delimiter to separate our string based on commas for `s2`

### Output string streams
There is almost no reason to use an output string stream object in this course (CS246)
- with the exception of converting integer values to strings for a library such as X11 

```c++
#include <iostream>
#include <string>
#include <sstream>
using namespace std;

int main () {
  ostringstream ss;
  int lo {1}, hi {100};
  ss << "Enter a # between " << lo << " and " << hi;
  string s {ss.str()};
  cout << s << endl;
}
```
- s contains "Enter a # between 1 and 100"

## Command-line arguments 

Command-line arguments in C++ are the same as in C: The `main` function may take two arguments, `argc` and `argv` 
- `argc` is the number of of arguments the program received
- `argv` is the array of arguments
- unfortunately they are no difference than in C! so it's of type `char **` not an array of strings

```c++
#include <iostream>

int main(int argc, char **argv) {
  for (int argi = 0; argi < argc; argi++) {
    std::cout << argv[argi] << std::endl;
  }
}
```
- just like in c `argv[0]` is the name of the program itself

## Functions

functions in C++ are very similar to C. Basic format: 
```c++ 
return-type function-name( type1 arg1, type2 arg2, ... ) {
    ...
    return value of appropriate type;
}
```

### Forward declarations

You should already know to separate a function into its **declaration** (signature) and its **definition** (implementation)

You must call functions only after they have been **declared** but you can **define** them wherever. 

## Overloading

C++ allows for functions to be **overloaded&& which means more than one function can have the exact same name so long as the number of arguments and/or their types is different. 

Note: the decision as to which function must be called must be made at compile-time

The compiler does **not** distinguish between overloaded functions based on return types
- this makes sense, because if they're exactly the same other than return which do you use? 

### Default parameters

Sometimes you want a function to behave the a way most of the time unless specified otherwise through a parameter.          
We can do this with overloading, but then we'd have to maintain two functions, instead we use default parameters. 

function declaration: 
```c++ 
void processInput( bool log = false ); 
```
- this means that the parameter will be set to false when it is called without the parameter explicitly specified

**Note:** All parameters with default values must come **after** those without. 

## Structures

*C*: 
```c 
typedef struct Node_t {
    int value;
    struct Node_t * next;
} Node;

Node * head = NULL;
Node n;
n.value = 5;
n.next = NULL;
```
*C++*:
```c++
struct Node {
    int value;
    Node * next;
};

Node * head = nullptr;
Node n{ 5, nullptr }, n1 = { 6, head };
```
- C++ doesn't require that the type definition start with keyword `typedef`
- `struct` doesn't need to repeated in all variable declarations. Just needs to be done once in the initial type definition
-  C++ no longer uses `NULL` instead you should use `nullptr`
- there is no "short version" of teh type name before closing the semicolon
- there must always be a closing semicolon, after the closing `}`

Here is an **incorrect** example: 
```c++
struct Node {
    int value;
    Node next;
};
```
- this is because `Node` is not defined until the end of the closing bracket. You can use a pointer since they all have the same size


## Constants

We can define **immutable** values with teh `const` keyword. A common convention is to name cosntant values using all capital letters: 
```c++
const int MAX_GRADE = 100; 
const double MATH_PI = 3.14159;
```

you can also declare more complext types as constant such as a `struct`

## Parameter passing

If we want to write a function that increments a value without having to assign its return value we need to pass the variables adress and directly modify it.           
Normally we are only passing the value of a variable and any modification within the function does not affect it, this is called **call-by-value**

```c++
void inc( int * n ) { ++*n; } // same as *n = *n + 1;
...
inc( &value );
```
- this allows for `inc(x)` to work 

## References

References are a very important topic you should understand them well. 
- in this course, you should generally pass by reference rather than by pointer as much ass possible
    - that way you don't have to remember to dereference your pointers all of the time. 

Let's introduce the concept of **rvalues** and **lvalues** (left and right)
- if you can take the address of an expression it's an **lvalue**, otherwise it's an **rvalue**
- **lvalue** can appear on the left hand side of an assignment

for example : 
```c++ 
int x = 5;
int * ptr = nullptr;
```
- x and ptr are both **lvalues**

A **reference** is an *lvalue* that acts like a constant pointer but the compiler automatically dereferences it. Since it's constant it **must** be initialized when it is defined. 
```c++ 
int x = 5;
int &y = x;
int * ptr = &y;
y += 2;
*ptr += 3;
std::cout << x << std::endl;
```
- `*ptr` contains the address of `x` 

There are a number of things that **cannot** be done with an **lvalue reference**
1. cannot leave them uninitialized `int &x;` is illegal, must be initialized with an **lvalue**
2. cannot create a pointer to a reference `int &*x;` is illegal
    - but a reference to a pointer is legal
3. cannot create a reference to a reference `int &&x;` does not mean "reference to reference" we will see what it actually means later 
4. cannot create an array of reference `int $refAarray[3] = {x, y, z}`

let us revise the increment program: 
```c++ 
#include <iostream>
using namespace std;

void inc(int &n) {
  n = n + 1;
}

int main () {
  int x {5};
  inc(x);
  cout << x << endl;
}
```
passing by value requires "copying" the value into the function which can be expensive for large data, so to incerase efficiency we can pass a **constant reference** which will allow us to read the data but not mutate it. 

**Advice:** pass by const ref over pass by value for anything larger than an integer unless the function needs to make a copy anyways. 

**Warning:** if you want to pass a literal integer it must be defined as a constant reference. 

`f(5)` would not work with `int f( int & n ) { ... }`       

`f(5)` works with `int f( const int & n ) { ... }`       

## Dynamic memory allocation

| C | C++ |
| --- | --- | 
| uses a library `cstdlib` now known as `stdio.h` that provides `malloc`,`calloc`,`realloc` and `free`. Only works with type `(void*)` so **not** type safe | uses keywords `new` and `delete`. Type safe, i.e. allocates space appropriate of size and return a  pointer of the appropriate type | 

```c++
#include <iostream>

struct Node {
   int data;
   Node * next;
};

int main() {
   Node n{ 5, nullptr };
   Node * np = new Node{ 3, &n };
   std::cout << n.data << ' ' << np->data << std::endl;
   delete np;
}
```

**Warning:** if you fail to delete dynamically allocated memory you have a **memory leak**. It is considered incorrect in this course since it will eventually fail. 

### Dynamic array allocation

```c++ 
Node * nodeArray = new Node[10];
...
nodeArray[0].data = 5;
nodeArray[0].next = nullptr;
...
delete []  nodeArray;
```
- must specify `[]` after `delete` otherwise it will only delete the first element and cause a **memory leak**
    - match your `new` and `delete` statements, if one used `[]` the other should too 

### Pointers and optional files

`./test [ input-file-name [output-file-name] ]` it is unix convention to specify (in documentation) optional arguments by enclosing them in `[]`

it is common to have programs default to `stdin` or use files if supplied in arguments. 

Here is a good example of how to handle this: 

```c++
#include <iostream>
#include <fstream>
#include <string>

void usage( char * pgmname ) {
    std::cerr << pgmname << " [ input-file-name [output-file-name] ]" << std::endl;
} // usage

int main( int argc, char * argv[] ) {
    std::istream * infile = &std::cin;
    std::ostream * outfile = &std::cout;

    if ( argc > 3 || argc < 1 ) {
        usage( argv[0] );
        return 1;           
    } // if

    switch( argc ) {
        case 3:
            outfile = new std::ofstream{ argv[2] };
            if ( outfile == nullptr || outfile->fail() ) {
                delete outfile;
                std::cerr << "ERROR: unable to open output file \""
                    << argv[2] << '"' << std::endl;
                return 1;
            } // if
            // fall through to open up the input file next
        case 2:
            infile = new std::ifstream{ argv[1] };
            if ( infile == nullptr || infile->fail() ) {
                if ( outfile != &std::cout ) delete outfile;
                delete infile;
                std::cerr << "ERROR: unable to open input file \""
                    << argv[1] << '"' << std::endl;
                return 1;
            } // if
            break;
        default:
            // do nothing
            break;
    } // switch

    // Echoes the input to output.
    std::string line;
    while ( std::getline( *infile, line ) ) {
        *outfile << line << std::endl;
    } // while

    // Closes the I/O files. Don't delete if standard input or output, though.
    if ( infile != &std::cin ) delete infile;
    if ( outfile != &std::cout ) delete outfile;
} // main
```

## Returning information

There are three ways a function can return values; 
1. return by *value*
2. return by *pointer* 
3. return by *reference*

let's see examples of the three using the structure: 
```c++ 
struct Node {
  int data;
  Node * next;
};
```

**Return by value**
```c++
Node getMeANode( int value ) {
   Node n{ value, nullptr };
   return n;
}
```
**Return by pointer**
```
// THIS CODE IS INCORRECT
Node * getMeANode( int value ) {
   Node n{ value, nullptr };
   return &n;
}
```
- this is return an adress of a local variable which is popped from the stack when the function ends
The correct way: 
```c++
Node * getMeANode( int value ) {
   Node *nptr = new Node{ value, nullptr };
   return nptr;
}
```

**Return by reference**
```c++
Node & getMeANode( int value ) {
   Node *nptr = new Node{ value, nullptr };
   return *nptr;
}
```
- the problem is that the user won't know that it allocates in the heap and that they must `delete` what's allocated

```c++
Node & newNode = getMeANode( 5 );
...
// do something with newNode
...
delete &newNode;
```
- when deleteing a reference value we must get it's address since `delete` only works on pointers

**Which technique should we use**
- in some cases returning a pointer is fine, however in most situations it turns out that return by value is the right thing to do since as of C++11 (and up) it's not as expensive as it looks

## Operator overloading

we can also overload operators such as `+`,`-`,`*`,`/`, etc. in C++. 
```c++
struct Vec {
   int x, y;
};

Vec operator+( const Vec & v1, const Vec & v2 ) {
   Vec v{ v1.x + v2.x, v1.y + v2.y };
   return v;
}

int main() {
   Vec v1{3, 4}, v2{6, 7};
   Vec v3 = v1 + v2;
}
```
We can multiply a vector by an integer
```c++
Vec operator*( const Vec & v, const int k  ) {
   return { k*v.x, k*v.y };
}
Vec operator*( const Vec & v, const int k  ) {
   return k * v;
}
```
- without the second operator overload we would only be able to write `(v * k)` so we have to define it both ways

### Overloading << and >> 
```c++ 
struct Grade { 
    int theGrade; 
};
```
We want the output operator the print the value then a '%' sign
```c++ 
std::ostream & operator<<( std::ostream & out, const Grade & g ) {
   out << g.theGrade << '%';
   return out;
}
```
Rules for output operator: 
1. the return type is always `std::osteram &`
2. the function name is always `operator<<`
3. the first parameter is always the output stream `std::ostream &`
4. the second parameter is always the information being output
5. write the `return` statement to return whatever the name of the output stream is

```c++
std::istream & operator>>( std::istream & in, Grade & g ) {
   in >> g.theGrade;
   if ( g.theGrade < 0 ) g.theGrade = 0;
   else if ( g.theGrade > 100 ) g.theGrade = 100;
   return in;
}
```

Rules for input operator: 
1. the return operator is always `std::istream &`
2. the function operator is always `operator>>`
3. the firs parameter is always the input stream `std::istream &`
4. the second parameter is always the information being read in. 
5. write the `return` statement to return whatever the name of the input stream 

templates: 
```c++ 
std::ostream & operator<<( std::ostream & out, const typeToPrint & value ) {
   out << v ; // whatever is appropriate for the type you are outputting
   return out;
}
std::istream & operator>>( std::istream & in, typeToRead & value ) {
   in >> v ; // whatever is appropriate for the type you are reading in
   return in;
}
```

# Preprocessing and Compilation

## The preprocessor

The **C preprocessor** is tasked with handling **preprocessor directives**, it's primary purpose is to control what code is included in your program. 

the `-E` flag with g++ will make the preprocessor output to standard out

the preprocessor can also define constants `#define GEESE 15` however in modern C++ and C this is unneeded and you should use `const` definitions since they are more type-safe.

the `#if` (ends with `#endif`) controls whether code is included (controlled by preprocessor).              
Here is an example of debugging using `#if`
```c++
$ cat debug.cc 
#include <iostream>
using namespace std;

#define DEBUG_LEVEL 1

int main() {
#if DEBUG_LEVEL >= 1
    cout << "main has started" << endl;
#endif
    cout << "Hello, world!" << endl;
#if DEBUG_LEVEL >= 2
    cout << "About to end main" << endl;
#endif
    return 0;
}
```

`#ifdef` and `#ifndef` check if a preprocessor variable is set: 
```c++
 [...]
#ifdef DEBUG
  cout << "Debugging activated (I don't care what level)" << endl;
#endif
```

`#if 0` can be used to comment out large amounts of code since it nests properly unlike comments

preprocessor variables can be given in the command line to `g++`, e.g. `$ g++ -std=c++14 debug.cc -DDEBUG_LEVEL=2 -o debug`

## Separate compilation
- **declaration**: asserts that a function or variable exists, but does't define its content
- **definition**: full details on a function or variable. Defines a function's content and allocates space for both functions and variables

We split our code into two components: 
- **interface**: declarations including function prototypes, with no actual code, as well as type definitions. Put in a separate file from the actual code, typically named wih `.h` (for "header")
- **implementation**: the full definition for every function, as well as space for any global variables. In this course, typicall named `.cc`. C files are always named `.c`

The real power in separating our implementations is by having **separate compilation** this is useful for very large projects where compiling the entire project for one change would take a very long time. 
```
$ g++ -c main.cc
$ g++ -c vec.cc
$ g++ main.o vec.o -o vecs
$
```
- the `-c` compiles to an **object file** which is compiled code but not enough for a full program.
- combining multiple `.o` files is called **linking**

if we only change something in main we don't have to recompile the entire project: 
```c++ 
  [... change main.cc ...]
$ g++ -c main.cc
$ g++ main.o vec.o -o vecs
$
```

header files can only have declarations so we need to declare a variable in the header file with `extern type name` then define the varaible in an implementation file.

## Make and makefiles


there is a tool to automate linking, `make`         
a simple makefile for our previous example program is 
```make
vecs: main.o vec.o
	g++ main.o vec.o -o vecs

main.o: main.cc vec.h
	g++ -std=c++14 -c main.cc

vec.o: vec.cc vec.h
	g++ -std=c++14 -c vec.cc
```
- this must be placed in a file named "Makefile"
- the lines not indented are *dependencies*
    - the show that the file before the colon depends on the file after the colon
    - each file is a **target** (something Makefile describes how to create)

**note:** the commands to create a target must be indented with tabs, even if you normally use spaces

the command to create any given target is called a **recipe**

to use the make file we only need to use the command `make`
```
$ make
g++ -std=c++14 -c main.cc
g++ -std=c++14 -c vec.cc
g++ main.o vec.o -o vecs
$
```
- `make` automatically only rebuilds what is needed based on what we changed

we can clean up unwanted side effects of building through a **phony target** (a target that only exists for its recipe and doesn't actually build anything)
```
$ cat Makefile 
vecs: main.o vec.o
	g++ main.o vec.o -o vecs

main.o: main.cc vec.h
	g++ -std=c++14 -c main.cc

vec.o: vec.cc vec.h
	g++ -std=c++14 -c vec.cc

.PHONY: clean

clean:
	rm *.o vecs

$ make clean
rm *.o vecs
$
```

we can reduce clutter in our `Makefile` by using **make variables**
```
$ cat Makefile 
CXX=g++
CXXFLAGS=-std=c++14
OBJECTS=main.o vec.o
EXEC=vecs

${EXEC}: ${OBJECTS}
	${CXX} ${OBJECTS} -o ${EXEC}

main.o: main.cc vec.h
vec.o: vec.cc vec.h
.PHONY: clean

clean:
	rm ${OBJECTS} ${EXEC}

$ make 
g++ -std=c++14   -c -o main.o main.cc
g++ -std=c++14   -c -o vec.o vec.cc
g++ main.o vec.o -o vecs
$
```

the `-MMD` flag for g++ makes it create `.d` files which are `make` dependencies so that we can keep track of what our dependencies are. 
```
$ cat Makefile 
CXX=g++
CXXFLAGS=-std=c++14 -MMD
OBJECTS=main.o vec.o
DEPENDS=${OBJECTS:.o=.d}
EXEC=vecs

${EXEC}: ${OBJECTS}
	${CXX} ${OBJECTS} -o ${EXEC}

-include ${DEPENDS}

.PHONY: clean

clean:
	rm ${OBJECTS} ${DEPENDS} ${EXEC}
$ 
```
`make` is capable of a lot more, but this is sufficient to build most normal C++ projects*

# Object Oriented Programming
## Introduction
### Classes
#### Coupling and cohesion
There are two important measurements of software design quality, **cohesion** and **coupling**      

**Cohesion** measures the amount of "relatedness" that a module or unit of code contains. we want there to be a "high degree" of cohesion. 
- for example the `stdio` library contains input and output functions so it's highly cohesive

**Coupling** measures the amont of dependency *between* units/modules. We want the amount of coupling between modules to be low, this is because the more dependency each module has the more likely a change in one will cause a change in the other. 
- so we want our code modules to be as "independent" as possible so that a potential change in one module does not impact many others 

#### Applying these principles
In C we can combine related data together in a structure. In C++ we can also combine *functions* and *data* together using the `struct` keyword. This improves cohesion.
- functions inside a structure are now called, **operations**, **methods** or **member functions** which are in the data structure called a **class**
- a **class** is a *type* and an *instance* of a class is called an **object**
- in C++ we can also add functions to a `struct`

Here is an example using `struct`:      
`student.h`
```C++
#ifndef _STUDENT_H_
#define _STUDENT_H_

struct Student { 
    int assns, mt, final; 

    float grade(); 
};

#endif
```
- we see there is a single method `grade` which takes no parameters and returns the final grade
`studnet.cc`
```C++
#include "student.h"

float Student::grade() { 
    return assns * 0.4 + mt * 0.2 + final * o.4; 
}
```
- we use the **scope resolution operator** `::` prefixed by the class name to specify that the `grade` function is a **method** of the `student` class
- `C::f`
    - for some class `C`, `f` is in the context of `C`
`main.cc` the *client code* 
```C++
#include "student.h"
#include <iostream> 
int main() { 
    Student s{ 60, 70, 80 }; 
    std::cout<< s.grade() << std::endl;
} 
``` 
- we use an **initialization list** where the compiler automatically maps the values to the order they were declared

All class methods have a hidden first parameter called **this** which is a pointer of class type and points to the object which the method is being invoked upon.       
We can rewrite our previous code as 
```C++ 
float Student::grade() { 
    return this->assns * 0.4 + this->mt * 0.2 + this->final * 0.4; 
} 
```
**Warning** some people hate the use of `this` unnecessarily and feel it should only ever be used when needed to disambiguate parameter or method calls since it clutters up the ocode. 
- in this course we will only use it when absolutely necessary 

#### Initializing objects         

C++ classes have a special type of method called a **constructor**
- which guarantees that an object is always initialized upon creation

```C++
Name-of-Class-Type( parameter-list ) { 
    // necessary code 
} 
```
- there is no return type
- the method is the type name 
- the parameter list may be empty
- constructors can be overloaded 
- method body may be empty, but must be present

So using constructors our new implementation file becomes
```C++
#include "student.h"

int capGrade( int grade ) {
   if ( grade < 0 ) return 0;
   if ( grade > 100 ) return 100;
   return grade;
}

Student::Student( int assns, int mt, int final ) {
   this->assns = capGrade( assns );
   this->mt = capGrade( mt );
   this->final = capGrade( final );
}

float Student::grade() {
  return assns * 0.4 + mt * 0.2 + final * 0.4;
}
```
- our header file will need to account for the constructor as well 
- notice we need to use `this` to differentiate between the parameters and the actual data field names

The preffered syntax in modern C++ is **uniform intialization syntax** and is of form: 
```C++ 
Student s{ 60, 70, 80 };
int x{ 5 };
std::string word{ "hello" };
Node * ptr = new Node{ 10, nullptr };
```

we can overload our constructors
- have different constructors with different parameters

we can use default parameters on our constructors, these go in the interface and **not** the implementation file. 

## Special Class Members
### Default constructors

By definition a **default constructor** is a constructor that has 0 parameters. 

If you do not define any constructor to your class the compiler will give you a defualt constructor. 
- all it will do is call the default constructor on any data fields in your object that are themselves objects

### Initializing constants and references
what if we want to intialize constants in an object (for example student id in a student object)
- we can't just provide the value in the constructor since they const is already created and can't be modified

so we use 
#### Member initialization lists (MIL)
after the parenthesis of a constructor we add a `:` followed by a list of data field names to be initialized
```C++
#include "student.h"

int capGrade( int grade ) {
   if ( grade < 0 ) return 0;
   if ( grade > 100 ) return 100;
   return grade;
}

Student::Student( const int id, int assns, int mt, int final ) 
   : id{ id },
     assns{ capGrade(assns) }, 
     mt{ capGrade(mt) }, 
     final{ capGrade(final) }
{}

float Student::grade() {
  return assns * 0.4 + mt * 0.2 + final * 0.4;
}
```
- the name outside of `{}` in the MIL is the data field, the name inside is the parameter name
- the MIL can be used to initialize other data fields not just constants or references
- fields in the MIL are intialized in the order in which they are declared in the class, **not** in the order that they are listed in the MIL
- using MIL is more efficient for data fields which have a default constructor since it takes precedance over intialization in the class so it avoids initializing a data feild twice
- MIL can only be used on constructors

It is normally considered poor practice to use the body for anything the MIL could have done

#### Copy constructors
There are other methods the compiler provides if you don't provide your own 
1. default constructor: calls the default constructor on all fields that are objects
2. copy constructor: copies all fields from the object passed in 
3. copy assignment operator: copies all fields from the object passed in 
4. destructor: does nothing by default
5. move constructor: takes data from the object passed in 
6. move assignment operator: takes data from the object passed in 

a copy constructor has a parameter which is a constant reference to an object of the same type 
```C++
Student( const Student & other ) 
      : assns{other.assns}, mt{other.mt}, final{other.final} {}
```
- example of a copy constructor 

The default copy constructor does not work when we want to copy a dynamically allocated data structure. 
- for example if we copied a linked list it would create a **shallow copy** since it would copy the first node which is linked to the same other nodes
    - the end result is that we did not create a new linked list that is independent so we need to define our own copy constructor if we want to create a **deep copy**

```C++
Node(const Node &n) {
   data = n.data;
   if ( n.next != nullptr ) {
      next = new Node{ *n.next };
   } else {
      next = nullptr;
   }
}
```
- here is a possible copy constructor for our linked list

For now, we are going to say that a copy constructor is called when an object: 
1. is initialized by another object
2. is passed by value
3. returned by value
    - we will see exceptions to these cases later

### The Peril of single-argument constructors
By definition a single argument constructor **implicitly convert** an argument of the specified type into an object of the construcor type. 

```C++
struct Node {
   ...
   Node( int data ) : data{data}, next{nullptr} {}
};

int f(Node n) {...}

Node n1{4}; // single-argument ctor call
Node n2 = 4; // implicit conversion from int to Node via single-arg ctor
f( 4 ); // 4 implicitly converted to a Node
```
- beware of the conversionn happening here as it can cause errors

if we want to disable implict converstion we can lable all single-argument constructors with the `explicit` keyword

```c++
struct Node {
  int data;
  Node *next = nullptr;
  explicit Node(int data) : data{data} {}
  Node(int data, Node *next): data{data}, next{next} {}

  Node(const Node &n): data{n.data},
                       next{n.next ? new Node{*n.next} : nullptr} {}
};

Node myNode = 4; // Causes an ERROR
```
- we would have to expicitly create a node with `Node myNode = Node{4};`

## Destructors
The destructor provided by the compiler does nothing but call destructor of data fields which are objects

the steps that occur when a destructor is run are: 
1. run the body of the destructor
2. invoke destructors for the object's data fields that are themeslves objects. This occurs in reverse declaration order.
3. Deallocate the space associated with the object

the signature for a class destructor follows the format: 
```c++
~class-name(); 
```

Header file
```C++
struct Node {
  int data;
  Node *next;
  Node(int data, Node *next);
  Node(const Node &n);
  explicit Node(int n);
  ~Node();
};
```
Here is the destructor as it would appear in the implementation file
```C++
Node::~Node() {
    delete next;
}
```

## Copy assignment operator
We can copy an object by assigning it to another object. This uses the **copy assignment operator** which performs a *shallow copy* of the data fields just like the implicit copy constructor. 
- we need to define our own if we wanty to perform a *deep copy*

the name of the operator is `operator=` and by definition it takes a constant reference of the class type as its single parameter. 
- it returns a reference of the class type since it needs to work if its part of a cascade/sequence of assignment operations

```C++
class-type & operator=( const class-type & parameter-name );
```

Here is an example of a copy assignment operator implementation
```C++
Node & operator=( const Node & other) {
   if ( this == &other ) return *this;
   data = other.data;
   Node * tmp = other.next? new Node{ *other.next } : nullptr;
   delete next;
   next = tmp;
   return *this;
}
```

### Copy-swap idiom
There is another approach by using the **copy-and-swap** idiom where we create a local copy which is automatically destroyed. and if it is succesfully created we swap using `std::swap`
```c++
#include <utility>
struct Node {
   ...
   void swap( Node & other ) {
      std::swap( data, other.data );
      std::swap( next, other.next );
   }
   
   Node & operator=( const Node & other) {
      Node tmp{ other };
      swap( tmp );
      return *this;
   }
   ...
};
```

## Move semantics
There are situations (such as passing an argument as a parameter) where the compiler will need to create a temporary object and then later copy this object to create the final result. 
- the compiler realizes its wasteful to copy information so the compiler optimizes by just "stealing" the information instead this is called **move/copy elision**
    - in order to do this we need to pass the object as an **rvalue reference** (`type&&`) which tells the compiler to not perform the whole move/copy
### Move constructor
The introduction of an rvalue reference now lets us declar a constructor which takes in an rvalue reference.

Ad **move constructor** is designed to steal the information from the rvalue passed into the constructor 
```c++ 
class-type( class-type && parameter-name ) {...}
```
- this constructor saves us that temporary object we copied earlier

The rvalue passed through is eventually destroyed by the call for its destructor so we have to ensure that we save the information we need.             
In the example of the node structure we have: 
```C++
struct Node {
    ...
    Node( Node && other );
    ...
};

...

Node::Node( Node &&other ) : data{other.data}, next{other.next} {
    other.next = nullptr;
}
```
### Move assignment
**Move assignment** is similar to copy assignment. We need to make sure we don't leak memory.
- we can exchange our old information with new information from the rvalue, guaranteeing that it'll be cleauned up when the rvalue's destructor is run
```C++
struct Node {
    ...
    Node & operator=( Node &&other );
    void swap( Node &other );
    ...
};
 
...

Node & Node::operator=( Node &&other ) {
    swap(other);
    return *this;
}

void Node::swap(Node &other) {
    std::swap( data, other.data );
    std::swap( next, other.next );
}
```

## Rules for replacing default compiler operations

|---|---|--|
|Default constructor|	if no other constructors|	does nothing|
|Destructor|	if no destructor|	does nothing|
|Copy constructor|	if no move constructor and no move assignment|	copies all members|
|Copy assignment|	if no move constructor and no move assignment|	copies all members|
|Move constructor|	if no destructor, no copy constructor and no copy nor move assignment|	moves all members|
|Move assignment|	if no destructor, no copy constructor and no copy nor move assignment|	moves all members|

This leads us to the rule of 5, generally if u define one of the following u will need to define the rest
1. copy constructor
2. copy assignment operator
3. destructor
4. move constructor
5. move assignment operator

## Member operators
if we are invoking an operation, the object **must** be on the left hand side

```C++
struct Vec {
   int x, y;
   
   Vec operator+( const Vec & other ) {
      return {x + other.x, y + other.y};
   }
   
   Vec operator*( const int k ) {
      return { x * k, y * k };
   }
};
```
- this definition of the operator requires us to have the vector on the left hand side
- the only way we can have a version which allows us to have the vector on the right hand side as well is to define it outside of the class 

**Must be class members:**
- constructors
- destructors
- operator=
- operator[]
- operator->
- operator()
- operator T()

**Must not be class members**
- operators whose first parameter isn't an object of the class type. In particular, I/O operators

## Static Members
If we want to have values which are the same across all objects of a certain type (value belongs to the class rather than the individual objects), for example the number of students, then we need to use a static member. 

**Static members** are associated with the class itself and not any particular instance of the class: 
```c++ 
// In student.h
struct Student {
    . . .
    static int numInstances;
    Student(int assns, int mt, int final): assns{assns}, mt{mt}, final{final} {
        ++numInstances;
    }
};

// In student.cc:
int Student::numInstances = 0;
```

**Static member functions:** don't depend on a specific instance for their computation (they don't have an implicit `this` parameter).
- they can only access static fields and call other static member functions
```c++
// In student.h:
struct Student {
    int assns, mt, final;
    static int numInstances;
    . . .
    // The static method howMany() can access the static field numInstances.
    // However, it cannot access the instance fields assns, mt, final.
    static void howMany() {
        cout << numInstances << endl;
    }
};

// In main.cc:
Student billy {60, 70, 80}, jane {70, 80, 90};
Student::howMany(); // 2
```
- notice how the method is called on the `Student` class, and not on any object

# Advanced object use
## Object arrays
To create an array of objects the class must provide a default constructor, otherwise it's a syntax error

This cannot be used in an array: 
```C++
struct Vec {
   int x, y;
   Vec( int x, int y );
};
```
However this **can** be used in an array: 
```C++
struct Vec {
   int x, y;
   Vec( int x, int y );
};
```

If the class we're working cannot/should not introduce a default constructor, then the only alternative is to create an array of pointers to the class type

## Constant Objects
**Constant object** (const object) is an object whos fields cannot be modified. 
- we can define a constant object `const className obj` or pass the object as a constant `f(const className &obj)`
- we can only call methods which have `const;` added to their signature on constant objects because that promises that the fields won't be modified
for example:
```C++
// const is part of a function's signature, so it must be written in both .h and .cc
float Student::grade() const {
    return assns * 0.4 + mt * 0.2 + final * 0.4;
}
```
- if we call a method which modified a field on a constant object then it will cause an error

### Mutable fields
```C++
struct Student {
    . . .
    mutable int numMethodCalls = 0;
    float grade() const {  // can be const now
        ++numMethodCalls;  // OK now
        return . . . ;
    }
};
```
Say we want to track how many times a method is called to track performance. The variables which counts the number of times the method is called only affects the **phyiscal constness** of the object rather than the **logical constness** (its value changing does not affect any of the logic an outside user would observe). 

We can define `mutable` fields which means the can be changed even in constant objects
- we cannot implement the above without this because the methodCalls counter would not work on a const object

### Best practices
- if you know a method will not affect any internal fields then always declare the method as `const`
- whenever declaring a method which recieves objects as parameters and it will not change the contents of the object then declare parameters as `const` so that constant objects can be passed to it
- if you have fields that must be modified even for constant objects define them as mutable
- whenever you create (instantiate) an object whose values should not change later then declare it as constant 

# Invariants and Encapsulation
Sometimes we need to enforce certain proper use of classes or other things in our code so that errors cannot be introduced. For example: 
```C++
struct Node {
    int data;
    Node *next;
    Node (int data, Node *next): data{data}, next{next} {}
    . . .
    ~Node() { delete next; }
};


int main() {
    Node n1 {1, new Node{2, nullptr}};
    Node n2 {3, nullptr};
    Node n3 {4, &n2};
}
```
- when the destructor for `n3` is called it can cause the program to crash since it is trying to delete an object in the stack not the heap. 
- so we need to enforce that a node is declared either to a valid location in the heap or a `nullptr`

## Encapsulation

We can regain control of our classes through **encapsulation**, by setting the **access modifier** or **visibility** for each one of the members of a class. 
- **private** class members can only be accessed from within the object (i.e, using the implicit `this` pointer of the object's methods)
- **public** class members can be accessed from anywhere

For example: 
```c++ 
struct Vec {
    Vec (int x, int y); // By default, members are public
  private: // What follows is private; cannot be accessed outside struct Vec
    int x, y;

  public: // What follows is public; accessible to all
    Vec operator+(const Vec &other);
    . . .
};
```
- once we use an access modifier all members after it are assigned to that modifier until the other one is declared
    - so we can write private once at the top to have all members as private
- by default in a struct members are *public*

## The `class` Keyword

By default all members of structs are public, but in general we want fields to be private and only methods should be public. So it would be better if the default visibility way private. 

We achieve this with the `struct` keyword
- the only difference between `struct` and `class` is the defualt visibility
```c++ 
class Vec {
    int x, y; // These are private.
  public:
    Vec (int x, int y);
    Vec operator+(const Vec &other);
    . . .
};
```
- since in most cases we want default visibility to be private it is best practice to use class and only change necessary things to public

## Accessor and Mutator Methods

Since fields of objects are private, we use **acessor** and **mutator** methods to read and change the values. 
```C++
class Vec {
    int x, y;
  public:
    . . .
    int getX() const { return x; } // accessor
    void setX(int z) { x = z; }    // mutator

    int getY() const { return y; } // accessor
    void setY(int z) { y = z; }    // mutator
 };
 ```
 - since the fields get and set the value it is convention to name them `getField` and `setField`
    - they are sometimes called getters and setters
- since accessor methods should not modify any state they should be decalred as `const`

### Enforcing encapsulation with accessors and mutators
We should only create accessors and mutators when necessary. If certain invariants are needed for mutators they are implemented in the mutator methods (for example grade must be between 0 and 100) 

here is a fixed implementation of our linked list class
**list.h:**
```c++
class List {
    struct Node;             // Private nested class; only accessible inside List
    Node *theList = nullptr; // Must be nullptr or pointer to heap-allocated object
  public:
    void addToFront(int n);  // Adds an element to the front of the list
    int ith(int i);          // Retrieves the element in the ith position of the list
    ~List();
};
```
**list.cc**
```c++
struct List::Node { // Nested class
    int data;
    Node *next;
    Node (int data, Node *next): data{data}, next{next} {}
    ~Node() { delete next; }
};

List::~List() { delete theList; }

void List::addToFront(int n) { theList = new Node(n, theList); }

int List::ith(int i) {
    Node *cur = theList;
    for (int j = 0; j < i; ++j, cur = cur->next);
    return cur->data;
}
```
- note that Node is now a nested class (the client cannot directly create a node) this allows us to prevent errors we discussed earlier
- invariants should be documented in the source file or another standard document used by the organization

## Friend Classes

In our implementation of node the client cannot access nodes directly and must call `ith` function many times to find it which costs O($n^2$) time.             
We can fix this by making node a public class but with the construct being private (so the client cannot create a node). 
- but this would make our list class unable to make a node too
So we use **friend** classes to allow List to have special privilages with Node

```
class List {
  public:
    class Node {   // Public nested class
        int data;
        Node *next;
        Node (int data, Node *next); // Constructor is now private!
       public:
        ~Node();
        int getData() const;
        Node *getNext() const;
        friend class List;    // List has access to all members of Node
    }
  private:
    Node *theList = nullptr;  // Private internal state
  public:
    void addToFront(int n);        // Adds an element to the front of the list
    int ith(int i) const;          // Retrieves the element in the ith position of the list
    Node *getNodeAt(int i) const;  // Retrieves the Node in the ith position of the list
    ~List();
};
```
- note that List is declared as a friend of Node. 

You should use friends as little as possible since it weakens encapsulation

## Friend Functions
```C++
class Vec { 
    int x, y; 
} 
```
- x and y are private but `operator<<` needs to see them so it must be a **friend function**
We implement it as
```C++
// vec.h
class Vec {
    int x, y;
    friend std::ostream &operator<<(std::ostream &out, const Vec &v);
};

//vec.cc
std::ostream &operator<<(std::ostream &out, const Vec &v) {
    return out << v.x << ' ' << v.y;
}
```

Once again this weakens encapsulation

# Unified Modelling Language
The **Unified Modelling Language** (UML) is a visual modelling language that lets people design and document a software system.

We will be looking onlt at the subset of notation for class models

### Class models
Martin Fowler's "UML Distilled: Third Edition" is a very good reference (focus on chapter 3 and 5)


## Class model notation
### Classes
Class models contain 3 boxes
1. containes the **class name**
    - must be unique among all classes in that scope, otherwise a scope operator is added (`Banking::CheckingAccount`)
    - The calss name must be Capitalized, centered, or left-justified, and in bold. Generally they are plural only if they are containers for multiple objects of the type
    - The class name may be qualifed with an optional stereotype keyword using guillements
        - these are not made up of << and >> but rather their own thing `controller`
2. the second box is optional, and contains **atributes**
3. the third box is optional, and contains **operations**

### Comments
A **comment** can be added to the class diagram by joining a rectangle with a bet uppr right corner ("dog ear") to the item being annoted with a dashed-line. 

### Attributes
**Attributes** are left-justified and written in the regular typeface. Describe the information held by an instance of the class and may be replaced by **association needs**

The general syntax for an attribute is: 
```
stereotype visibility / name : type multiplicity initial-value {property}
```
- visibility: describes the visibility of the attribute as a punctuation mark
    - + public
    - - private
    - # protected
    - ~ package
- type: a string that describes the attribute's type. Usually written to be as language-independent as possible (Boolean instead of Bool)
- / : indicates that this attribute is derived from a parent class
- mutliplicity: How many of these values will be held. It is enclosed in square brackets (1 if nothing is there), can describe a range ([3..10])
    - [0..1] implicitly represents a pointer in C/C++
- initial-value: Specifies the defaul intitial value as an equal sign followed by the value 
- property: list of comma-separated strings surrounded by {} which describe properties

### Operations
**operations** are left-justified and written in regular type face. They are shown when needed though a full description must be provided at least once. 
- visibility: same as for attribute
- return-type: string containing comma-separated return types. If it is empty its equivalen to C++ `void`
- Parameter-list: 
- property

**abstraction operation** is italicized. 

If the operatio is static the name and type strings are underlined

examples:
```
- display () : Location
+ hide ()
constructor + create ()
- attachXWindow( xwin : XWindow* )
# Matrix::transform (in distance: Vector, in angle: Real = 0) : Matrix
```

# Class relationships
1. aggregation
2. composition
3. generalization

## Association
Tells us very little other than that a relationship exists
## Aggregation
Describes a "whole-part" relation where the **aggregate** (or whole) is made up of the constituent parts
if A has a B then typically: 
- B exists independently outside of A
- if A is destroyed, B lives on
- if A is copied, B is not deep copied

## Composition
**Composition** is a stricter form of aggregation. Once a part is joined to a "whole" it may not be shared with any other object. 

The whole is responsible for destroying all of its component parts when it is destroyed

An example of the relation is a Point to a Polygon or a Circle (a point may belong to an object of either type but not part of borth simultaneously).

## Generalization/specialization
The **generalization** (or **specialization**) association between the parent/super class and the child/sub class is indicated by putting a triangular arrowhead on the association end that joins the parent. By definition, there is no multiplicity or navigation arrow head, though constraints may be added. There may be separate lines from the parent class to each child, or the lines may be drawn as a tree structure.

# Inheritance
## Inheritance example
Say we have 3 classes for a book, text, and comic       
- they all contain basic infor such as author, date, etc...
If we want to iterate over all instances of these 3 types we could use
- C unions
- C void pointers
- C++ inheritance
### Unions
C has a union type which holds multiple data fields of different sizes but only one data filed is available at any moment. 
- an instance of the union is allocated the number of bytes required by the largest data field in the union
```C
union ExampleUnion {
    int i;
    char c;
    float f;
};
```
Since we need to know which datafield each instance holds we would need either a prallel data structuer to keep track or wrap the union in another struct which keeps track of each instance's used data field.

### C void pointers
we essentially store the address of each data type as a `void*` and respectively cast the types back to what they originally were (i.e int* or whatever was intended).      
here is an example implementation: 
```C++
#include <iostream>

struct Element {
    void * data;
    char dataType;
};

int main() {
    Element elems[3];
    int * iptr;
    char * cptr;
    float * fptr;

    elems[0].data = (void *) new int{-1};
    elems[0].dataType = 'i';
    elems[1].data = (void *) new char{'x'};
    elems[1].dataType = 'c';
    elems[2].data = (void *) new float{3.14159};
    elems[2].dataType = 'f';
    
    for ( int i = 0; i < 3; ++i ) {
        switch( elems[i].dataType ) {
            case 'i':
                iptr = (int*) elems[i].data;
                std::cout << *iptr << std::endl;
                break;
            case 'f' :
                fptr = (float*) elems[i].data;
                std::cout << *fptr << std::endl;
                break;
            case 'c':
                cptr = (char*) elems[i].data;
                std::cout << *cptr << std::endl;
                break;
        } // switch
    } // for
} // main
```

### C++ inheritance
both of the above methods are not ideal and require extra information to be stored as well as introduce potential for erros when changing types.

C++ inheritance lets the **base**/**parent**/**super** class be a generalization of the **derived**/**child**/**sub** classes, and children have the fields and methods of their parents.           
- we could override a child's methods to change them from the parent

In our example Book is the parent class and comic/text are just specizalizations of that class (children)

The keyowrds `: public ParentClassName` after the class name tell us that they are chidlren.        
Example: 
```C++ 
class Book {
    std::string author, title;
    int length;
  public:
    Book( const std::string &author, 
      const std::string &title, 
      int length );
    std::string getTitle() const;
    std::string getAuthor() const;
    int getLength() const;
    bool isHeavy() const;
};
class Text : public Book {
    std::string topic;
  public:
    Text( const std::string &author, 
        const std::string &title, 
        int length, 
        const std::string &topic );
    std::string getTopic() const;
};
class Comic : public Book {
    std::string hero;
  public:
    Comic( const std::string &author, 
        const std::string &title, 
        int length, 
        const std::string &hero );
    std::string getHero() const;
};
```
- only an object of type Book can see Book's private fields so how do we initialize a child? 

We need to invoke the superclass constructor so that it is able to define the private fields of the superclass when the childclass is being constructed.
- but invoking the superclass constructor inside the constructor is already too late so we need to use MIL (the colon and list of declarations)

So creating a child object needs: 
1. allocate space for the object
2. invoke the superclass constructor to build the superclass portion of the object
3. construct the fields
4. run the constructor body

### Version 2
If we want to give derived classes access to a field we can declare the fields/methods as **protected**

so we can do this 
```C++
class Book {
    std::string title, author;
    int length;
  protected:
    int getLength() const;
  public:
    Book(const std::string &title, const std::string &author, int length);
    std::string getTitle() const;
    std::string getAuthor() const;
    bool isHeavy() const;
};

bool Book::isHeavy() const { return length > 200; }
bool Text::isHeavy() { return getLength() > 400; }
bool Comic::isHeavy() const { return getLength() > 30; }
```
- we see isHeavy() is protected since derived methods need to be able to call it as well
- our goal is to be able to tell if something is heavy without knowing its type

This works until we we try to set a book equal to a commic `book b = c` this will copy over the "core information" (the superclass portion) of the comic but leave out that it is a comic. 
- this means that `book b` is still a book not a comic so if we run isheavy it will not be heavy since it is a book
    - this is called **object slicing** (since we lose information copying a child intro a superclass)
We can try to fix this with pointers instead. 
- the pointer of type Book can point to a Comic
    - the adress of the pointer will hold the extra information of a comic 
- however if we invoke any method on the Book pointer it will treat the data at the adress as a Book so it will call the Book methods and thus we still run into the problem 
    - this time we are storing the extra information but our pointer is of a different type so we use the incorrect methods

### Version 3
We use virtual keyword makes a function in C++ dynamically examine the type of the pointed object (or the actual type of reference-bound object) rather than relying on declared type of the pointer. 
- when we have a virtual method in a parent class whos implementation is changed or replaced in a child class, we say it is **overriden**
- note that the method signatures must match exactly
- we can let the compiler help us catch potential errors by appending the keyword override to the **child** class signatures
example: 
```C++
class Book {
    std::string author, title;
    int length;
  protected:
    int getLength() const;
 public:
    Book( const std::string &author, 
      const std::string &title, 
      int length );
    std::string getTitle() const;
    std::string getAuthor() const;    
    virtual bool isHeavy() const;
};
class Text : public Book {
    std::string topic;
  public:
    Text( const std::string &author, 
        const std::string &title, 
        int length, 
        const std::string &topic );
    bool isHeavy() const override;
    std::string getTopic() const;
};
class Comic : public Book {
    std::string hero;
  public:
    Comic( const std::string &author, 
        const std::string &title, 
        int length, 
        const std::string &hero );
    bool isHeavy() const override;
    std::string getHero() const;
};
bool Book::isHeavy() const { return length > 200; }
bool Text::isHeavy() const { return getLength() > 400; }
bool Comic::isHeavy() const { return getLength() > 30; }
```
- notice we leave the keywords virtual and override out of the implementation
- we could also add the keyword virtual in the child classes (but it is not needed)

### Version 4
This takes the previous idea and builds a container of different types (parents and children) and then through virtual functions is able to use them properly       
example: 
```C++
// Polymorphism in action.
void printMyFavourites(Book *myBooks[], int numBooks) {
  for (int i=0; i < numBooks; ++i) {
    if (myBooks[i]->favourite()) cout << myBooks[i]->getTitle() << endl;
  }
}

int main() {
  Book* collection[] { 
   new Book{"War and Peace", "Tolstoy", 5000},
   new Book{"Peter Rabbit", "Potter", 50},
   new Text{"Programming for Beginners", "??", 200, "BASIC"},
   new Text{"Programming for Big Kids", "??", 200, "C++"},
   new Comic{"Aquaman Swims Again", "??", 20, "Aquaman"},
   new Comic{"Clark Kent Loses His Glasses", "??", 20, "Superman"}
  };

  printMyFavourites(collection, 6);
  for (int i=0; i < 6; ++i) delete collection[i];
}
```
- notice the favourite() function would be implemented differently for each of Book, Text, and Comic

## Arrays of polymorphic objects
never use arrays of objects polymorphically
- use an array of pointers instead to avoid **misaligned** data

## Polymorphism and destructors
Always make sure destructors are virtual, because if the child and parent dynamically allocate memory you must ensure that the appropriate destructor is called 
- so make your destructors virutal, even if they do nothing

## Abstract classes
What if we have a class student with subclasses Regular or Coop, but a student must be either of those. So there are no cases where we have an object of just type Student.         
Then we need Student to be an abstract class which can't be instantiated. 
- it must have at least one method that is not implemented
    - in this case fees() is not implemented since its children must override it with the appropriate regular or coop fees
    - if a method has no implementation it is a **pure virtual method**
        - a class with a pure virtual method cannot be instantiated
```C++
class Student {
    . . .
  public:
    virtual int fees() const = 0;
};
```
 non abstract classes are called concrete

### UML abstract
abstract calsses are identified by italicizing the name

# Templates
If we want to make a general list class which can work with any data type we can use a **template** 
```c++
template <typename T> class List {
    struct Node {
      T data;
      Node *next;
     . . .
    };
    Node *theList;
  public:
    . . .
};
List <int> li; 
List <string> ls; 
```
- roughly speaking, the compiler specializes the templates into actual code and then compiles the resulting code. 
**Note**: because of the way templates work , the implementation needs to go in the `.h` files rather than the implementation files

Here is an example with multiple parameters
```C++
template <typename K, V> class Dictionary {
    K key;
    V value;
    . . .
}
Dictionary<string, Student> d;
```
# Error handling with exceptions
## Introduction to exceptions
A function **raises** or **throws** and **exception** which by default stops execution but we can write **handlers** to **catch** exceptions and deal with them. 


### Throwing an exception
In C++ we can throw anything, but usual practice is to define specific exception classes. 

### Handling exceptions
we use a `try{} cath{}` block. Any exceptions raised in the try block are passed to the catch block. The catch block must specify which exceptions it handles and if the such exception is caught then the code in the catch block executes.            
If an exception is raised which does not have a matching catch block then the code terminates as if there was no catch block at all.

### Passing information in the exception
Since the exception is an object of a class we can add any fields and methods to the exception class to provide useful information for error handling. 

Example 
```C++
class InvalidGrade {
  private:
    int grade;
  public:
    InvalidGrade(grade): grade{grade} {}
    int getGrade() const { return grade; }
};

// Helper function
int checkGrade( int grade ) {
  if ( grade >= 0 && grade <= 100 ) {
    return grade;
  } else {
    throw InvalidGrade{grade};
  }
}

// In main.cc
int main () {
  try {
    Student s{ 7899, -10, 50, 150 };
    cout << "s.grade() = " << s.grade() << endl;
  } catch (InvalidGrade ex) {
    cout << "Invalid grade: " << ex.getGrade() << endl; 
  }
}
```
## Exceptions and the call chain
consider 
```C++ 
void f() {
  throw out_of_range{"f"};
}
void g() {
  f();
}
void h() {
  g();
}
int main() {
  try {
    h();
  }
  catch (out_of_range) {
    cerr << "Range error in main()" << endl;
  }
}
```
Notice that none of the functions leading to main() after the execution of h() have any handlers.       
So the execution of each function is terminated early until it reaches main where the exception is handled. 
- if main didn't have an exception handler the program would terminate
- the end of each function is not reached (because they are terminated by the thrown error)

## Partial exception handling
a handler can execute some corrective code and throw another exception. 
- this is useful if we need to perform some cleanup to avoid memory leaks, but we are unable to fully deal with the exception so we throw it for someone else to handle it

## Exceptions in destructors
**Warning:** never let a destructor throw an exception. The program will terminate. It is technically possible to have a throwing destructor, you should still never do it. If the destructor is executed while dealing with another exception you will have two active exceptions and the program will abort immediately. 

# Advanced C++
## Unique and shared pointers (smart pointers)
### unique_ptr 
a unique_ptr wraps a pointer and guaranteed to be the only pointer to the heap-allocated object in question (as long as it is used correctly).
```C++
#include <memory>

  [...]

double pointDistance(std::unique_ptr<Point>);

  [...]

double mydistance(double x, double y) {
    auto p = std::make_unique<Point>(x, y);
    // Here, we could access p->x and p->y, just as if p was a pointer
    return pointDistance(std::move(p));
}
```
- since unique_pointers are unique they cannot be copied and thus can never be passed by value and that is why we must move p

unique_ptr is deleted when it goes out of scope, but we can move the pointers to extend their lifetime past the lifetime of some scope. So they offer the lifetime of heap allocated values with the memory safety of stack variables which delete after the end of their scope. 

we can pass unique_ptr by reference. 

we can get the adress a unique_ptr points to using `get`
```C++
double pointDistance(Point *);

  [...]

double mydistance(double x, double y) {
    auto p = std::make_unique<Point>(x, y);
    return pointDistance(p.get());
}
```
- you should be careful that the pointer returned by get is not held onto after the object it points at is destroyed (when unique_ptr goes out of scope)

### shared_ptr
similar to unique_ptr in that it controls the lifetime of the object however we can have multiple shared_ptr point to the same object. 

```C++
double mydistance(double x, double y) {
    auto p = std::make_shared<Point>(x, y);
    return pointDistance(p);
}

double mydistance(double x, double y) {
    auto p = std::make_shared<Point>(x, y);
    double ret = pointDistance(p);
    ret += p->x; // No problem
    return ret;
}
```
- we can pass the shared_ptr like normal instead of having to move it 

unlike using regular pointers if an exception is thrown (or surprising control flow events) the object is still deleted when we go out of scope.

## caveats of `shared_ptr`
```C++
class GraphNode {
    public:
    GraphNode(sname) : name(sname) {}

    void addVertex(std::shared_ptr<GraphNode> to) {
        vertices.push_back(to);
    }

      [...]

    private:
    std::string name;
    std::vector<std::shared_ptr<GraphNode>> vertices;
}
void graphWork() {
    auto root = std::make_shared<GraphNode>("Node 1");
    auto n2 = std::make_shared<GraphNode>("Node 2");
    root->addVertex(n2);
    n2->addVertex(root);

      [... do some graph work ...]

    return;
}
```
The problem demonstrated here is **cyclic references** becase adding the vertex from root to n2 increases n2's reference count to 2, and when they functiong graphWork() ends the pointrs are gone out of scope but 2-1=1 not 0 so the objects are never deleted

In cases like these it is common to use regular pointers.

Another caveat is that counting reference in smart pointers is extra work and can lead to worse performance. 

Sometimes the get method is used to get the regular adress held by the pointers to avoid cyclic references or to perform performance critical sections of code without having to keep updating reference counts. 

shared_ptrs have a use_count method which returns the reference count, this should only ever be used for debugging.

## RAII: Resource Acquisition is Initialization

A principle where resources which must be explicitly cleaned up are bound to resources that are cleaned up automatically

Using the previous graph example, we bind the nodes with smart pointers to a graph class so that when the graph is destroyed all the nodes are destroyed. 
```C++
class Graph {
    public:
    std::shared_ptr<GraphNode> createNode(std::string name) {
        auto node = std::make_shared<GraphNode>(name, nodes.length);
        nodes.push_back(node);
        return node;
    }

    std::shared_ptr<GraphNode> getNode(int index) {
        return nodes[index];
    }

    void addVertex(std::shared_ptr<GraphNode> from, std::shared_ptr<GraphNode> to) {
        from->addVertex(to->getIndex());
    }

      [...]

    private:
    std::vector<std::shared_ptr<GraphNode>> nodes;
}

class GraphNode {
    public:
    GraphNode(std::string sname, int sindex) : name(sname), index(sindex) {}

    int getIndex() {
        return index;
    }

    void addVertex(int to) {
        vertices.push_back(to);
    }

    std::vector<std::shared_ptr<GraphNode>> getVertices(std::shared_ptr<Graph> graph) {
        std::vector<std::shared_ptr<GraphNode>> ret;
        for (auto index : vertices) {
            ret.push_back(graph->getNode(index));
        }
        return ret;
    }

      [...]

    private:
    std::string name;
    int index;
    std::vector<int> vertices;
}
```

## Exception Safety
```C++
void f() {
    MyClass mc;
    MyClass *p = new MyClass;
    g();
    delete p;
}
```
- if g() throws an exception p is not deleted

### solution 1: an exception handler
we can write an exception handler to catch the exception to delete p

This solution works but it is not elegant and is error-prone. If we forget the exception handler we would only find out in a test case where g() throws an exception.

### exception safety levels
generally speaking there are three levels of **exception safety** for a function f
1. basic guarantee: if an exception occurs, the program will be in some valid, unspecified state. Nothing leaked, class invariants mantained
2. strong guarantee: if f throws or propagates an exception, the state of the program will be as if `f` had not been called
3. no-throw guarantee: f will never throw an exception and will always accomplish its task

### 1. basic guarantee
```C++
void f() {
    MyClass mc;
    auto p = std::make_unique<MyClass>();
    g();
}
```

### 2. strong guarantee
we can use pimpl if all functions/methods called in our funciton also offer a strong or no-throw guarantee

### 3. no-throw guarantee
```C++
void f() noexcept; // the function f() does not throw

void f() noexcept(true); // the function f() does not throw; same as just noexcept
void f() noexcept(false); // the function f() is potentially throwing; same as if you did not use noexcept at all
```

If the move constructor and move assignment operator only swap basic values then declare them as noexcept functions to allow collection classes such as std::vector to be more efficient when storing objects of that class. 

## Template functions
heres an example: 
```C++
template <typename Iter, typename Func>
void for_each (Iter start, Iter finish, Func f) {
    while (start != finish) {
        f(*start);
        ++start;
    }
}
void f (int n) { cout << n << endl; }
. . .
int a [] = {1, 2, 3, 4, 5};
. . .
for_each(a, a+5, f); // prints the array
```

## Function objects 
```C++
class Plus1 {
  public:
    int operator() (int n) { return n + 1; }
};
. . .
Plus1 p;
p(4); // produces 5
```
## Lambda functions (anonymous functions)
```C++
vector <int> v { . . . };
int x = count_if(v.begin(), v.end(), [](int n) { return n % 2 == 0; });
```

