# CS 246 - Object Oriented Software Development | Fall 2020

# Linux File Permissions 

Permission information: d rwx r-x ---
- first character: `d` if directory, `-` if file
- next three are read (`r`), write (`w`), executable (`x`)
- first three are user, next three are group, next three are other (everyone)

## chgrp - change group

Changes group-name associated with a file

Usage: `chgrp [-R] group-name file/directory-list`

## chmod - change permissions

Changes permissions of a file

Usage: `chmod [-R] mode-list file/directory-list`
- `mode-list` has the form : `security-level operator permission`
- securty-level is: user (`u`), group (`g`), other (`o`), all (`a`)
- Operator `+` adds permission, `-` removes permission, `=` sets permission

Example: `chmod go-rw foo`, `chmod a+r schedule.html`, `chmod g=rw test.txt`


# The File System 
**path:** is the general name of a file or directory in textual format

Note: directories in linux are just a specialized form of file
- they can be edited but it is dangerous to do so 

## Absolute and relative paths
`/` is the **root** directory

`.` is the current directory, `..` is the previous directory

## Changing the current directory
`cd` to change directory        
`pwd` to display path of working directory      

## The home directory
Each new user is given their own **home directory**
- this is a directory owned by the user where they can place their personal files without disturbing other users

when writing a pathname, the shell replaces the special character `~` with the absolute path of your home directory.        

## The $PATH variable
When the name of a file is given without a path then the shell looks in locations defined global system variable named `$PATH`      
The contents of the `$PATH` variable are a list of pathnames separated by the colon character (:)
```
$ echo $PATH
/home/bob/bin:/user/local/bin:/usr/bin
```

you can run a program by giving its path to the shell           

you can add to the $PATH variable by (this doesn't affect existing PATH values):
```
export PATH=$PATH:/location/program
```

# The shell


A **shell** is a program that runs and gives an interface to communicate with the opreating system 

In most linux distributions, a program called bash acts as the shell

SSH (Secure SHell) connection allows us to user the shell on another computer through the internet. 

**Standard input:** `stdin` is a device where from the shell is reading text input              
**Standard output:** `stdout` is a device where the shell is writing text output        
**Standard error:** `stderr` is a device where the shell writes error messages to            

## The command `ls`
The command `ls -l` displays a long form of the list with the following information:            
- **type:** `-` for a file, `d` for directory
- **permissions:** three groups of three bits
    - 3 for user, 3 for group, 3 for other
- **owner:** the ID of the user that owns the file
- **group:** a user can belong to one or more group
- **size:** size of the file in bytes
- **modified:** the date and time it was last modified
- **name:** the file name


## Executing commands

`bash` can run in an interactive (user provides commands) or non-interactive mode (a script file)

## The command prompt
command prompt is what the shell displays in interactive mode when it is waiting for user input

### Types of commands
**Scripts:** are text files that contain commands in a specific programming language. 
- interpreters interpret and execute the commands

**Programs:** are files that contain commands in binary format. They can be understood the operating system not by a human                  
and can be run without an interpreter 

## Input/Output redirection

### The command `cat`

`cat` simple reads the contents of standard input and writes it back to standard output

### Redirecting input and output

you can use the shell's **redirect** `cat`'s standard input and output devices to read from or write to fiels.      

`cat < file1.txt` 
- cat is doing the same thing but instead of `stdin` being the keyboard it will be `file1.txt`

you can also redirect the standard output using `>`             
`cat > file2.txt`
- this will make cat reading from the keyboard and output to `file2.txt`

you can combined both redirections.         
```
cat < file1.txt > file2.txt
```
- this will read from file1 and write to file2

you can redirect the standard error device with `2>`. For example:          
```
cat < file1.txt > file2.txt 2> log.txt
```
- this will write error messages to `log.txt`

## Commans-line arguments

### Passing command-line arguments
you can pass arguments to a program or script by writing each argument separated by a space after the command name:             
```
cat -n file1.txt
```
- here the `-n` argument makes cat prefix each line with a line number

### Difference between arguments and input redirection

`cat -n < file1.txt` essentially dose the same thing as `cat -n file1.txt` but they are different
- the first has the **shell** redirect `stdin` so that it's `file1.txt`
- the second passes "file1.txt" to cat which then has to look for the file to read from it

the program `echo` reads each command-line argument to `stdout`

```
$ echo a file1.txt
a file1.txt
$ echo a < file1.txt
a 
$
```
- the second time echo is called `file1.txt` is not printed because its not an argument (its an instruction for the shell to redirect `stdin`)
    - this demonstrates the difference between arguments and input redirection

### Quoting arguments

Spaces are treated as separators between arguments. If you want to pass an argument that contains spaces you need to quote it.      
`'` single quotes will not interpolate anything. `"` duoble quotes will interpolate. 

```
$ echo "My shell is $0"
My shell is -bash
$ echo 'My shell is $0'
My shell is $0
```

### Pipes
**pipes** allow us to use the output of one program as the input of another by connecting the second program's `stdin` to the first's `stdout`      

- The command `head -n` gives the first n lines of a file
- the command `wc -w` counts the words in the input

We can combine these two programs by piping them. A pipe is made using the the character `|`        
```
head -20 file.txt | wc - w
```
- this counts the words in the first 20 lines of `file.txt`

``` 
cat file.txt | head -20 | wc -w > words.txt
```
- cat outputs `file.txt` to head
- file is passed to `head` which is passed to `wc` and finally the number of words is redirected to `words.txt`


**Note:** echo changes whitespace of a file, do not combine `echo` with `cat` if u need to preserve the original file format        


## Globbing patterns

The shell can automaticall expand a few wildcard patterns to match all the files that satisfy the pattern. 
- this is known as **globbing**
```
cat *.txt
```
- `*.txt` is known as a **globbing pattern**, the wildcard `*` means "match any sequence of characters>" 

The following operators can be used in globbing patterns
- `*` : matches zero or more characters
- `?` : matches zero or one character
- `+` : matches at least one character
- `[abc]` : matches exactly one of the characters in the brackets
- `[!abc]` : matches any character *except* the ones in the brackets
- `[a-z]` : matches any character in the given range
- `{pat1, pat2}` matches either `pat1` or `pat2` (note no spaces)

# Regular Expressions

## Introduction to pattern matching

We will use the tool `egrep` which looks for lines that match a pattern. 
- `grep` is the less powerful predecessor of `egrep`

```
$ egrep "CS246" < tasks.txt
CS246: Assignment 2
anth221: Discuss conflict with CS246
```
- looks for lines with exactly "CS246"

```
$ egrep "(CS246|cs246)" < tasks.txt
CS246: Assignment 2
cs246 : Exam 1
anth221: Discuss conflict with CS246
```
- looks for lines with either "CS246|cs246"

The syntax `(x|y)` matches to either the pattern `x` or `y`

```
$ egrep "(CS|cs)246" < tasks.txt
CS246: Assignment 2
cs246 : Exam 1
anth221: Discuss conflict with CS246
```

`egrep` also has argument `-i` which ignores case
- this is blunt because it will accept "Cs246" and "cS246" 

`^` means "beginning of line" in regular expressions

```
$ egrep "^(CS|cs)246:" < tasks.txt
CS246: Assignment 2
```

## Advanced patterns
It is common to want to match to a pattern or nothing, the sorthand is `?`
```
$ egrep "^(CS|cs)246 ?:" < tasks.txt
CS246: Assignment 2
cs246 : Exam 1
```
- this makes the space before the colon optional 

```
$ egrep "^(CS|cs)246 *:" < tasks.txt
CS246: Assignment 2
cs246 : Exam 1
```
- this makes the space before the `*` repeatable, it will match to either 0 or any number of repetitions of the space 
- if we wanted it to match to at least one ore more of the space we can change the `*` to `+` which means at least one of the repetition must exist

```
$ egrep "^(CS|cs)246 +:" < tasks.txt
cs246 : Exam 1
```

## Pattern reference
- The basic battern is all normal characters. `e` matches to "e"
- `(XYZ)` groups patterns, usually in order to use `|`,`*`,or `+` on a whole group
    - for example `(CS246)*` matches to "" or "CS246" or "CS246CS246"
- `(X|Y)` matches either `X` or `Y`
- `[...]` matches any of the *characters* between the square brackets
    - `[cC][sS]` is equivalent to `(c|C)(s|S)`
- `[...]` can also match *ranges* of characters, specified with `a-z`. 
    - `[a-z0-9]` matches all lower case letters and numbers
    - `[a-df-z]` matches all lower case letters except for "e"
- `[^...]` is an inversion of `[...]` (matches anything except what's specified)
    - `[^a-z]` matches anything other than a lower-case character
    - it must match to something tho, `CS[^3]46` will not match to "CS46" but will match "CS246" 
- `*` matches repetition of a pattern 0 or more times
    - repeats the pattern not the matched string so `(c|C)*` matches "cCCCcccCCcCCC"
- `+` matches repetition of pattern 1 or more times
- `?` matches repetition of a pattern 0 or 1 time. 
    - `a?` matches either "" or "a"
- `.` matches any single character. Often used to combined patterns that are separated by random tings
    -  `(CS246.*ANTH221|ANTH221.*CS246)` matches to ant and cs with anything between
- `^` matches beginning of line
    - `^CS246` matches to the line that starts with "CS246"
- `$` matches end of line
    - `CS246$` matches to the line that ends with "CS246"
    - `^CS246$` matches to the line that is exactly "CS246"
- `\` escapes special characters
    - be carefule the shell interprets `\` on its own so you should use it in single quotes (which will not interploate)

Here's an example
```
$ egrep "^(CS|cs)2[0-9][0-9] *:.*[Aa]ssignment" < tasks.txt
CS241: Finish assignment 1
CS246: Assignment 2
```
- matches to cs with 2 numbers after and with a colon and followed by assignment

## bash, egrep, and quotation marks

Since we just started with `bash` it is recommended to using `'` single quotes around `egrep` patterns to avoid bash substitutions             

```
$ echo "\hi"
\hi
$ echo "\\"
\
$ echo "\\hi"
\hi
$ echo "$PATH"
/usr/bin:/bin
$ echo "\$PATH"
$PATH
```
In comparison to:               
```
$ echo '\hi'
\hi
$ echo '\\'
\\
$ echo '\\hi'
\\hi
$ echo '$PATH'
$PATH
$ echo '\$PATH'
\$PATH
```

# Bash Scripts

## Introduction
### Creating a script file
It is convention, but not necessary, to use `.sh` for bash script files

```
#!/bin/bash 
date 
whoami 
pwd
```
- the first line is called a **shebang** line
- it tells the shell which language the script is written in 
- the argument `-x` can be added to show verbose output
    - this will be helpful for assignment 1

we can run the program by telling bash to execute it `basic basic.sh`

### Running a script file
The general rules for setting up a script file are: 
1. insert a **shebang** line as your first line
2. always add user-level execute permission 

# Bash as a programming language

adding `-x` will make the script show every command and its arguments as it executes

## Variables

Good list of potential problems [here](https://www.linuxtopia.org/online_books/advanced_bash_scripting_guide/gotchas.html)

Variable naming should follow similar naming conventions to C variable names.

When assigning veriables there should never be a `$`, a `$` is only used to retrives values from a variable. 

``` 
x=1
echo $x
```
- the 1 is a string
- there must be no whitespace around the `=` operator, otherwise its an error

it is good idea to user curly braces `{}` around variable names when retrieving their value `${x}`

there are a lot of global variables available to you. 
    - use the env command to see many of them

### Special shell variables

- `$0` the first parameter of the command-line and its arguments; the shell-script name
- `$1, $2, etc` each command-line argument, based upon its position
- `$#` the total number of command-line arguments
- `$?` the exit/return value of the most recently executed command; used to tell us whether it succeeded or failed
    - 0 means success, not-0 (any other value) means failure

```
#!/bin/bash

egrep "^$1$" /usr/share/dict/words
```
- this returns the word if its in the dictionary


## Selection statements

if statement general structure must follow one of the two following forms: 
```
if condition1 ; then
    statement1
    statement2
elif condition2 ; then
    statement3
...
else
    statement4
    statement5
fi
```
or 
```
if condition1
then
  statement1
  statement2
elif condition2
then
    statement3
...
else
    statement4
    statement5
fi
```
- note that if you want the keyword then to be on the same line as `if/elif` you must separate it with a semicolon from the condition

### specifying conditions
a conditions is generally specified with `[ ]` a pair of open square brackets. There must be a black space between the opening square bracked and the closing square bracket
```
if [ -e foo.txt ]; then
    cat foo.txt
fi
```

```
if [ $foo -eq 2 ]; then
    echo equals 2
else
    echo not equal 2
fi
```

if you want to combine conditions using "and" or "or" use the keywords `-a` or `-o`. 

## Functions

functions can only return a positive integer value, 0 to 255, so we don't need to specify a return-type

```
foo() {
    echo "name is: " ${0}
    echo "foo argument 1 is: " ${1}
    echo "foo argument 2 is: " ${2}
    echo "foo argument 3 is: " ${3}
    if [ ${1} = "cat" ]; then
        return 0
    fi
    return 1
}
```
and `foo` is called by saying: 



```
foo ${3} ${2} ${1}
echo 'foo returned ${?}' ${?}
```

## Loops
bash provied two main types of loops, a counted loop and a loop that iterates over a list of items

here the general forms of a counted loop: 
```
while [ cond ]; do
    ...
done

until [ cond ]; do
   ...
done

for (( expr1; expr2; expr3 )) ; do
   ...
done
```

and here are examples of the forms: 

```
x=1
while [ ${x} -le 5 ]; do
   echo ${x}
   x=$((x + 1))
done

x=1
until [ ${x} -gt 5 ]; do
   echo ${x}
   x=$((x + 1))
done

for (( x=1; x <= 5; x++ )) ; do
    echo ${x}
done
```

- the special syntax `$(( ... ))` is used to tell the shell that the information within the doubled parentheses are to be treated as integers.


here is a list iteration loop: 

```
for variable in list; do
   command1
   command2
   ...
done
```

# Software testing

software can be tested manually by a human or automatically by a machine

In **automated testing** test suites are implemented that automatically test the software and compare results with expected ones.           
- in general **test suites** should contain a list of input sets and matching expected outputs 

## Types of software tests
**Unit tests**
- conducted at the lowest level, testing one specific module/unit of the software       

**Integration tests**
- verify if the different modules/units of the software work correctly together

**Functional tests (system tests)**
- verifies if application produces the correct outputs, here we are not conerned with how results are produced

**Acceptance tests**
- part of a formal process where client must verify that produced software meets all the requirements
    - can be split into phases such as **alpha testing** (end of development, subset of users, in developer environment) and **beta testing (end of development after alpha tests, subset of users, in user's environment)

**Regressions tests**
- conducted after any modification in the software to ensure no errors were introduced

**Performance tests**
- verify if the run-time performance of teh system will be adequate

## White/Black box tests

White box tests: 
- created with knowledge of internal structure of a program
- generalyl used to verify internal structures of a program instead of expected functional requirements
- most common for unit tests

Black-box tests: 
- tests created based only on the requirement specifications, without any knowledge of internal structure of program            
- verify if software works according to specification

Grey-box tests: 
- a mix of the two approaches above

Creating black-box test: 
- identify the different classes of input (numeric ranges, positive vs. negative, etc.)
- test the boundaries of valid ranges (edge cases), e.g., min and max values
- test multiple simultaneous boundaries (corner case)
- test extreme cases 
- intuition - with experience you can begin to guess likely errors

creating white-box tests
- the tests execute all logical paths through the program
the tests make sure that every function runs












