# Computer Organization and Design 

## Motivations: 
Course goals: 
Understanding of computer architecture, structure and evolution
- Computer architecture = instruction set architecture & computer organization 
- Instruction set architecture: 
    - conceptual structure and functional behaviour of computing system as seen by programmer
- Computer organization: 
    - physical implementation, described in terms of function units, their interconnection, how information flow among them is controlled

Why this course is taught: 
- Understanding what's inside the computer
- Material is used in future courses 
- Architecture issues influence programming
    - for example initializing a 2D array row-by-row is much faster than going by column

**A brief look at electricity:**
- Comuter work with current/voltage $V = IR$ (voltage = current * resistance)
- These are continuous values (can graph them) 
- Can be manipulated by accuracy is difficuly

**Digitizing**
- Discrete signal (high voltage or low voltage, [5V or 0] most modern computers are ~1V and 0V). 
- Signal is either high (1) or low (0)
- Transformation could lead to intermediate values 
    - we're going to assume they're taken care of and are "designed" out by engineers

**Why binary?**
- Two level are simpler and equally expressive
- Nearly all computers today use binary
- Nearly all computer have similar underlying structure             

**Course outline:**
- ARM overview, brief discussion of performance 
- digital logic design
- data representation and manipulation
- + designing a datapath
- + single-cycle control units
- + multiple-cycle controler units
- + pipelining and hazards 
- + memory hierarchies (**caches** and virtual memory)
- input/output
- multiprocessor systems
- case studies: VAX, SPARC, Pentium

**CS 251 topics continued in other courses:**
- CS 240: memory management
- CS 350: operating systems
- CS 343: concurrency
- CS 370: scientific computation
- CS 454: distributed systems
- CS 456: networks

## Adminstrative overview
Weekly: quiz and/or assignment each week        

Videos (broken up into the following): 
- Content, Examples, Review, Details

Quizes:
- simple set of questions to ensure students are going through content 
    - only covers the current week of material

Assignments: 
- will cover more material and more challenging
- occur every two weeks

Term test: 
- bulk of grade (timed 2 hours) prepare for them like midterm


# Arm Overview

ARM: 
- Advanced RISC Machines
- RISC: Reduced Instruction Set Computer
    - CISC: Complex Instruction Set Computer

## Registers
Registers:
- temporary storage units which maintain binary information (e.g, 64 bit register)
- you can only manipulate values in a register 
    - so you take values from memory manipulate in registers then write to memory

There are 32 registers
- can use like a variable in a program, but via ARM instruction
    - each register has 64 bits, eight bytes
    - X0, X1, ..., X31
    - X31 always contains 0
    - Example: ADD X1, X2, X3 (add X2, X3 and store in X1) comes in R-Format (two source registers and one destination)

Example: `f = (g + h) - (i + j)`        
Lets assume X1:f X2:g X3: h X4:i X5:j       
```
ARM: 

ADD X6, X2, X3
ADD X7, X4, X5
SUB X1, X6, X7
```
- it will actually be more than 3 instructions since we need to load the values in a full example and we would also have to populate f in memory

## Instruction
Five general types of ARM instructions      
Format refers to how many and what type of operands         
- R-format: `ADD X1,X2,X3`
    - adds content of X2 to contents of X3; store result in X1
- D-format: `LDUR X1, [X2, #20]`
    - load data from memory address X2+20 into register X1
    - `STUR X1, X2, #100` store data from X1 into memory at address X2+30
- I-format: `ADDI X1, X2, #100`
    - adds immediate value 100 to contents of X2; store result in X1 
- B-format: `B #28`
    - set program counter to PC+4\*28
- CB-format: `CBZ X1,#8`
    - if X1==0 then set program counter to PC+(4x8)

Program counter: 
- keeps track of the address of whic instruction is executing and which instruction will come next
    - adress go up by 4

## Memory
- Arm can access $2^{64}$ bytes of random access memory (RAM)
- Memory accesd with number from 0 to $2^{64} - 1$
- Usually grouped in 4-byte blocks called *words* or 8-byte blocks called *double-words*
    - most memory accesses are to addresses that are multiple 4 or 8
- Both ARM program and data are stored in memory
- Instructions are 32-bits (4 bytes)
- Each instruction adress is a multiple of 4

## Control flow 
- In ARM, no conditionals like `if` nor loop constructions like `for` or `while`
- Control flow handled by goto-like commands
    - branch (unconditional goto)
    - CBZ (conditional goto)
- Special register, *program counter* (PC), stores address of executing instruction
- When non-goto instruction executed, PC incremented by 4. This auto-increment advances the program to the next instruction

### Branch instruction
Branch: `B`
```
100: B #3
104: ...
108: ...
112: ... // this line
```
- when branch is executed PC is set to PC + 4 times the immediate argument
- BTA : Branch target address 

### Conditional branch
Example: `CBZ X1, #100` (or -100)
- Compare contents of register X1 to zero. If equal add 4 times constant and add to PC. 
    - if register is not zero the instruction following branch is executed (PC+4)
- constant can be negative
- `CBNZ` is similar but looks for if the register is **not** zero

Example: 
```
100: ADD X1, XZR, XZR
104: ADD X2, XZR, #6
108: ADDI X1, X1, 5
112: SUBI X2, X2, 1
116: CBNZ X2, #-2
120: ADD X4, X6, X8
```

### Memory access
Three general categories of instructions in every Instruction Set Architecture
1. computation (arithmetic format)
2. control flow
3. data manipulation (memory access) (loading and storing)

Load Unscaled Register (LDUR): Reads a double word from memory and stores this to register         
`100: LDUR X1, [x2,#100]`       
- loads from the address at to 100 + x2
Read value stored at memory address 100+X2 (M[100+X2]). Store result in register X1.        

Store Unscaled Register (STUR): takes the value contained in a register 64-bit) value and writes it to memory
- `100: STUR X1, [X2,#100]`




    

